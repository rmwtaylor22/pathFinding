--[ 2019.10.29.10.14.46.405.0 ]--
NewLogger: P04_Pathfinding
Version: 1.3
--[ 2019.10.29.10.14.46.458.0 ]--
InitTree:
/src/algs4.jar
/src/Coord.java
/src/stdlib.jar
/src/Walker.java
/src/Terrain.java
/src/Pathfinder.java
/src/TerrainEditor.java
/src/PathfinderVisualizer.java
/src/InteractivePathfinderVisualizer.java
/.log/history.log
/.idea/copyright/profiles_settings.xml
/.idea/libraries/algs4.xml
/.idea/libraries/stdlib.xml
/.idea/.name
/.idea/misc.xml
/.idea/modules.xml
/.idea/compiler.xml
/.idea/workspace.xml
/.idea/uiDesigner.xml
/heightmaps/.donotlog
/heightmaps/png2emap.py
/heightmaps/ramp.png.emap
/heightmaps/ramp2.png.emap
/heightmaps/ramp3.png.emap
/heightmaps/mazeAB.png.emap
/heightmaps/usa128.png.emap
/heightmaps/usa256.png.emap
/heightmaps/usa1024.png.emap
/heightmaps/maze32_0.png.emap
/heightmaps/maze32_1.png.emap
/heightmaps/maze232_0.png.emap
/heightmaps/maze320_0.png.emap
/heightmaps/mazeBrain.png.emap
/.cos265
/readme.html
/P04_Pathfinding.iml

--[ 2019.10.29.10.14.46.460.0 ]--
InitFile: /src/Terrain.java
import java.lang.IndexOutOfBoundsException;

/**
 * Terrain stores elevations for map and computes distance and
 * cost in traversing the terrain.
 */

public class Terrain {
    private int N;
    private int[][] heights;

    public Terrain(int N) {
        this.N = N;
        this.heights = new int[N][N];
    }

    public Terrain(int[][] heights) {
        this.N = heights.length;
        this.heights = heights;
    }

    public Terrain(String emapfile) {
        In in = new In(emapfile);
        this.N = in.readInt();
        this.heights = new int[N][N];
        for (int j = 0; j < N; j++) {
            for (int i = 0; i < N; i++) {
                this.heights[i][j] = in.readInt();
            }
        }
    }

    public int getN() {
        return N;
    }

    public void setHeight(int i, int j, int h) {
        if(i < 0 || j < 0 || i >= N || j >= N)
            throw new IndexOutOfBoundsException("i and j must be in [0,N)");
        heights[i][j] = h;
    }
    public void setHeight(int i, int j, float h) {
        setHeight(i, j, (int) h);
    }
    public void setHeight(Coord loc, int h) {
        setHeight(loc.getI(), loc.getJ(), h);
    }
    public void setHeight(Coord loc, float h) {
        setHeight(loc.getI(), loc.getJ(), h);
    }

    public int getHeight(int i, int j) {
        if(i < 0 || j < 0 || i >= N || j >= N)
            throw new IndexOutOfBoundsException("i and j must be in [0,N)");
        return heights[i][j];
    }
    public int getHeight(Coord loc) {
        return getHeight(loc.getI(), loc.getJ());
    }

    // computes distance between (i0,j0) and (i1,j1) as the crow flies
    public float computeDistance(int i0, int j0, int i1, int j1) {
        return (float)Math.sqrt((i0 - i1) * (i0 - i1) + (j0 - j1) * (j0 - j1));
    }
    public float computeDistance(Coord c0, Coord c1) {
        return computeDistance(c0.getI(), c0.getJ(), c1.getI(), c1.getJ());
    }

    public float computeTravelCost(int i0, int j0, int i1, int j1) {
        float h0 = getHeight(i0, j0), h1 = getHeight(i1, j1);
        float climb = (float)Math.pow(Math.abs(h0 - h1) * 1000.0, 1.5);
        float dist = computeDistance(i0,j0, i1,j1);
        return (1.0f + climb) * dist;
    }
    public float computeTravelCost(Coord c0, Coord c1) {
        return computeTravelCost(c0.getI(), c0.getJ(), c1.getI(), c1.getJ());
    }
    public float computeTravelCost(Iterable<Coord> cs) {
        Coord c0 = null;
        float cost = 0.0f;
        for(Coord c1 : cs) {
            if(c0 != null) cost += computeTravelCost(c0, c1);
            c0 = c1;
        }
        return cost;
    }
}

--[ 2019.10.29.10.14.46.462.0 ]--
InitFile: /src/PathfinderVisualizer.java
/**
 * PathfinderVisualizer visualizes the terrain and found path.
 */

import java.awt.Color;
import java.awt.Font;

public class PathfinderVisualizer {

    // delay in milliseconds (controls animation speed)
    private final static int DELAY = 100;

    // color for different elevations.  must be in ascending order!
    private final static int[][] elevationColors = {
            // h    r   g   b   where h=height, r=red, g=green, b=blue
            {  0,   0,  0,  0},
            {  2,   0,  0,160},
            {  4,   0,224,224},
            { 16, 192,192,  0},
            { 64,  16,255, 16},
            {128,  32,224, 32},
            {192, 128,128,  8},
            {224, 164,164,164},
            {255, 255,255,255}
    };

    private final static Color cStart    = new Color(128, 128, 255);
    private final static Color cEnd      = new Color(255, 128, 128);
    private final static Color cSolution = new Color(255, 128, 255);
    private final static Color cSearched = new Color(128,   0, 128);

    // linearly interpolating between the corresponding rgb values
    private static Color colorLERP(float v1, int r0, int g0, int b0, int r1, int g1, int b1) {
        v1 = Math.max(0.0f, Math.min(1.0f, v1));
        float v0 = 1.0f - v1;
        int r = (int)(v0 * r0 + v1 * r1);
        int g = (int)(v0 * g0 + v1 * g1);
        int b = (int)(v0 * b0 + v1 * b1);
        return new Color(r, g, b);
    }
    private static Color colorLERP(float v1, Color c0, Color c1) {
        v1 = Math.max(0.0f, Math.min(1.0f, v1));
        float v0 = 1.0f - v1;
        int r = (int)(v0 * c0.getRed()   + v1 * c1.getRed());
        int g = (int)(v0 * c0.getGreen() + v1 * c1.getGreen());
        int b = (int)(v0 * c0.getBlue()  + v1 * c1.getBlue());
        int a = (int)(v0 * c0.getAlpha() + v1 * c1.getAlpha());
        return new Color(r, g, b, a);
    }

    // returns color for given height
    private static Color height2Color(int h) {
        h = Math.max(0, Math.min(255, h));

        int[] ec0 = elevationColors[0];  // default lower bound
        int[] ec1 = elevationColors[1];  // default upper bound

        // find upper bound while updating lower bound
        for(int i = 1; i < elevationColors.length; i++) {
            ec1 = elevationColors[i];
            if(h >= ec0[0] && h <= ec1[0]) break;
            ec0 = ec1;
        }

        int h0=ec0[0], r0=ec0[1], g0=ec0[2], b0=ec0[3];
        int h1=ec1[0], r1=ec1[1], g1=ec1[2], b1=ec1[3];
        float v1 = ((float)(h - h0)) / ((float)(h1 - h0));

        return colorLERP(v1, r0, g0, b0, r1, g1, b1);
    }

    private static void drawCircle(int i, int j, int N, double rad) {
        int c = (int)((i+0.5f) * 464.0f / N);
        int r = (int)((j+0.5f) * 464.0f / N);
        StdDraw.circle(c + 24, 464 - r + 36, rad);
    }
    public static void drawCircle(Coord loc, int N, double rad) {
        drawCircle(loc.getI(), loc.getJ(), N, rad);
    }

    private static void drawPath(Iterable<Coord> path, int N) {
        boolean first = true;
        int c0 = 0, r0 = 0;
        for (Coord loc : path) {
            int c1 = (int)((loc.getI()+0.5f) * 464.0f / N);
            int r1 = (int)((loc.getJ()+0.5f) * 464.0f / N);
            if(!first) {
                StdDraw.line(c0 + 24, 464 - r0 + 36, c1 + 24, 464 - r1 + 36);
            }
            first = false;
            c0 = c1; r0 = r1;
        }
    }

    // draw N-by-N pathfinding map
    public static void draw(Terrain terrain, Pathfinder pf, Walker walker, int N) {
        StdDraw.clear();
        StdDraw.setXscale(0, 512);
        StdDraw.setYscale(0, 512);
        StdDraw.setPenColor(StdDraw.BLACK);
        StdDraw.filledSquare(256, 256 + 12, 464 / 2);

        // draw terrain
        for(int row = 0; row < 464; row++) {
            int j = (int)((float)row/464.0f * N);
            for(int col = 0; col < 464; col++) {
                int i = (int)((float)col/464.0f * N);
                Coord loc = new Coord(i,j);
                Color c = height2Color(terrain.getHeight(loc));
                if(pf.wasSearched(loc)) {
                    c = colorLERP(0.50f, c, cSearched);
                }
                StdDraw.setPenColor(c);
                StdDraw.filledSquare(col + 24, 464 - row + 36, 1);
            }
        }

        // draw path start
        if(pf.getPathStart() != null) {
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            drawCircle(pf.getPathStart(), N, 4.0);

            StdDraw.setPenColor(cStart);
            StdDraw.setPenRadius(0.002);
            drawCircle(pf.getPathStart(), N, 4.0);
        }

        // draw path end
        if(pf.getPathEnd() != null) {
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            drawCircle(pf.getPathEnd(), N, 4.0);

            StdDraw.setPenColor(cEnd);
            StdDraw.setPenRadius(0.002);
            drawCircle(pf.getPathEnd(), N, 4.0);
        }

        // draw found path
        if(pf.foundPath()) {
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            drawPath(pf.getPathSolution(), N);

            StdDraw.setPenColor(cSolution);
            StdDraw.setPenRadius(0.002);
            drawPath(pf.getPathSolution(), N);
        }

        // draw walker
        if(walker != null) {
            Coord loc = walker.getLocation();
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            PathfinderVisualizer.drawCircle(loc, N, 2.0);

            StdDraw.setPenColor(StdDraw.WHITE);
            StdDraw.setPenRadius(0.002);
            PathfinderVisualizer.drawCircle(loc, N, 2.0);
        }

        // write status text
        StdDraw.setFont(new Font("SansSerif", Font.PLAIN, 12));
        StdDraw.setPenColor(StdDraw.BLACK);
        StdDraw.text(96, 12, "heuristic: " + pf.getHeuristic());
        if(pf.foundPath()) StdDraw.text(256, 12, "path: " + pf.getPathCost());
        else               StdDraw.text(256, 12, "no path found");
        StdDraw.text(512-96, 12, "searched: " + pf.getSearchSize() + " (" + (int)(100.0f * pf.getSearchSize() / (N*N)) + "%)");
    }
}

--[ 2019.10.29.10.14.46.464.0 ]--
InitFile: /src/InteractivePathfinderVisualizer.java
import java.awt.event.KeyEvent;

/**
 * InteractivePathfinderVisualizer visualizes the terrain and the computed
 * path and allows the user to change parameters of the Pathfinder.  Below
 * is a list of commands and what they do.  Note: some of the commands
 * modify the properties of the path finder and some modify the terrain.
 *
 * Command        Action                                      Terrain
 * C              clear path
 * space          recompute path
 * S/E            set start/end location to mouse
 * left/right     halve/double path search heuristic value
 * 0/1            set path search heuristic to 0 or 1
 * W              start a walker to show the path
 * R              randomly generate a new terrain                *
 * M              smooths terrain under mouse                    *
 * shift+M        smooths all terrain                            *
 * up/down        increase/decrease terrain under mouse          *
 */

public class InteractivePathfinderVisualizer {
    private final static int DELAY = 10;

    // sets how many redraws it should take for the walker to reach its destination
    private final static float STEPS_TO_WALK = 100.0f;

    // for convenience, here are the emap files that are located under heightmaps/ folder
    // the python script in that folder converts png files to emap. \
    // you can use it to create your own maps to test your code
    private final static String[] emaps = {
            "maze32_0.png.emap",    // 0   (32x32 maze)
            "maze32_1.png.emap",    // 1   (another 32x32 maze)
            "maze232_0.png.emap",   // 2   (232x232 maze)
            "maze320_0.png.emap",   // 3   (same as maze32_0, only scaled up by 10x)
            "mazeAB.png.emap",      // 4   (a maze from a site no longer online :( )
            "mazeBrain.png.emap",   // 5   (...)
            "ramp.png.emap",        // 6   (some tests)
            "ramp2.png.emap",       // 7   (...)
            "ramp3.png.emap",       // 8   (...)
            "usa128.png.emap",      // 9   (elevation map of USA from https://bananas.openttd.org/en/heightmap/)
            "usa256.png.emap",      // 10  (same as usa128, only higher resolution)
            "usa1024.png.emap",     // 11  (same as usa128, only higher resolution
    };

    private final static String emapFilename = emaps[2];        // change index to load a different elevation map



    public static void main(String[] args) {
        Terrain terrain = new Terrain(emapFilename);
        Pathfinder pf = new Pathfinder(terrain);
        int N = terrain.getN();

        StdDraw.show(0);

        // set default starting and ending locations
        pf.setPathStart(new Coord(1, 1));
        pf.setPathEnd(new Coord(N-3, N-3));

        // find a path
        pf.computePath();

        PathfinderVisualizer.draw(terrain, pf, null, N);
        StdDraw.show(DELAY);

        // prevent repeated applications
        boolean keyboardR = false;
        boolean keyboardM = false;

        Walker walker = null;

        while(true) {
            boolean recompute = false;
            boolean redraw = false;

            // mouse location on map
            int mouseI = (int) ((StdDraw.mouseX()-24) / 464 * N);
            int mouseJ = (int) ((464 - (StdDraw.mouseY()-36)) / 464 * N);
            boolean isMouseOnMap = (mouseI >=0 && mouseI < N && mouseJ >= 0 && mouseJ < N);

            if(StdDraw.isKeyPressed(KeyEvent.VK_LEFT) || StdDraw.isKeyPressed(KeyEvent.VK_RIGHT)) {
                boolean keyboardLeft = StdDraw.isKeyPressed(KeyEvent.VK_LEFT);
                float m = keyboardLeft ? 0.5f : 2.0f;
                float h = pf.getHeuristic() * m;
                h = Math.max(1.0f/1024.0f, Math.min(1048576.0f, h));
                pf.setHeuristic(h);
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_0) || StdDraw.isKeyPressed(KeyEvent.VK_1)) {
                boolean keyboard0 = StdDraw.isKeyPressed(KeyEvent.VK_0);
                float h = keyboard0 ? 0 : 1;
                pf.setHeuristic(h);
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_C)) {
                pf.resetPath();
                walker = null;
                redraw = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_R) && !keyboardR) {
                TerrainEditor.setFractalHeights(terrain);
                TerrainEditor.clampHeights(terrain);
                recompute = true;
            }
            keyboardR = StdDraw.isKeyPressed(KeyEvent.VK_R);

            if(StdDraw.isKeyPressed(KeyEvent.VK_M)) {
                if(StdDraw.isKeyPressed(KeyEvent.VK_SHIFT)) {
                    if(!keyboardM) {
                        TerrainEditor.smoothHeights(terrain);
                        recompute = true;
                    }
                } else {
                    TerrainEditor.smoothHeights(mouseI, mouseJ, N / 20, true, terrain);
                    recompute = true;
                }
            }
            keyboardM = StdDraw.isKeyPressed(KeyEvent.VK_M);

            if(StdDraw.isKeyPressed(KeyEvent.VK_SPACE)) {
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_UP) || StdDraw.isKeyPressed(KeyEvent.VK_DOWN)) {
                boolean keyboardUp = StdDraw.isKeyPressed(KeyEvent.VK_UP);
                float add = keyboardUp ? 8.0f : -8.0f;
                TerrainEditor.addHeight(mouseI, mouseJ, N / 20, add, terrain);
                recompute = true;
            }

            if(isMouseOnMap && StdDraw.isKeyPressed(KeyEvent.VK_S)) {
                pf.setPathStart(new Coord(mouseI, mouseJ));
                recompute = true;
            }

            if(isMouseOnMap && StdDraw.isKeyPressed(KeyEvent.VK_E)) {
                pf.setPathEnd(new Coord(mouseI, mouseJ));
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_W)) {
                Iterable<Coord> path = pf.getPathSolution();
                if(path != null) {
                    walker = new Walker(terrain, pf.getPathSolution());
                }
            }

            if(walker != null) {
                if(walker.doneWalking()) {
                    walker = null;
                } else {
                    walker.advance(pf.getPathCost() / STEPS_TO_WALK);
                }
                redraw = true;
            }

            if(recompute) {
                walker = null;
                pf.resetPath();
                if(pf.getPathStart() != null && pf.getPathEnd() != null) {
                    pf.computePath();
                }
                redraw = true;
            }

            if(redraw) {
                PathfinderVisualizer.draw(terrain, pf, walker, N);
                StdDraw.show(DELAY);
            } else {
                try {
                    Thread.sleep(10);
                } catch (InterruptedException e) {
                    /* do nothing */
                }
            }
        }
    }
}

--[ 2019.10.29.10.14.46.465.0 ]--
InitFile: /src/Pathfinder.java
import java.lang.IndexOutOfBoundsException;
import java.lang.IllegalArgumentException;

/**
 * Pathfinder uses A* search to find a near optimal path
 * between to locations with given terrain.
 */

public class Pathfinder {

    /**
     * PFNode will be the key for MinPQ (used in computePath())
     */
    private class PFNode implements Comparable<PFNode> {
        // loc: the location of the PFNode
        // fromNode: how did we get here? (linked list back to start)
        public PFNode(Coord loc, PFNode fromNode) { }

        // compares this with that, used to find minimum cost PFNode
        public int compareTo(PFNode that) {
            return 0;
        }

        // returns the cost to travel from starting point to this
        // via the fromNode chain
        public float getCost(float heuristic) {
            return 0;
        }

        // returns if this PFNode is not marked invalid
        public boolean isValid() {
            return false;
        }

        // marks the PFNode as invalid
        public void invalidate() {
        }

        // returns if the PFNode is marked as used
        public boolean isUsed() {
            return true;
        }

        // marks the PFNode as used
        public void use() { }

        // returns an Iterable of PFNodes that surround this
        public Iterable<PFNode> neighbors() {
            Stack<PFNode> s = new Stack<>();
            s.push(new PFNode(null, null));
            return s;
        }
    }

    public Pathfinder(Terrain terrain) {
    }

    public void setPathStart(Coord loc) {
    }

    public Coord getPathStart() {
        return null;
    }

    public void setPathEnd(Coord loc) {
    }

    public Coord getPathEnd() {
        return null;
    }

    public void setHeuristic(float v) {
    }

    public float getHeuristic() {
        return 0;
    }

    public void resetPath() {
    }

    public void computePath() {
    }

    public boolean foundPath() {
        return false;
    }

    public float getPathCost() {
        return 0;
    }

    public int getSearchSize() {
        return 0;
    }

    public Iterable<Coord> getPathSolution() {
        return null;
    }

    public boolean wasSearched(Coord loc) {
        return false;
    }
}

--[ 2019.10.29.10.14.46.466.0 ]--
InitFile: /.cos265


--[ 2019.10.29.10.14.46.468.0 ]--
InitFile: /P04_Pathfinding.iml
<?xml version="1.0" encoding="UTF-8"?>
<module type="JAVA_MODULE" version="4">
  <component name="NewModuleRootManager" inherit-compiler-output="true">
    <exclude-output />
    <content url="file://$MODULE_DIR$">
      <sourceFolder url="file://$MODULE_DIR$/src" isTestSource="false" />
      <sourceFolder url="file://$MODULE_DIR$/heightmaps" type="java-resource" />
      <excludeFolder url="file://$MODULE_DIR$/.log" />
    </content>
    <orderEntry type="inheritedJdk" />
    <orderEntry type="sourceFolder" forTests="false" />
    <orderEntry type="library" name="algs4" level="project" />
    <orderEntry type="library" name="stdlib" level="project" />
  </component>
</module>

--[ 2019.10.29.10.14.46.469.0 ]--
InitFile: /src/Coord.java
/**
 * Coordinates is an immutable type that store the tuple (i, j)
 */
public final class Coord {
    private final int i;
    private final int j;

    public Coord(int i, int j) {
        this.i = i;
        this.j = j;
    }

    public int getI() { return i; }
    public int getJ() { return j; }

    public boolean isInBounds(int minI, int minJ, int maxI, int maxJ) {
        return i >= minI && j >= minJ && i <= maxI && j <= maxJ;
    }
    public boolean isInBounds(Coord min, Coord max) {
        return i >= min.i && i <= max.i && j >= min.j && j <= max.j;
    }

    public Coord add(int addI, int addJ) {
        return new Coord(i + addI, j + addJ);
    }
    public Coord add(Coord that) { return new Coord(i + that.i, j + that.j); }

    public String toString() { return "(" + i + "," + j + ")"; }

    public boolean equals(Object o) {
        if(this == o) return true;
        if(o == null) return false;
        if(o.getClass() != this.getClass()) return false;
        Coord that = (Coord) o;
        if(this.i != that.i) return false;
        if(this.j != that.j) return false;
        return true;
    }
}

--[ 2019.10.29.10.14.46.470.0 ]--
InitFile: /src/Walker.java
import java.util.Iterator;

/**
 * Walker takes an Iterable of Coords and simulates an individual
 * walking along the path over the given Terrain
 */
public class Walker {

    // terrain: the Terrain the Walker traverses
    // path: the sequence of Coords the Walker follows
    public Walker(Terrain terrain, Iterable<Coord> path) {
    }

    // returns the Walker's current location
    public Coord getLocation() {
        return null;
    }

    // returns true if Walker has reached the end Coord (last in path)
    public boolean doneWalking() {
        return true;
    }

    // advances the Walker along path
    // byTime: how long the Walker should traverse (may be any non-negative value)
    public void advance(float byTime) {
    }

}

--[ 2019.10.29.10.14.46.472.0 ]--
InitFile: /src/TerrainEditor.java
/**
 * The following class provides some simple terrain editing functions.
 */
public class TerrainEditor {
    private static float rndRadius(float d) {
        return (float)StdRandom.uniform(-d,d);
    }

    private static float getFractalHeight(int i, int j, float dh, Terrain terrain, boolean[] isset) {
        int N = terrain.getN();
        dh = Math.max(-64, Math.min(255+64, dh));   // allow the height to go just a bit out of range
        if(!isset[i + j * N]) {
            isset[i + j * N] = true;
            terrain.setHeight(i, j, dh);
        }
        return terrain.getHeight(i,j);
    }

    private static void setFractalHeights(int i0, int j0, int i1, int j1, Terrain terrain, boolean[] isset) {
        int id = i1-i0;
        int jd = j1-j0;
        int i01 = (i0+i1)/2;
        int j01 = (j0+j1)/2;

        if(id <= 1 && jd <= 1) return;

        float h00 = getFractalHeight(i0,j0,32,terrain,isset);
        float h01 = getFractalHeight(i0,j1,32,terrain,isset);
        float h10 = getFractalHeight(i1,j0,32,terrain,isset);
        float h11 = getFractalHeight(i1,j1,32,terrain,isset);

        float d = (float)(Math.sqrt((i1-i0)*(i1-i0) + (j1-j0)*(j1-j0)) * 0.5);

        float d0001 = (h00 + h01) / 2 + rndRadius(d);
        float d0010 = (h00 + h10) / 2 + rndRadius(d);
        float d1101 = (h11 + h01) / 2 + rndRadius(d);
        float d1110 = (h11 + h10) / 2 + rndRadius(d);

        float h0001 = getFractalHeight(i0, j01, d0001, terrain,isset);
        float h0010 = getFractalHeight(i01, j0, d0010, terrain,isset);
        float h1101 = getFractalHeight(i01, j1, d1101, terrain,isset);
        float h1110 = getFractalHeight(i1, j01, d1110, terrain,isset);

        float dm = (float)((h0001 + h0010 + h1101 + h1110) / 4.0);
        float hm = getFractalHeight(i01, j01, dm, terrain,isset);

        if(id > 1 && jd > 1) {
            setFractalHeights(i0, j0, i01, j01, terrain, isset);
            setFractalHeights(i01, j0, i1, j01, terrain, isset);
            setFractalHeights(i0, j01, i01, j1, terrain, isset);
            setFractalHeights(i01, j01, i1, j1, terrain, isset);
        } else if(jd > 1) {
            setFractalHeights(i0, j0, i1, j01, terrain, isset);
            setFractalHeights(i0, j01, i1, j1, terrain, isset);
        } else {
            setFractalHeights(i0, j0, i01, j1, terrain, isset);
            setFractalHeights(i01, j0, i1, j1, terrain, isset);
        }
    }

    public static void setFractalHeights(Terrain terrain) {
        int N = terrain.getN();
        boolean[] isset = new boolean[N*N];
        setFractalHeights(0, 0, N - 1, N - 1, terrain, isset);
    }

    public static void smoothHeights(Terrain terrain) {
        int N = terrain.getN();
        int radius = (int)Math.ceil(Math.sqrt(N*N/2.0f));
        smoothHeights(N/2, N/2, radius, false, terrain);
    }

    public static void smoothHeights(int ic, int jc, int radius, boolean fallOff, Terrain terrain) {
        final int N = terrain.getN();
        final int w = 2*radius+1;
        float[] s = new float[w*w];
        for(int ia = -radius; ia <= radius; ia++) {
            int i = ic + ia;
            if(i < 0 || i >= N) continue;
            for(int ja = -radius; ja <= radius; ja++) {
                int j = jc + ja;
                if(j < 0 || j >= N) continue;
                int sidx = (ia+radius) + (ja+radius)*w;

                float m = computeEffect(i, j, ic, jc, radius, fallOff, N);
                if(m <= 0.0000001) {
                    s[sidx] = terrain.getHeight(i,j);
                    continue;
                }
                float h = 0;
                int c = 0;
                if(i > 0 && j > 0) {
                    h += terrain.getHeight(i-1,j-1);
                    c += 1;
                }
                if(i < N-1 && j > 0) {
                    h += terrain.getHeight(i+1,j-1);
                    c += 1;
                }
                if(i > 0 && j < N-1) {
                    h += terrain.getHeight(i-1,j+1);
                    c += 1;
                }
                if(i < N-1 && j < N-1) {
                    h += terrain.getHeight(i+1,j+1);
                    c += 1;
                }
                if(i > 0) {
                    h += terrain.getHeight(i-1,j);
                    c += 1;
                }
                if(j > 0) {
                    h += terrain.getHeight(i,j-1);
                    c += 1;
                }
                if(i < N-1) {
                    h += terrain.getHeight(i+1,j);
                    c += 1;
                }
                if(j < N-1) {
                    h += terrain.getHeight(i,j+1);
                    c += 1;
                }
                s[sidx] = (1-m) * terrain.getHeight(i,j) + m * h / c;
            }
        }
        for(int ia = -radius; ia <= radius; ia++) {
            int i = ic + ia;
            if(i < 0 || i >= N) continue;
            for(int ja = -radius; ja <= radius; ja++) {
                int j = jc + ja;
                if(j < 0 || j >= N) continue;
                int sidx = (ia+radius) + (ja+radius)*w;
                terrain.setHeight(i, j, s[sidx]);
            }
        }
    }

    public static void clampHeights(Terrain terrain) {
        int N = terrain.getN();
        for(int i = 0; i < N; i++) {
            for(int j = 0; j < N; j++) {
                terrain.setHeight(i, j, Math.max(0, Math.min(255, terrain.getHeight(i, j))));
            }
        }
    }

    private static float computeEffect(int i, int j, int ic, int jc, int radius, boolean fallOff, int N) {
        if(i < 0 || j < 0 || i >= N || j >= N) return 0;
        if(!fallOff) return 1;
        int d2 = (ic-i)*(ic-i)+(jc-j)*(jc-j);
        if(d2 > radius*radius) return 0;
        return ((float)radius - (float)Math.sqrt(d2)) / (float)radius;
    }

    public static void addHeight(int i, int j, int radius, float add, Terrain terrain) {
        final int N = terrain.getN();
        for(int ja = -radius; ja <= radius; ja++) {
            int r = j + ja;
            if(r < 0 || r >= N) continue;
            for(int ia = -radius; ia <= radius; ia++) {
                int c = i + ia;
                if(c < 0 || c >= N) continue;
                float v = add * computeEffect(c, r, i, j, radius, true, N);
                float h = terrain.getHeight(c, r) + v;
                h = Math.max(0, Math.min(255, h));
                terrain.setHeight(c, r, h);
            }
        }
    }
}

--[ 2019.10.29.11.34.27.485.0 ]--
:/src/Pathfinder.java
+ 58     C
--[ 2019.10.29.11.34.27.730.0 ]--
r 58     Coor
--[ 2019.10.29.11.34.27.999.0 ]--
r 58     Coord
--[ 2019.10.29.11.34.30.845.0 ]--
r 58     Coord s
--[ 2019.10.29.11.34.30.974.0 ]--
r 58     Coord st
--[ 2019.10.29.11.34.31.237.0 ]--
r 58     Coord sta
--[ 2019.10.29.11.34.32.158.0 ]--
r 58     Coord star
--[ 2019.10.29.11.34.32.207.0 ]--
r 58     Coord start
--[ 2019.10.29.11.34.32.587.0 ]--
r 58     Coord start;
--[ 2019.10.29.11.34.37.206.0 ]--
+ 60         
--[ 2019.10.29.11.34.39.486.0 ]--
r 60         s
--[ 2019.10.29.11.34.39.813.0 ]--
r 60         st
--[ 2019.10.29.11.34.39.870.0 ]--
r 60         sta
--[ 2019.10.29.11.34.40.094.0 ]--
r 60         star
--[ 2019.10.29.11.34.40.212.0 ]--
r 60         start
--[ 2019.10.29.11.34.41.151.0 ]--
r 60         start 
--[ 2019.10.29.11.34.41.237.0 ]--
r 60         start =
--[ 2019.10.29.11.34.41.302.0 ]--
r 60         start = 
--[ 2019.10.29.11.34.41.768.0 ]--
r 60         start = l
--[ 2019.10.29.11.34.42.050.0 ]--
r 60         start = lo
--[ 2019.10.29.11.34.42.091.0 ]--
r 60         start = loc
--[ 2019.10.29.11.34.43.106.0 ]--
r 60         start = loc;
--[ 2019.10.29.11.34.45.841.0 ]--
r 64         return s;
--[ 2019.10.29.11.34.46.135.0 ]--
r 64         return st;
--[ 2019.10.29.11.34.46.273.0 ]--
r 64         return sta;
--[ 2019.10.29.11.34.46.443.0 ]--
r 64         return star;
--[ 2019.10.29.11.34.46.537.0 ]--
r 64         return start;
--[ 2019.10.29.11.34.59.411.0 ]--
+ 67     
--[ 2019.10.29.11.34.59.808.0 ]--
r 67     C
--[ 2019.10.29.11.35.00.228.0 ]--
r 67     Co
--[ 2019.10.29.11.35.00.286.0 ]--
r 67     Coo
--[ 2019.10.29.11.35.00.393.0 ]--
r 67     Coor
--[ 2019.10.29.11.35.00.643.0 ]--
r 67     Coord
--[ 2019.10.29.11.35.01.138.0 ]--
r 67     Coord 
--[ 2019.10.29.11.35.01.410.0 ]--
r 67     Coord e
--[ 2019.10.29.11.35.01.491.0 ]--
r 67     Coord en
--[ 2019.10.29.11.35.01.612.0 ]--
r 67     Coord end
--[ 2019.10.29.11.35.02.439.0 ]--
r 67     Coord end;
--[ 2019.10.29.11.35.06.111.0 ]--
+ 69         
--[ 2019.10.29.11.35.06.508.0 ]--
r 69         e
--[ 2019.10.29.11.35.06.647.0 ]--
r 69         en
--[ 2019.10.29.11.35.06.766.0 ]--
r 69         end
--[ 2019.10.29.11.35.07.559.0 ]--
r 69         end 
--[ 2019.10.29.11.35.07.708.0 ]--
r 69         end =
--[ 2019.10.29.11.35.07.841.0 ]--
r 69         end = 
--[ 2019.10.29.11.35.08.428.0 ]--
r 69         end = l
--[ 2019.10.29.11.35.08.648.0 ]--
r 69         end = lo
--[ 2019.10.29.11.35.08.774.0 ]--
r 69         end = loc
--[ 2019.10.29.11.35.10.108.0 ]--
r 69         end = loc;
--[ 2019.10.29.11.35.13.532.0 ]--
r 73         return e;
--[ 2019.10.29.11.35.13.592.0 ]--
r 73         return en;
--[ 2019.10.29.11.35.13.674.0 ]--
r 73         return end;
--[ 2019.10.29.11.35.34.924.0 ]--
r 67 
--[ 2019.10.29.11.35.36.671.0 ]--
- 66
r 66     
--[ 2019.10.29.11.35.40.487.0 ]--
+ 10     
--[ 2019.10.29.11.35.40.930.0 ]--
r 10         Coord end;
--[ 2019.10.29.11.35.40.963.0 ]--
r 10     Coord end;
--[ 2019.10.29.11.35.47.839.0 ]--
r 10     privateCoord end;
--[ 2019.10.29.11.35.47.870.0 ]--
r 10     private Coord end;
--[ 2019.10.29.11.35.54.324.0 ]--
r 59 
--[ 2019.10.29.11.35.55.225.0 ]--
- 58
r 58     
--[ 2019.10.29.11.35.58.533.0 ]--
+ 11     
--[ 2019.10.29.11.35.58.804.0 ]--
r 11         Coord start;
--[ 2019.10.29.11.35.58.855.0 ]--
r 11     Coord start;
--[ 2019.10.29.11.36.01.640.0 ]--
r 11     privateCoord start;
--[ 2019.10.29.11.36.01.664.0 ]--
r 11     private Coord start;
--[ 2019.10.29.11.39.51.520.0 ]--
+ 87         
--[ 2019.10.29.11.39.51.910.0 ]--
r 87         /
--[ 2019.10.29.11.39.52.022.0 ]--
r 87         //
--[ 2019.10.29.11.39.52.760.0 ]--
r 87         //s
--[ 2019.10.29.11.39.53.087.0 ]--
r 87         //st
--[ 2019.10.29.11.39.53.211.0 ]--
r 87         //sta
--[ 2019.10.29.11.39.53.351.0 ]--
r 87         //star
--[ 2019.10.29.11.39.53.545.0 ]--
r 87         //start
--[ 2019.10.29.11.39.53.649.0 ]--
r 87         //start 
--[ 2019.10.29.11.39.54.104.0 ]--
r 87         //start d
--[ 2019.10.29.11.39.54.401.0 ]--
r 87         //start do
--[ 2019.10.29.11.39.54.610.0 ]--
r 87         //start doi
--[ 2019.10.29.11.39.54.877.0 ]--
r 87         //start doin
--[ 2019.10.29.11.39.55.433.0 ]--
r 87         //start doing
--[ 2019.10.29.11.39.55.550.0 ]--
r 87         //start doing 
--[ 2019.10.29.11.39.55.649.0 ]--
r 87         //start doing a
--[ 2019.10.29.11.39.55.754.0 ]--
r 87         //start doing al
--[ 2019.10.29.11.39.55.876.0 ]--
r 87         //start doing all
--[ 2019.10.29.11.39.55.975.0 ]--
r 87         //start doing all 
--[ 2019.10.29.11.39.56.124.0 ]--
r 87         //start doing all t
--[ 2019.10.29.11.39.56.206.0 ]--
r 87         //start doing all th
--[ 2019.10.29.11.39.56.340.0 ]--
r 87         //start doing all the
--[ 2019.10.29.11.39.56.427.0 ]--
r 87         //start doing all the 
--[ 2019.10.29.11.39.56.934.0 ]--
r 87         //start doing all the w
--[ 2019.10.29.11.39.57.019.0 ]--
r 87         //start doing all the wo
--[ 2019.10.29.11.39.57.136.0 ]--
r 87         //start doing all the wor
--[ 2019.10.29.11.39.57.267.0 ]--
r 87         //start doing all the work
--[ 2019.10.29.11.39.57.418.0 ]--
r 87         //start doing all the work 
--[ 2019.10.29.11.39.57.608.0 ]--
r 87         //start doing all the work o
--[ 2019.10.29.11.39.57.712.0 ]--
r 87         //start doing all the work of
--[ 2019.10.29.11.39.57.806.0 ]--
r 87         //start doing all the work of 
--[ 2019.10.29.11.39.58.092.0 ]--
r 87         //start doing all the work of f
--[ 2019.10.29.11.39.58.209.0 ]--
r 87         //start doing all the work of fi
--[ 2019.10.29.11.39.58.363.0 ]--
r 87         //start doing all the work of fin
--[ 2019.10.29.11.39.58.568.0 ]--
r 87         //start doing all the work of find
--[ 2019.10.29.11.39.58.611.0 ]--
r 87         //start doing all the work of findi
--[ 2019.10.29.11.39.58.667.0 ]--
r 87         //start doing all the work of findin
--[ 2019.10.29.11.39.58.812.0 ]--
r 87         //start doing all the work of finding
--[ 2019.10.29.11.39.58.908.0 ]--
r 87         //start doing all the work of finding 
--[ 2019.10.29.11.39.59.067.0 ]--
r 87         //start doing all the work of finding t
--[ 2019.10.29.11.39.59.133.0 ]--
r 87         //start doing all the work of finding th
--[ 2019.10.29.11.39.59.240.0 ]--
r 87         //start doing all the work of finding the
--[ 2019.10.29.11.39.59.286.0 ]--
r 87         //start doing all the work of finding the 
--[ 2019.10.29.11.39.59.801.0 ]--
r 87         //start doing all the work of finding the s
--[ 2019.10.29.11.40.00.417.0 ]--
r 87         //start doing all the work of finding the sh
--[ 2019.10.29.11.40.00.512.0 ]--
r 87         //start doing all the work of finding the sho
--[ 2019.10.29.11.40.00.607.0 ]--
r 87         //start doing all the work of finding the shor
--[ 2019.10.29.11.40.00.789.0 ]--
r 87         //start doing all the work of finding the short
--[ 2019.10.29.11.40.00.960.0 ]--
r 87         //start doing all the work of finding the shorte
--[ 2019.10.29.11.40.01.261.0 ]--
r 87         //start doing all the work of finding the shortes
--[ 2019.10.29.11.40.01.486.0 ]--
r 87         //start doing all the work of finding the shortest
--[ 2019.10.29.11.40.01.617.0 ]--
r 87         //start doing all the work of finding the shortest 
--[ 2019.10.29.11.40.02.050.0 ]--
r 87         //start doing all the work of finding the shortest p
--[ 2019.10.29.11.40.02.125.0 ]--
r 87         //start doing all the work of finding the shortest pa
--[ 2019.10.29.11.40.02.347.0 ]--
r 87         //start doing all the work of finding the shortest pat
--[ 2019.10.29.11.40.02.439.0 ]--
r 87         //start doing all the work of finding the shortest path
--[ 2019.10.29.11.41.18.564.0 ]--
+ 12     
--[ 2019.10.29.11.41.19.320.0 ]--
r 12     R
--[ 2019.10.29.11.41.19.924.0 ]--
r 12     
--[ 2019.10.29.11.41.20.369.0 ]--
r 12     T
--[ 2019.10.29.11.41.20.680.0 ]--
r 12     Te
--[ 2019.10.29.11.41.20.777.0 ]--
r 12     Ter
--[ 2019.10.29.11.41.20.995.0 ]--
r 12     Terr
--[ 2019.10.29.11.41.21.794.0 ]--
r 12     Terrain
--[ 2019.10.29.11.41.22.310.0 ]--
r 12     Terrain 
--[ 2019.10.29.11.41.22.745.0 ]--
r 12     Terrain t
--[ 2019.10.29.11.41.22.917.0 ]--
r 12     Terrain te
--[ 2019.10.29.11.41.23.107.0 ]--
r 12     Terrain ter
--[ 2019.10.29.11.41.23.283.0 ]--
r 12     Terrain terr
--[ 2019.10.29.11.41.24.101.0 ]--
r 12     Terrain terrain
--[ 2019.10.29.11.41.25.361.0 ]--
r 12     Terrain terrain;
--[ 2019.10.29.11.41.29.993.0 ]--
+ 59         
--[ 2019.10.29.11.41.30.441.0 ]--
r 59         t
--[ 2019.10.29.11.41.30.598.0 ]--
r 59         th
--[ 2019.10.29.11.41.30.667.0 ]--
r 59         thi
--[ 2019.10.29.11.41.30.732.0 ]--
r 59         this
--[ 2019.10.29.11.41.31.000.0 ]--
r 59         this.
--[ 2019.10.29.11.41.31.896.0 ]--
r 59         this.t
--[ 2019.10.29.11.41.32.125.0 ]--
r 59         this.te
--[ 2019.10.29.11.41.32.270.0 ]--
r 59         this.ter
--[ 2019.10.29.11.41.32.490.0 ]--
r 59         this.terr
--[ 2019.10.29.11.41.33.048.0 ]--
r 59         this.terrain
--[ 2019.10.29.11.41.34.194.0 ]--
r 59         this.terrain 
--[ 2019.10.29.11.41.34.309.0 ]--
r 59         this.terrain =
--[ 2019.10.29.11.41.34.459.0 ]--
r 59         this.terrain = 
--[ 2019.10.29.11.41.35.326.0 ]--
r 59         this.terrain = t
--[ 2019.10.29.11.41.35.467.0 ]--
r 59         this.terrain = te
--[ 2019.10.29.11.41.35.678.0 ]--
r 59         this.terrain = ter
--[ 2019.10.29.11.41.35.874.0 ]--
r 59         this.terrain = terr
--[ 2019.10.29.11.41.36.484.0 ]--
r 59         this.terrain = terrain
--[ 2019.10.29.11.41.37.596.0 ]--
r 59         this.terrain = terrain;
--[ 2019.10.29.11.42.05.312.0 ]--
r 12     privateTerrain terrain;
--[ 2019.10.29.11.42.05.322.0 ]--
r 12     private Terrain terrain;
--[ 2019.10.29.11.43.02.558.0 ]--
+ 90         
--[ 2019.10.29.11.43.02.926.0 ]--
r 90         /
--[ 2019.10.29.11.43.03.022.0 ]--
r 90         //
--[ 2019.10.29.11.43.03.639.0 ]--
r 90         // 
--[ 2019.10.29.11.43.03.923.0 ]--
r 90         // l
--[ 2019.10.29.11.43.04.583.0 ]--
r 90         // 
--[ 2019.10.29.11.43.05.003.0 ]--
r 90         //
--[ 2019.10.29.11.43.05.646.0 ]--
r 90         //l
--[ 2019.10.29.11.43.05.902.0 ]--
r 90         //lo
--[ 2019.10.29.11.43.06.019.0 ]--
r 90         //loo
--[ 2019.10.29.11.43.06.124.0 ]--
r 90         //look
--[ 2019.10.29.11.43.06.356.0 ]--
r 90         //looki
--[ 2019.10.29.11.43.06.492.0 ]--
r 90         //lookin
--[ 2019.10.29.11.43.07.141.0 ]--
r 90         //looking
--[ 2019.10.29.11.43.07.374.0 ]--
r 90         //looking 
--[ 2019.10.29.11.43.07.455.0 ]--
r 90         //looking a
--[ 2019.10.29.11.43.07.611.0 ]--
r 90         //looking at
--[ 2019.10.29.11.43.07.841.0 ]--
r 90         //looking at 
--[ 2019.10.29.11.43.08.657.0 ]--
r 90         //looking at t
--[ 2019.10.29.11.43.08.735.0 ]--
r 90         //looking at th
--[ 2019.10.29.11.43.08.884.0 ]--
r 90         //looking at the
--[ 2019.10.29.11.43.08.985.0 ]--
r 90         //looking at thei
--[ 2019.10.29.11.43.09.473.0 ]--
r 90         //looking at the
--[ 2019.10.29.11.43.09.773.0 ]--
r 90         //looking at the 
--[ 2019.10.29.11.43.10.364.0 ]--
r 90         //looking at the r
--[ 2019.10.29.11.43.10.689.0 ]--
r 90         //looking at the re
--[ 2019.10.29.11.43.11.164.0 ]--
r 90         //looking at the r
--[ 2019.10.29.11.43.11.293.0 ]--
r 90         //looking at the 
--[ 2019.10.29.11.43.11.416.0 ]--
r 90         //looking at the t
--[ 2019.10.29.11.43.11.547.0 ]--
r 90         //looking at the te
--[ 2019.10.29.11.43.11.740.0 ]--
r 90         //looking at the ter
--[ 2019.10.29.11.43.12.126.0 ]--
r 90         //looking at the terr
--[ 2019.10.29.11.43.12.392.0 ]--
r 90         //looking at the terra
--[ 2019.10.29.11.43.12.493.0 ]--
r 90         //looking at the terrai
--[ 2019.10.29.11.43.12.622.0 ]--
r 90         //looking at the terrain
--[ 2019.10.29.11.43.19.273.0 ]--
r 90         //looking at the terrain 
--[ 2019.10.29.11.43.19.523.0 ]--
r 90         //looking at the terrain t
--[ 2019.10.29.11.43.19.788.0 ]--
r 90         //looking at the terrain to
--[ 2019.10.29.11.43.20.063.0 ]--
r 90         //looking at the terrain to 
--[ 2019.10.29.11.43.20.297.0 ]--
r 90         //looking at the terrain to s
--[ 2019.10.29.11.43.20.405.0 ]--
r 90         //looking at the terrain to se
--[ 2019.10.29.11.43.20.666.0 ]--
r 90         //looking at the terrain to see
--[ 2019.10.29.11.43.21.296.0 ]--
r 90         //looking at the terrain to see 
--[ 2019.10.29.11.43.21.895.0 ]--
r 90         //looking at the terrain to see i
--[ 2019.10.29.11.43.22.074.0 ]--
r 90         //looking at the terrain to see it
--[ 2019.10.29.11.43.23.045.0 ]--
r 90         //looking at the terrain to see its
--[ 2019.10.29.11.43.23.223.0 ]--
r 90         //looking at the terrain to see its 
--[ 2019.10.29.11.43.23.510.0 ]--
r 90         //looking at the terrain to see its s
--[ 2019.10.29.11.43.23.653.0 ]--
r 90         //looking at the terrain to see its si
--[ 2019.10.29.11.43.24.262.0 ]--
r 90         //looking at the terrain to see its siz
--[ 2019.10.29.11.43.24.617.0 ]--
r 90         //looking at the terrain to see its size
--[ 2019.10.29.11.43.25.677.0 ]--
r 90         //looking at the terrain to see its size,
--[ 2019.10.29.11.43.25.837.0 ]--
r 90         //looking at the terrain to see its size, 
--[ 2019.10.29.11.43.26.122.0 ]--
r 90         //looking at the terrain to see its size, c
--[ 2019.10.29.11.43.26.161.0 ]--
r 90         //looking at the terrain to see its size, co
--[ 2019.10.29.11.43.26.258.0 ]--
r 90         //looking at the terrain to see its size, cos
--[ 2019.10.29.11.43.26.576.0 ]--
r 90         //looking at the terrain to see its size, cost
--[ 2019.10.29.11.43.26.717.0 ]--
r 90         //looking at the terrain to see its size, cost,
--[ 2019.10.29.11.43.26.793.0 ]--
r 90         //looking at the terrain to see its size, cost, 
--[ 2019.10.29.11.43.26.906.0 ]--
r 90         //looking at the terrain to see its size, cost, e
--[ 2019.10.29.11.43.27.221.0 ]--
r 90         //looking at the terrain to see its size, cost, et
--[ 2019.10.29.11.43.27.523.0 ]--
r 90         //looking at the terrain to see its size, cost, etc
--[ 2019.10.29.11.43.27.874.0 ]--
r 90         //looking at the terrain to see its size, cost, etc,
--[ 2019.10.29.11.43.28.710.0 ]--
r 90         //looking at the terrain to see its size, cost, etc
--[ 2019.10.29.11.43.29.335.0 ]--
r 90         //looking at the terrain to see its size, cost, etc.
--[ 2019.10.29.11.46.30.096.0 ]--
+ 13     
--[ 2019.10.29.11.46.31.104.0 ]--
r 13     p
--[ 2019.10.29.11.46.31.267.0 ]--
r 13     pr
--[ 2019.10.29.11.46.31.649.0 ]--
r 13     pri
--[ 2019.10.29.11.46.31.788.0 ]--
r 13     priv
--[ 2019.10.29.11.46.31.919.0 ]--
r 13     priva
--[ 2019.10.29.11.46.32.414.0 ]--
r 13     privat
--[ 2019.10.29.11.46.32.595.0 ]--
r 13     private
--[ 2019.10.29.11.46.32.888.0 ]--
r 13     private 
--[ 2019.10.29.11.46.33.551.0 ]--
r 13     private b
--[ 2019.10.29.11.46.33.678.0 ]--
r 13     private bo
--[ 2019.10.29.11.46.33.846.0 ]--
r 13     private boo
--[ 2019.10.29.11.46.34.029.0 ]--
r 13     private bool
--[ 2019.10.29.11.46.34.198.0 ]--
r 13     private boole
--[ 2019.10.29.11.46.34.680.0 ]--
r 13     private boolea
--[ 2019.10.29.11.46.34.763.0 ]--
r 13     private boolean
--[ 2019.10.29.11.46.35.047.0 ]--
r 13     private boolean 
--[ 2019.10.29.11.46.35.903.0 ]--
r 13     private boolean u
--[ 2019.10.29.11.46.35.995.0 ]--
r 13     private boolean us
--[ 2019.10.29.11.46.36.155.0 ]--
r 13     private boolean use
--[ 2019.10.29.11.46.38.058.0 ]--
r 13     private boolean us
--[ 2019.10.29.11.46.38.206.0 ]--
r 13     private boolean u
--[ 2019.10.29.11.46.38.442.0 ]--
r 13     private boolean 
--[ 2019.10.29.11.46.39.170.0 ]--
r 13     private boolean i
--[ 2019.10.29.11.46.39.308.0 ]--
r 13     private boolean is
--[ 2019.10.29.11.46.40.005.0 ]--
r 13     private boolean isU
--[ 2019.10.29.11.46.40.220.0 ]--
r 13     private boolean isUs
--[ 2019.10.29.11.46.40.398.0 ]--
r 13     private boolean isUse
--[ 2019.10.29.11.46.40.580.0 ]--
r 13     private boolean isUsed
--[ 2019.10.29.11.46.41.544.0 ]--
r 13     private boolean isUsed 
--[ 2019.10.29.11.46.41.672.0 ]--
r 13     private boolean isUsed =
--[ 2019.10.29.11.46.41.755.0 ]--
r 13     private boolean isUsed = 
--[ 2019.10.29.11.46.42.132.0 ]--
r 13     private boolean isUsed = t
--[ 2019.10.29.11.46.42.437.0 ]--
r 13     private boolean isUsed = tr
--[ 2019.10.29.11.46.42.557.0 ]--
r 13     private boolean isUsed = tru
--[ 2019.10.29.11.46.42.764.0 ]--
r 13     private boolean isUsed = true
--[ 2019.10.29.11.46.42.887.0 ]--
r 13     private boolean isUsed = true.
--[ 2019.10.29.11.46.43.659.0 ]--
r 13     private boolean isUsed = true
--[ 2019.10.29.11.46.44.642.0 ]--
r 13     private boolean isUsed = true;
--[ 2019.10.29.11.46.50.604.0 ]--
r 13     private boolean isUsed = rue;
--[ 2019.10.29.11.46.51.002.0 ]--
r 13     private boolean isUsed = True;
--[ 2019.10.29.11.46.54.076.0 ]--
r 13     private boolean isUsed = rue;
--[ 2019.10.29.11.46.54.347.0 ]--
r 13     private boolean isUsed = true;
--[ 2019.10.29.11.47.03.556.0 ]--
r 13     private boolean isUsed;
--[ 2019.10.29.11.47.09.881.0 ]--
+ 49         public void use() { 
r 50         }
--[ 2019.10.29.11.47.09.899.0 ]--
+ 50             
--[ 2019.10.29.11.47.11.217.0 ]--
r 50             i
--[ 2019.10.29.11.47.11.496.0 ]--
r 50             is
--[ 2019.10.29.11.47.11.922.0 ]--
r 50             isU
--[ 2019.10.29.11.47.12.138.0 ]--
r 50             isUs
--[ 2019.10.29.11.47.12.289.0 ]--
r 50             isUse
--[ 2019.10.29.11.47.12.508.0 ]--
r 50             isUsed
--[ 2019.10.29.11.47.13.616.0 ]--
r 50             isUsed 
--[ 2019.10.29.11.47.13.715.0 ]--
r 50             isUsed =
--[ 2019.10.29.11.47.13.768.0 ]--
r 50             isUsed = 
--[ 2019.10.29.11.47.14.136.0 ]--
r 50             isUsed = t
--[ 2019.10.29.11.47.14.532.0 ]--
r 50             isUsed = tr
--[ 2019.10.29.11.47.14.652.0 ]--
r 50             isUsed = tru
--[ 2019.10.29.11.47.14.747.0 ]--
r 50             isUsed = true
--[ 2019.10.29.11.47.16.012.0 ]--
r 50             isUsed = true;
--[ 2019.10.29.11.47.31.504.0 ]--
r 45             ireturn true;
--[ 2019.10.29.11.47.31.662.0 ]--
r 45             ifreturn true;
--[ 2019.10.29.11.47.32.195.0 ]--
r 45             if(return true;
--[ 2019.10.29.11.47.34.446.0 ]--
r 45             if(ureturn true;
--[ 2019.10.29.11.47.34.646.0 ]--
r 45             if(usreturn true;
--[ 2019.10.29.11.47.35.110.0 ]--
r 45             if(usereturn true;
--[ 2019.10.29.11.47.35.853.0 ]--
r 45             if(use(return true;
--[ 2019.10.29.11.47.36.018.0 ]--
r 45             if(use()return true;
--[ 2019.10.29.11.47.38.114.0 ]--
r 45             if(use())return true;
--[ 2019.10.29.11.47.38.850.0 ]--
r 45             if(use()) return true;
--[ 2019.10.29.11.49.18.616.0 ]--
r 13     
--[ 2019.10.29.11.49.19.575.0 ]--
- 13
--[ 2019.10.29.11.49.22.159.0 ]--
+ 18         
--[ 2019.10.29.11.49.22.450.0 ]--
r 18         private boolean isUsed;
--[ 2019.10.29.11.49.39.810.0 ]--
r 45             return true;
--[ 2019.10.29.11.49.42.922.0 ]--
r 45             return i;
--[ 2019.10.29.11.49.43.051.0 ]--
r 45             return is;
--[ 2019.10.29.11.49.43.710.0 ]--
r 45             return isU;
--[ 2019.10.29.11.49.44.027.0 ]--
r 45             return isUs;
--[ 2019.10.29.11.49.44.124.0 ]--
r 45             return isUse;
--[ 2019.10.29.11.49.44.329.0 ]--
r 45             return isUsed;
--[ 2019.10.29.11.49.45.388.0 ]--
r 45             return isUsed();
--[ 2019.10.29.11.49.49.196.0 ]--
r 45             return isUsed(;
--[ 2019.10.29.11.49.49.271.0 ]--
r 45             return isUsed;
--[ 2019.10.29.11.51.02.821.0 ]--
r 36             return i;
--[ 2019.10.29.11.51.02.985.0 ]--
r 36             return in;
--[ 2019.10.29.11.51.03.309.0 ]--
r 36             return inv;
--[ 2019.10.29.11.51.03.421.0 ]--
r 36             return inva;
--[ 2019.10.29.11.51.03.516.0 ]--
r 36             return inval;
--[ 2019.10.29.11.51.03.679.0 ]--
r 36             return invali;
--[ 2019.10.29.11.51.03.873.0 ]--
r 36             return invalid;
--[ 2019.10.29.11.51.03.980.0 ]--
r 36             return invalida;
--[ 2019.10.29.11.51.04.137.0 ]--
r 36             return invalidat;
--[ 2019.10.29.11.51.04.271.0 ]--
r 36             return invalidate;
--[ 2019.10.29.11.51.19.623.0 ]--
r 36             return false;
--[ 2019.10.29.11.51.39.052.0 ]--
+ 19         
--[ 2019.10.29.11.51.39.207.0 ]--
r 19         private boolean isUsed;
--[ 2019.10.29.11.52.40.454.0 ]--
r 19         private boolean i;
--[ 2019.10.29.11.52.40.562.0 ]--
r 19         private boolean in;
--[ 2019.10.29.11.52.40.832.0 ]--
r 19         private boolean inv;
--[ 2019.10.29.11.52.40.928.0 ]--
r 19         private boolean inva;
--[ 2019.10.29.11.52.41.069.0 ]--
r 19         private boolean inval;
--[ 2019.10.29.11.52.41.202.0 ]--
r 19         private boolean invali;
--[ 2019.10.29.11.52.41.342.0 ]--
r 19         private boolean invalid;
--[ 2019.10.29.11.52.51.210.0 ]--
+ 41         public void invalidate() 
r 42         {
--[ 2019.10.29.11.52.52.789.0 ]--
- 41
r 41         public void invalidate() {
--[ 2019.10.29.11.52.54.589.0 ]--
+ 42             
--[ 2019.10.29.11.52.55.469.0 ]--
r 42             i
--[ 2019.10.29.11.52.55.586.0 ]--
r 42             in
--[ 2019.10.29.11.52.55.957.0 ]--
r 42             inv
--[ 2019.10.29.11.52.56.069.0 ]--
r 42             inva
--[ 2019.10.29.11.52.56.179.0 ]--
r 42             inval
--[ 2019.10.29.11.52.56.352.0 ]--
r 42             invali
--[ 2019.10.29.11.52.56.574.0 ]--
r 42             invalid
--[ 2019.10.29.11.53.27.487.0 ]--
r 42             invalid 
--[ 2019.10.29.11.53.28.134.0 ]--
r 42             invalid =
--[ 2019.10.29.11.53.28.376.0 ]--
r 42             invalid = 
--[ 2019.10.29.11.53.28.616.0 ]--
r 42             invalid = t
--[ 2019.10.29.11.53.29.228.0 ]--
r 42             invalid = tr
--[ 2019.10.29.11.53.29.310.0 ]--
r 42             invalid = tru
--[ 2019.10.29.11.53.29.394.0 ]--
r 42             invalid = true
--[ 2019.10.29.11.53.29.629.0 ]--
r 42             invalid = truel
--[ 2019.10.29.11.53.30.802.0 ]--
r 42             invalid = true
--[ 2019.10.29.11.53.31.109.0 ]--
r 42             invalid = true;
--[ 2019.10.29.11.55.08.936.0 ]--
r 37             return i;
--[ 2019.10.29.11.55.09.022.0 ]--
r 37             return in;
--[ 2019.10.29.11.55.09.441.0 ]--
r 37             return inv;
--[ 2019.10.29.11.55.09.579.0 ]--
r 37             return inva;
--[ 2019.10.29.11.55.12.380.0 ]--
r 37             return inval;
--[ 2019.10.29.11.55.12.847.0 ]--
r 37             return invali;
--[ 2019.10.29.11.55.13.085.0 ]--
r 37             return invalid;
--[ 2019.10.29.11.55.13.183.0 ]--
r 37             return invalida;
--[ 2019.10.29.11.55.13.335.0 ]--
r 37             return invalidat;
--[ 2019.10.29.11.55.13.467.0 ]--
r 37             return invalidate;
--[ 2019.10.29.11.55.21.803.0 ]--
r 37             return invalidate9;
--[ 2019.10.29.11.55.21.852.0 ]--
r 37             return invalidate90;
--[ 2019.10.29.11.55.22.897.0 ]--
r 37             return invalidate9;
--[ 2019.10.29.11.55.22.996.0 ]--
r 37             return invalidate;
--[ 2019.10.29.11.55.23.604.0 ]--
r 37             return invalidate();
--[ 2019.10.29.11.55.29.499.0 ]--
r 37             return invalidate(;
--[ 2019.10.29.11.55.29.557.0 ]--
r 37             return invalidate;
--[ 2019.10.29.11.55.37.847.0 ]--
r 37             return i;
--[ 2019.10.29.11.55.38.155.0 ]--
r 37             return in;
--[ 2019.10.29.11.55.38.508.0 ]--
r 37             return inv;
--[ 2019.10.29.11.55.38.842.0 ]--
r 37             return inva;
--[ 2019.10.29.11.55.39.298.0 ]--
r 37             return inval;
--[ 2019.10.29.11.55.39.497.0 ]--
r 37             return invali;
--[ 2019.10.29.11.55.39.820.0 ]--
r 37             return invalid;
--[ 2019.10.29.11.57.22.458.0 ]--
r 51         public void use() {
r 66 
r 74 
--[ 2019.10.29.21.44.37.397.0 ]--
+ 83     public void setHeuristic(float v) 
r 84     {
--[ 2019.10.29.21.44.42.423.0 ]--
- 83
r 83     public void setHeuristic(float v) {
--[ 2019.10.29.21.44.43.588.0 ]--
+ 84         
--[ 2019.10.29.21.44.46.016.0 ]--
r 84         h
--[ 2019.10.29.21.44.46.186.0 ]--
r 84         he
--[ 2019.10.29.21.44.46.244.0 ]--
r 84         heu
--[ 2019.10.29.21.44.46.587.0 ]--
r 84         heur
--[ 2019.10.29.21.44.47.404.0 ]--
r 84         heuri
--[ 2019.10.29.21.44.47.535.0 ]--
r 84         heuris
--[ 2019.10.29.21.44.47.960.0 ]--
r 84         heurisr
--[ 2019.10.29.21.44.48.888.0 ]--
r 84         heuris
--[ 2019.10.29.21.44.50.153.0 ]--
r 84         heurist
--[ 2019.10.29.21.44.51.653.0 ]--
r 84         heurist 
--[ 2019.10.29.21.44.51.772.0 ]--
r 84         heurist =
--[ 2019.10.29.21.44.51.925.0 ]--
r 84         heurist = 
--[ 2019.10.29.21.44.56.455.0 ]--
r 84         heurist = v
--[ 2019.10.29.21.44.56.581.0 ]--
r 84         heurist = v;
--[ 2019.10.29.21.45.06.820.0 ]--
r 84         heuris = v;
--[ 2019.10.29.21.45.07.123.0 ]--
r 84         heuri = v;
--[ 2019.10.29.21.45.07.408.0 ]--
r 84         heur = v;
--[ 2019.10.29.21.45.12.582.0 ]--
+ 13     
--[ 2019.10.29.21.45.13.714.0 ]--
r 13     p
--[ 2019.10.29.21.45.13.904.0 ]--
r 13     pr
--[ 2019.10.29.21.45.14.100.0 ]--
r 13     pri
--[ 2019.10.29.21.45.14.374.0 ]--
r 13     priv
--[ 2019.10.29.21.45.14.508.0 ]--
r 13     priva
--[ 2019.10.29.21.45.14.698.0 ]--
r 13     privat
--[ 2019.10.29.21.45.14.797.0 ]--
r 13     private
--[ 2019.10.29.21.45.14.911.0 ]--
r 13     private 
--[ 2019.10.29.21.45.16.720.0 ]--
r 13     private f
--[ 2019.10.29.21.45.16.815.0 ]--
r 13     private fl
--[ 2019.10.29.21.45.16.923.0 ]--
r 13     private fla
--[ 2019.10.29.21.45.17.571.0 ]--
r 13     private fl
--[ 2019.10.29.21.45.17.870.0 ]--
r 13     private flo
--[ 2019.10.29.21.45.18.072.0 ]--
r 13     private floa
--[ 2019.10.29.21.45.18.187.0 ]--
r 13     private float
--[ 2019.10.29.21.45.18.371.0 ]--
r 13     private float 
--[ 2019.10.29.21.45.19.003.0 ]--
r 13     private float h
--[ 2019.10.29.21.45.19.127.0 ]--
r 13     private float he
--[ 2019.10.29.21.45.19.618.0 ]--
r 13     private float heu
--[ 2019.10.29.21.45.19.720.0 ]--
r 13     private float heur
--[ 2019.10.29.21.45.21.002.0 ]--
r 13     private float heur;
--[ 2019.10.29.21.45.32.087.0 ]--
r 89         return h;
--[ 2019.10.29.21.45.32.693.0 ]--
r 89         return he;
--[ 2019.10.29.21.45.32.801.0 ]--
r 89         return heu;
--[ 2019.10.29.21.45.32.862.0 ]--
r 89         return heur;
--[ 2019.10.29.21.45.41.137.0 ]--
r 84     public void setHeuristic(float v) { 
--[ 2019.10.29.21.45.41.457.0 ]--
r 84     public void setHeuristic(float v) { /
--[ 2019.10.29.21.45.41.593.0 ]--
r 84     public void setHeuristic(float v) { //
--[ 2019.10.29.21.45.41.873.0 ]--
r 84     public void setHeuristic(float v) { // 
--[ 2019.10.29.21.45.42.339.0 ]--
r 84     public void setHeuristic(float v) { // i
--[ 2019.10.29.21.45.42.430.0 ]--
r 84     public void setHeuristic(float v) { // is
--[ 2019.10.29.21.45.42.585.0 ]--
r 84     public void setHeuristic(float v) { // is 
--[ 2019.10.29.21.45.42.703.0 ]--
r 84     public void setHeuristic(float v) { // is t
--[ 2019.10.29.21.45.42.788.0 ]--
r 84     public void setHeuristic(float v) { // is th
--[ 2019.10.29.21.45.42.883.0 ]--
r 84     public void setHeuristic(float v) { // is thi
--[ 2019.10.29.21.45.42.970.0 ]--
r 84     public void setHeuristic(float v) { // is this
--[ 2019.10.29.21.45.43.090.0 ]--
r 84     public void setHeuristic(float v) { // is this 
--[ 2019.10.29.21.45.43.341.0 ]--
r 84     public void setHeuristic(float v) { // is this c
--[ 2019.10.29.21.45.43.442.0 ]--
r 84     public void setHeuristic(float v) { // is this co
--[ 2019.10.29.21.45.43.624.0 ]--
r 84     public void setHeuristic(float v) { // is this cor
--[ 2019.10.29.21.45.43.789.0 ]--
r 84     public void setHeuristic(float v) { // is this corr
--[ 2019.10.29.21.45.43.828.0 ]--
r 84     public void setHeuristic(float v) { // is this corre
--[ 2019.10.29.21.45.44.087.0 ]--
r 84     public void setHeuristic(float v) { // is this correc
--[ 2019.10.29.21.45.44.320.0 ]--
r 84     public void setHeuristic(float v) { // is this correct
--[ 2019.10.29.21.45.44.631.0 ]--
r 84     public void setHeuristic(float v) { // is this correct?
--[ 2019.10.29.21.47.03.482.0 ]--
UpdateTree (AD): 24 0
+ /out/production/P04_Pathfinding/.donotlog
+ /out/production/P04_Pathfinding/algs4.jar
+ /out/production/P04_Pathfinding/stdlib.jar
+ /out/production/P04_Pathfinding/Coord.class
+ /out/production/P04_Pathfinding/png2emap.py
+ /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/ramp.png.emap
+ /out/production/P04_Pathfinding/Terrain.class
+ /out/production/P04_Pathfinding/ramp2.png.emap
+ /out/production/P04_Pathfinding/ramp3.png.emap
+ /out/production/P04_Pathfinding/mazeAB.png.emap
+ /out/production/P04_Pathfinding/usa128.png.emap
+ /out/production/P04_Pathfinding/usa256.png.emap
+ /out/production/P04_Pathfinding/Pathfinder.class
+ /out/production/P04_Pathfinding/usa1024.png.emap
+ /out/production/P04_Pathfinding/maze32_0.png.emap
+ /out/production/P04_Pathfinding/maze32_1.png.emap
+ /out/production/P04_Pathfinding/maze232_0.png.emap
+ /out/production/P04_Pathfinding/maze320_0.png.emap
+ /out/production/P04_Pathfinding/mazeBrain.png.emap
+ /out/production/P04_Pathfinding/TerrainEditor.class
+ /out/production/P04_Pathfinding/Pathfinder$PFNode.class
+ /out/production/P04_Pathfinding/PathfinderVisualizer.class
+ /out/production/P04_Pathfinding/InteractivePathfinderVisualizer.class

--[ 2019.10.29.21.47.03.697.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.10.29.21.48.59.743.0 ]--
+ 14     
--[ 2019.10.29.21.49.00.684.0 ]--
r 14     p
--[ 2019.10.29.21.49.00.926.0 ]--
r 14     pr
--[ 2019.10.29.21.49.01.085.0 ]--
r 14     pri
--[ 2019.10.29.21.49.01.375.0 ]--
r 14     priv
--[ 2019.10.29.21.49.01.541.0 ]--
r 14     priva
--[ 2019.10.29.21.49.01.689.0 ]--
r 14     privat
--[ 2019.10.29.21.49.01.844.0 ]--
r 14     private
--[ 2019.10.29.21.49.01.942.0 ]--
r 14     private 
--[ 2019.10.29.21.49.02.931.0 ]--
r 14     private b
--[ 2019.10.29.21.49.03.059.0 ]--
r 14     private bo
--[ 2019.10.29.21.49.03.188.0 ]--
r 14     private boo
--[ 2019.10.29.21.49.03.389.0 ]--
r 14     private bool
--[ 2019.10.29.21.49.03.456.0 ]--
r 14     private boole
--[ 2019.10.29.21.49.03.891.0 ]--
r 14     private boolea
--[ 2019.10.29.21.49.04.010.0 ]--
r 14     private boolean
--[ 2019.10.29.21.49.05.345.0 ]--
r 14     private boolean 
--[ 2019.10.29.21.49.05.766.0 ]--
r 14     private boolean p
--[ 2019.10.29.21.49.05.900.0 ]--
r 14     private boolean pa
--[ 2019.10.29.21.49.06.115.0 ]--
r 14     private boolean pat
--[ 2019.10.29.21.49.06.232.0 ]--
r 14     private boolean path
--[ 2019.10.29.21.49.06.856.0 ]--
r 14     private boolean pathF
--[ 2019.10.29.21.49.07.085.0 ]--
r 14     private boolean pathFo
--[ 2019.10.29.21.49.07.332.0 ]--
r 14     private boolean pathFou
--[ 2019.10.29.21.49.07.459.0 ]--
r 14     private boolean pathFoun
--[ 2019.10.29.21.49.07.581.0 ]--
r 14     private boolean pathFound
--[ 2019.10.29.21.49.09.316.0 ]--
r 14     private boolean pathFound;
--[ 2019.10.29.21.49.09.441.0 ]--
r 14     private boolean pathFound; 
--[ 2019.10.29.21.49.09.640.0 ]--
r 14     private boolean pathFound;  
--[ 2019.10.29.21.49.09.771.0 ]--
r 14     private boolean pathFound;  /
--[ 2019.10.29.21.49.09.942.0 ]--
r 14     private boolean pathFound;  //
--[ 2019.10.29.21.49.10.645.0 ]--
r 14     private boolean pathFound;  //i
--[ 2019.10.29.21.49.10.874.0 ]--
r 14     private boolean pathFound;  //im
--[ 2019.10.29.21.49.11.024.0 ]--
r 14     private boolean pathFound;  //imp
--[ 2019.10.29.21.49.11.094.0 ]--
r 14     private boolean pathFound;  //impl
--[ 2019.10.29.21.49.11.435.0 ]--
r 14     private boolean pathFound;  //imple
--[ 2019.10.29.21.49.11.550.0 ]--
r 14     private boolean pathFound;  //implem
--[ 2019.10.29.21.49.11.674.0 ]--
r 14     private boolean pathFound;  //impleme
--[ 2019.10.29.21.49.11.841.0 ]--
r 14     private boolean pathFound;  //implemen
--[ 2019.10.29.21.49.11.924.0 ]--
r 14     private boolean pathFound;  //implement
--[ 2019.10.29.21.49.12.056.0 ]--
r 14     private boolean pathFound;  //implement 
--[ 2019.10.29.21.49.12.147.0 ]--
r 14     private boolean pathFound;  //implement i
--[ 2019.10.29.21.49.12.301.0 ]--
r 14     private boolean pathFound;  //implement in
--[ 2019.10.29.21.49.12.472.0 ]--
r 14     private boolean pathFound;  //implement in 
--[ 2019.10.29.21.49.21.808.0 ]--
r 14     private boolean pathFound;  //implement in c
--[ 2019.10.29.21.49.21.960.0 ]--
r 14     private boolean pathFound;  //implement in co
--[ 2019.10.29.21.49.22.089.0 ]--
r 14     private boolean pathFound;  //implement in com
--[ 2019.10.29.21.49.22.298.0 ]--
r 14     private boolean pathFound;  //implement in comp
--[ 2019.10.29.21.49.22.724.0 ]--
r 14     private boolean pathFound;  //implement in compu
--[ 2019.10.29.21.49.22.859.0 ]--
r 14     private boolean pathFound;  //implement in comput
--[ 2019.10.29.21.49.22.940.0 ]--
r 14     private boolean pathFound;  //implement in compute
--[ 2019.10.29.21.49.23.178.0 ]--
r 14     private boolean pathFound;  //implement in compute 
--[ 2019.10.29.21.49.23.413.0 ]--
r 14     private boolean pathFound;  //implement in compute p
--[ 2019.10.29.21.49.23.594.0 ]--
r 14     private boolean pathFound;  //implement in compute pa
--[ 2019.10.29.21.49.23.764.0 ]--
r 14     private boolean pathFound;  //implement in compute par
--[ 2019.10.29.21.49.24.272.0 ]--
r 14     private boolean pathFound;  //implement in compute pa
--[ 2019.10.29.21.49.24.423.0 ]--
r 14     private boolean pathFound;  //implement in compute pat
--[ 2019.10.29.21.49.24.524.0 ]--
r 14     private boolean pathFound;  //implement in compute path
--[ 2019.10.29.21.49.27.672.0 ]--
r 14     private boolean pathFound;  //implement in compute path,
--[ 2019.10.29.21.49.27.839.0 ]--
r 14     private boolean pathFound;  //implement in compute path, 
--[ 2019.10.29.21.49.28.055.0 ]--
r 14     private boolean pathFound;  //implement in compute path, s
--[ 2019.10.29.21.49.28.165.0 ]--
r 14     private boolean pathFound;  //implement in compute path, se
--[ 2019.10.29.21.49.28.349.0 ]--
r 14     private boolean pathFound;  //implement in compute path, set
--[ 2019.10.29.21.49.28.493.0 ]--
r 14     private boolean pathFound;  //implement in compute path, set 
--[ 2019.10.29.21.49.28.608.0 ]--
r 14     private boolean pathFound;  //implement in compute path, set t
--[ 2019.10.29.21.49.28.710.0 ]--
r 14     private boolean pathFound;  //implement in compute path, set to
--[ 2019.10.29.21.49.28.855.0 ]--
r 14     private boolean pathFound;  //implement in compute path, set to 
--[ 2019.10.29.21.49.29.857.0 ]--
r 14     private boolean pathFound;  //implement in compute path, set to t
--[ 2019.10.29.21.49.30.383.0 ]--
r 14     private boolean pathFound;  //implement in compute path, set to tr
--[ 2019.10.29.21.49.30.546.0 ]--
r 14     private boolean pathFound;  //implement in compute path, set to tru
--[ 2019.10.29.21.49.30.656.0 ]--
r 14     private boolean pathFound;  //implement in compute path, set to true
--[ 2019.10.29.21.49.30.826.0 ]--
r 14     private boolean pathFound;  //implement in compute path, set to true 
--[ 2019.10.29.21.49.31.139.0 ]--
r 14     private boolean pathFound;  //implement in compute path, set to true w
--[ 2019.10.29.21.49.31.250.0 ]--
r 14     private boolean pathFound;  //implement in compute path, set to true wh
--[ 2019.10.29.21.49.31.362.0 ]--
r 14     private boolean pathFound;  //implement in compute path, set to true whe
--[ 2019.10.29.21.49.31.542.0 ]--
r 14     private boolean pathFound;  //implement in compute path, set to true when
--[ 2019.10.29.21.49.31.740.0 ]--
r 14     private boolean pathFound;  //implement in compute path, set to true when 
--[ 2019.10.29.21.49.32.957.0 ]--
r 14     private boolean pathFound;  //implement in compute path, set to true when f
--[ 2019.10.29.21.49.33.022.0 ]--
r 14     private boolean pathFound;  //implement in compute path, set to true when fo
--[ 2019.10.29.21.49.33.189.0 ]--
r 14     private boolean pathFound;  //implement in compute path, set to true when fou
--[ 2019.10.29.21.49.33.308.0 ]--
r 14     private boolean pathFound;  //implement in compute path, set to true when foun
--[ 2019.10.29.21.49.33.508.0 ]--
r 14     private boolean pathFound;  //implement in compute path, set to true when found
--[ 2019.10.29.21.49.36.516.0 ]--
r 14     private boolean pathFound ;  //implement in compute path, set to true when found
--[ 2019.10.29.21.49.37.231.0 ]--
r 14     private boolean pathFound =;  //implement in compute path, set to true when found
--[ 2019.10.29.21.49.37.306.0 ]--
r 14     private boolean pathFound = ;  //implement in compute path, set to true when found
--[ 2019.10.29.21.49.37.629.0 ]--
r 14     private boolean pathFound = f;  //implement in compute path, set to true when found
--[ 2019.10.29.21.49.37.749.0 ]--
r 14     private boolean pathFound = fa;  //implement in compute path, set to true when found
--[ 2019.10.29.21.49.37.898.0 ]--
r 14     private boolean pathFound = fal;  //implement in compute path, set to true when found
--[ 2019.10.29.21.49.38.014.0 ]--
r 14     private boolean pathFound = fals;  //implement in compute path, set to true when found
--[ 2019.10.29.21.49.38.139.0 ]--
r 14     private boolean pathFound = false;  //implement in compute path, set to true when found
--[ 2019.10.29.21.49.48.860.0 ]--
r 102         return p;
--[ 2019.10.29.21.49.48.975.0 ]--
r 102         return pa;
--[ 2019.10.29.21.49.49.303.0 ]--
r 102         return path;
--[ 2019.10.29.21.49.50.472.0 ]--
r 102         return pathFound;
--[ 2019.10.29.21.51.32.358.0 ]--
+ 28             
--[ 2019.10.29.21.51.39.858.0 ]--
r 28             l
--[ 2019.10.29.21.51.40.159.0 ]--
r 28             lo
--[ 2019.10.29.21.51.40.195.0 ]--
r 28             loc
--[ 2019.10.29.21.51.40.535.0 ]--
r 28             loc.
--[ 2019.10.29.21.51.41.934.0 ]--
r 28             loc.c
--[ 2019.10.29.21.51.42.058.0 ]--
r 28             loc.co
--[ 2019.10.29.21.51.42.930.0 ]--
r 28             loc.com
--[ 2019.10.29.21.51.43.087.0 ]--
r 28             loc.comp
--[ 2019.10.29.21.51.43.153.0 ]--
r 28             loc.compa
--[ 2019.10.29.21.51.43.361.0 ]--
r 28             loc.compar
--[ 2019.10.29.21.51.43.545.0 ]--
r 28             loc.compare
--[ 2019.10.29.21.51.43.879.0 ]--
r 28             loc.compareT
--[ 2019.10.29.21.51.45.175.0 ]--
r 28             loc.compareTo
--[ 2019.10.29.21.51.46.497.0 ]--
r 28             loc.compareTo()
--[ 2019.10.29.21.51.46.859.0 ]--
r 28             loc.compareTo(t)
--[ 2019.10.29.21.51.46.958.0 ]--
r 28             loc.compareTo(th)
--[ 2019.10.29.21.51.47.149.0 ]--
r 28             loc.compareTo(this)
--[ 2019.10.29.21.51.51.714.0 ]--
r 28             iloc.compareTo(this)
--[ 2019.10.29.21.51.52.060.0 ]--
r 28             ifloc.compareTo(this)
--[ 2019.10.29.21.51.52.442.0 ]--
r 28             if(loc.compareTo(this)
--[ 2019.10.29.21.51.57.244.0 ]--
r 28             if(loc.compareTo(this) 
--[ 2019.10.29.21.51.57.692.0 ]--
r 28             if(loc.compareTo(this) <
--[ 2019.10.29.21.51.59.787.0 ]--
r 28             if(loc.compareTo(this) < 
--[ 2019.10.29.21.52.00.003.0 ]--
r 28             if(loc.compareTo(this) < 0
--[ 2019.10.29.21.52.01.096.0 ]--
r 28             if(loc.compareTo(this) < 0)
--[ 2019.10.29.21.52.02.009.0 ]--
r 28             if(loc.compareTo(this) < 0){
--[ 2019.10.29.21.52.02.358.0 ]--
+ 29 
+ 30 }
--[ 2019.10.29.21.52.02.373.0 ]--
r 30             }
--[ 2019.10.29.21.52.02.392.0 ]--
r 29                 
--[ 2019.10.29.21.52.03.399.0 ]--
r 29                 r
--[ 2019.10.29.21.52.03.567.0 ]--
r 29                 re
--[ 2019.10.29.21.52.03.841.0 ]--
r 29                 ret
--[ 2019.10.29.21.52.04.034.0 ]--
r 29                 retu
--[ 2019.10.29.21.52.04.111.0 ]--
r 29                 retur
--[ 2019.10.29.21.52.04.258.0 ]--
r 29                 return
--[ 2019.10.29.21.52.11.565.0 ]--
r 29                 return 
--[ 2019.10.29.21.52.18.300.0 ]--
r 29                 return l
--[ 2019.10.29.21.52.18.573.0 ]--
r 29                 return lo
--[ 2019.10.29.21.52.18.945.0 ]--
r 29                 return loc
--[ 2019.10.29.21.52.19.409.0 ]--
r 29                 return loc;
--[ 2019.10.29.21.52.25.926.0 ]--
r 28             if(loc.compareTo(this) =< 0){
--[ 2019.10.29.21.52.29.277.0 ]--
r 28             if(loc.compareTo(this) = 0){
--[ 2019.10.29.21.52.31.037.0 ]--
r 28             if(loc.compareTo(this) <= 0){
--[ 2019.10.29.21.52.35.928.0 ]--
r 28             if(loc.compareTo(this) < 0){
--[ 2019.10.29.21.52.36.293.0 ]--
r 28             if(loc.compareTo(this)  0){
--[ 2019.10.29.21.52.37.311.0 ]--
r 28             if(loc.compareTo(this) > 0){
--[ 2019.10.29.21.52.39.770.0 ]--
r 29                 return t;
--[ 2019.10.29.21.52.39.877.0 ]--
r 29                 return th;
--[ 2019.10.29.21.52.39.942.0 ]--
r 29                 return tha;
--[ 2019.10.29.21.52.40.009.0 ]--
r 29                 return that;
--[ 2019.10.29.21.52.53.844.0 ]--
- 29
- 29
r 29 
--[ 2019.10.29.21.52.54.429.0 ]--
- 29
--[ 2019.10.29.21.52.55.093.0 ]--
r 28             if(loc.compareTo(this) > 0)
--[ 2019.10.29.21.52.56.814.0 ]--
r 28             if(loc.compareTo(this) > 0
--[ 2019.10.29.21.52.57.183.0 ]--
r 28             if(loc.compareTo(this) > 
--[ 2019.10.29.21.52.57.800.0 ]--
r 28             if(loc.compareTo(this) >
--[ 2019.10.29.21.52.58.675.0 ]--
r 28             if(loc.compareTo(this) 
--[ 2019.10.29.21.52.59.141.0 ]--
r 28             if(loc.compareTo(this)
--[ 2019.10.29.21.53.01.872.0 ]--
r 28             ifloc.compareTo(this)
--[ 2019.10.29.21.53.02.096.0 ]--
r 28             iloc.compareTo(this)
--[ 2019.10.29.21.53.02.511.0 ]--
r 28             loc.compareTo(this)
--[ 2019.10.29.21.53.03.146.0 ]--
r 28             rloc.compareTo(this)
--[ 2019.10.29.21.53.03.427.0 ]--
r 28             reloc.compareTo(this)
--[ 2019.10.29.21.53.03.743.0 ]--
r 28             retloc.compareTo(this)
--[ 2019.10.29.21.53.03.944.0 ]--
r 28             retuloc.compareTo(this)
--[ 2019.10.29.21.53.04.110.0 ]--
r 28             returloc.compareTo(this)
--[ 2019.10.29.21.53.04.224.0 ]--
r 28             returnloc.compareTo(this)
--[ 2019.10.29.21.53.04.495.0 ]--
r 28             return loc.compareTo(this)
--[ 2019.10.29.21.53.06.726.0 ]--
r 28             return loc.compareTo(this);
--[ 2019.10.29.21.53.10.060.0 ]--
r 28             return t.compareTo(this);
--[ 2019.10.29.21.53.10.210.0 ]--
r 28             return th.compareTo(this);
--[ 2019.10.29.21.53.10.309.0 ]--
r 28             return thi.compareTo(this);
--[ 2019.10.29.21.53.10.392.0 ]--
r 28             return this.compareTo(this);
--[ 2019.10.29.21.53.17.436.0 ]--
r 28             return this.compareTo(t);
--[ 2019.10.29.21.53.17.552.0 ]--
r 28             return this.compareTo(th);
--[ 2019.10.29.21.53.17.611.0 ]--
r 28             return this.compareTo(tha);
--[ 2019.10.29.21.53.17.698.0 ]--
r 28             return this.compareTo(that);
--[ 2019.10.29.21.53.38.059.0 ]--
r 28             return l.compareTo(that);
--[ 2019.10.29.21.53.38.326.0 ]--
r 28             return lo.compareTo(that);
--[ 2019.10.29.21.53.38.410.0 ]--
r 28             return loc.compareTo(that);
--[ 2019.10.29.21.53.46.828.0 ]--
r 28             return Ploc.compareTo(that);
--[ 2019.10.29.21.53.47.142.0 ]--
r 28             return PFloc.compareTo(that);
--[ 2019.10.29.21.53.48.226.0 ]--
r 28             return PFNodeloc.compareTo(that);
--[ 2019.10.29.21.53.48.246.0 ]--
r 28             return PFNode loc.compareTo(that);
--[ 2019.10.29.21.53.48.276.0 ]--
r 28             return PFNodeloc.compareTo(that);
--[ 2019.10.29.21.53.49.540.0 ]--
r 28             return PFNode.loc.compareTo(that);
--[ 2019.10.29.21.53.58.893.0 ]--
r 28             return PFNode..compareTo(that);
--[ 2019.10.29.21.53.59.635.0 ]--
r 28             return PFNode.compareTo(that);
--[ 2019.10.29.21.54.08.873.0 ]--
r 28             return PFNode.ncompareTo(that);
--[ 2019.10.29.21.54.08.961.0 ]--
r 28             return PFNode.nocompareTo(that);
--[ 2019.10.29.21.54.09.151.0 ]--
r 28             return PFNode.nodcompareTo(that);
--[ 2019.10.29.21.54.09.363.0 ]--
r 28             return PFNode.nodecompareTo(that);
--[ 2019.10.29.21.54.10.438.0 ]--
r 28             return PFNode.nodcompareTo(that);
--[ 2019.10.29.21.54.10.642.0 ]--
r 28             return PFNode.nocompareTo(that);
--[ 2019.10.29.21.54.10.927.0 ]--
r 28             return PFNode.ncompareTo(that);
--[ 2019.10.29.21.54.11.197.0 ]--
r 28             return PFNode.compareTo(that);
--[ 2019.10.29.21.54.12.253.0 ]--
r 28             return PFNode.lcompareTo(that);
--[ 2019.10.29.21.54.12.475.0 ]--
r 28             return PFNode.locompareTo(that);
--[ 2019.10.29.21.54.13.255.0 ]--
r 28             return PFNode.loccompareTo(that);
--[ 2019.10.29.21.54.15.176.0 ]--
r 28             return PFNode.loc.compareTo(that);
--[ 2019.10.29.21.54.22.327.0 ]--
r 28             return PFNode.loc.compareTo(that); 
--[ 2019.10.29.21.54.22.776.0 ]--
r 28             return PFNode.loc.compareTo(that); /
--[ 2019.10.29.21.54.22.966.0 ]--
r 28             return PFNode.loc.compareTo(that); //
--[ 2019.10.29.21.54.23.925.0 ]--
r 28             return PFNode.loc.compareTo(that); //h
--[ 2019.10.29.21.54.24.094.0 ]--
r 28             return PFNode.loc.compareTo(that); //he
--[ 2019.10.29.21.54.24.192.0 ]--
r 28             return PFNode.loc.compareTo(that); //hel
--[ 2019.10.29.21.54.24.383.0 ]--
r 28             return PFNode.loc.compareTo(that); //help
--[ 2019.10.29.21.54.29.675.0 ]--
r 28             /return PFNode.loc.compareTo(that); //help
--[ 2019.10.29.21.54.29.781.0 ]--
r 28             //return PFNode.loc.compareTo(that); //help
--[ 2019.10.29.21.54.32.050.0 ]--
+ 29             
--[ 2019.10.29.21.54.32.429.0 ]--
r 29             r
--[ 2019.10.29.21.54.32.580.0 ]--
r 29             re
--[ 2019.10.29.21.54.32.844.0 ]--
r 29             ret
--[ 2019.10.29.21.54.33.077.0 ]--
r 29             retu
--[ 2019.10.29.21.54.33.211.0 ]--
r 29             retur
--[ 2019.10.29.21.54.33.279.0 ]--
r 29             return
--[ 2019.10.29.21.54.33.626.0 ]--
r 29             return 
--[ 2019.10.29.21.54.34.120.0 ]--
r 29             return 0
--[ 2019.10.29.21.54.34.550.0 ]--
r 29             return 0;
--[ 2019.10.29.21.55.43.418.0 ]--
r 111         return s;
--[ 2019.10.29.21.55.43.694.0 ]--
r 111         return se;
--[ 2019.10.29.21.55.43.795.0 ]--
r 111         return sea;
--[ 2019.10.29.21.55.43.963.0 ]--
r 111         return sear;
--[ 2019.10.29.21.55.44.362.0 ]--
r 111         return searc;
--[ 2019.10.29.21.55.44.707.0 ]--
r 111         return search;
--[ 2019.10.29.21.55.45.581.0 ]--
r 111         return searchS;
--[ 2019.10.29.21.55.46.696.0 ]--
r 111         return searchSi;
--[ 2019.10.29.21.55.47.028.0 ]--
r 111         return searchSiz;
--[ 2019.10.29.21.55.47.313.0 ]--
r 111         return searchSize;
--[ 2019.10.29.21.55.51.996.0 ]--
+ 15     
--[ 2019.10.29.21.55.52.700.0 ]--
r 15     p
--[ 2019.10.29.21.55.53.030.0 ]--
r 15     pr
--[ 2019.10.29.21.55.53.130.0 ]--
r 15     pri
--[ 2019.10.29.21.55.53.446.0 ]--
r 15     priv
--[ 2019.10.29.21.55.53.644.0 ]--
r 15     priva
--[ 2019.10.29.21.55.53.799.0 ]--
r 15     privat
--[ 2019.10.29.21.55.53.967.0 ]--
r 15     private
--[ 2019.10.29.21.55.54.062.0 ]--
r 15     private 
--[ 2019.10.29.21.55.54.209.0 ]--
r 15     private i
--[ 2019.10.29.21.55.54.279.0 ]--
r 15     private in
--[ 2019.10.29.21.55.54.812.0 ]--
r 15     private int
--[ 2019.10.29.21.55.55.010.0 ]--
r 15     private int 
--[ 2019.10.29.21.55.55.712.0 ]--
r 15     private int s
--[ 2019.10.29.21.55.55.813.0 ]--
r 15     private int se
--[ 2019.10.29.21.55.55.995.0 ]--
r 15     private int sea
--[ 2019.10.29.21.55.56.071.0 ]--
r 15     private int sear
--[ 2019.10.29.21.55.56.395.0 ]--
r 15     private int searc
--[ 2019.10.29.21.55.56.518.0 ]--
r 15     private int search
--[ 2019.10.29.21.55.57.031.0 ]--
r 15     private int searchSize
--[ 2019.10.29.21.55.58.945.0 ]--
r 15     private int searchSize;
--[ 2019.10.29.21.56.13.718.0 ]--
r 105     } 
--[ 2019.10.29.21.56.14.220.0 ]--
r 105     }  
--[ 2019.10.29.21.56.14.383.0 ]--
r 105     }  /
--[ 2019.10.29.21.56.14.595.0 ]--
r 105     }  //
--[ 2019.10.29.21.56.15.016.0 ]--
r 105     }  // 
--[ 2019.10.29.21.56.15.395.0 ]--
r 105     }  // i
--[ 2019.10.29.21.56.15.727.0 ]--
r 105     }  // 
--[ 2019.10.29.21.56.15.875.0 ]--
r 105     }  //
--[ 2019.10.29.21.56.16.497.0 ]--
r 105     }  //i
--[ 2019.10.29.21.56.16.635.0 ]--
r 105     }  //im
--[ 2019.10.29.21.56.16.895.0 ]--
r 105     }  //imp
--[ 2019.10.29.21.56.16.961.0 ]--
r 105     }  //impl
--[ 2019.10.29.21.56.17.234.0 ]--
r 105     }  //imple
--[ 2019.10.29.21.56.17.348.0 ]--
r 105     }  //implem
--[ 2019.10.29.21.56.17.469.0 ]--
r 105     }  //impleme
--[ 2019.10.29.21.56.17.634.0 ]--
r 105     }  //implemen
--[ 2019.10.29.21.56.17.748.0 ]--
r 105     }  //implement
--[ 2019.10.29.21.56.17.877.0 ]--
r 105     }  //implement 
--[ 2019.10.29.21.56.18.001.0 ]--
r 105     }  //implement i
--[ 2019.10.29.21.56.18.145.0 ]--
r 105     }  //implement in
--[ 2019.10.29.21.56.18.298.0 ]--
r 105     }  //implement in 
--[ 2019.10.29.21.56.20.476.0 ]--
r 105     }  //implement in c
--[ 2019.10.29.21.56.20.611.0 ]--
r 105     }  //implement in co
--[ 2019.10.29.21.56.20.727.0 ]--
r 105     }  //implement in com
--[ 2019.10.29.21.56.20.955.0 ]--
r 105     }  //implement in comp
--[ 2019.10.29.21.56.21.245.0 ]--
r 105     }  //implement in compu
--[ 2019.10.29.21.56.21.387.0 ]--
r 105     }  //implement in comput
--[ 2019.10.29.21.56.21.496.0 ]--
r 105     }  //implement in compute
--[ 2019.10.29.21.56.21.584.0 ]--
r 105     }  //implement in compute 
--[ 2019.10.29.21.56.22.112.0 ]--
r 105     }  //implement in compute p
--[ 2019.10.29.21.56.22.219.0 ]--
r 105     }  //implement in compute pa
--[ 2019.10.29.21.56.22.347.0 ]--
r 105     }  //implement in compute par
--[ 2019.10.29.21.56.22.518.0 ]--
r 105     }  //implement in compute pare
--[ 2019.10.29.21.56.23.155.0 ]--
r 105     }  //implement in compute par
--[ 2019.10.29.21.56.23.311.0 ]--
r 105     }  //implement in compute pa
--[ 2019.10.29.21.56.23.896.0 ]--
r 105     }  //implement in compute pat
--[ 2019.10.29.21.56.23.954.0 ]--
r 105     }  //implement in compute path
--[ 2019.10.29.21.56.29.429.0 ]--
r 113     } 
--[ 2019.10.29.21.56.29.630.0 ]--
r 113     } //implement in compute path
--[ 2019.10.29.22.00.25.549.0 ]--
+ 72         
--[ 2019.10.29.22.00.26.303.0 ]--
r 72         i
--[ 2019.10.29.22.00.26.444.0 ]--
r 72         if
--[ 2019.10.29.22.00.27.887.0 ]--
r 72         if()
--[ 2019.10.29.22.00.29.673.0 ]--
r 72         if(c)
--[ 2019.10.29.22.00.31.674.0 ]--
r 72         if()
--[ 2019.10.29.22.00.33.083.0 ]--
r 72         if(l)
--[ 2019.10.29.22.00.33.297.0 ]--
r 72         if(lo)
--[ 2019.10.29.22.00.33.401.0 ]--
r 72         if(loc)
--[ 2019.10.29.22.00.34.365.0 ]--
r 72         if(loc )
--[ 2019.10.29.22.00.34.876.0 ]--
r 72         if(loc =)
--[ 2019.10.29.22.00.35.007.0 ]--
r 72         if(loc ==)
--[ 2019.10.29.22.00.35.405.0 ]--
r 72         if(loc == )
--[ 2019.10.29.22.00.35.563.0 ]--
r 72         if(loc == n)
--[ 2019.10.29.22.00.35.750.0 ]--
r 72         if(loc == nu)
--[ 2019.10.29.22.00.35.998.0 ]--
r 72         if(loc == nul)
--[ 2019.10.29.22.00.36.156.0 ]--
r 72         if(loc == null)
--[ 2019.10.29.22.00.37.992.0 ]--
r 72         if(loc == null) 
--[ 2019.10.29.22.00.38.447.0 ]--
r 72         if(loc == null) t
--[ 2019.10.29.22.00.38.600.0 ]--
r 72         if(loc == null) th
--[ 2019.10.29.22.00.38.776.0 ]--
r 72         if(loc == null) thr
--[ 2019.10.29.22.00.39.064.0 ]--
r 72         if(loc == null) thro
--[ 2019.10.29.22.00.39.198.0 ]--
r 72         if(loc == null) throw
--[ 2019.10.29.22.00.39.388.0 ]--
r 72         if(loc == null) throw 
--[ 2019.10.29.22.00.39.776.0 ]--
r 72         if(loc == null) throw n
--[ 2019.10.29.22.00.39.891.0 ]--
r 72         if(loc == null) throw ne
--[ 2019.10.29.22.00.40.656.0 ]--
r 72         if(loc == null) throw new
--[ 2019.10.29.22.00.40.824.0 ]--
r 72         if(loc == null) throw new 
--[ 2019.10.29.22.00.58.174.0 ]--
r 72         if(loc == null) throw new I
--[ 2019.10.29.22.00.58.999.0 ]--
r 72         if(loc == null) throw new Ill
--[ 2019.10.29.22.01.00.098.0 ]--
r 72         if(loc == null) throw new IllegalArgumentException
--[ 2019.10.29.22.01.00.131.0 ]--
r 72         if(loc == null) throw new IllegalArgumentException()
--[ 2019.10.29.22.01.02.850.0 ]--
r 72         if(loc == null) throw new IllegalArgumentException("")
--[ 2019.10.29.22.01.08.116.0 ]--
r 72         if(loc == null) throw new IllegalArgumentException("t")
--[ 2019.10.29.22.01.08.232.0 ]--
r 72         if(loc == null) throw new IllegalArgumentException("th")
--[ 2019.10.29.22.01.08.336.0 ]--
r 72         if(loc == null) throw new IllegalArgumentException("the")
--[ 2019.10.29.22.01.08.521.0 ]--
r 72         if(loc == null) throw new IllegalArgumentException("the ")
--[ 2019.10.29.22.01.08.807.0 ]--
r 72         if(loc == null) throw new IllegalArgumentException("the l")
--[ 2019.10.29.22.01.09.030.0 ]--
r 72         if(loc == null) throw new IllegalArgumentException("the lo")
--[ 2019.10.29.22.01.09.170.0 ]--
r 72         if(loc == null) throw new IllegalArgumentException("the loc")
--[ 2019.10.29.22.01.09.284.0 ]--
r 72         if(loc == null) throw new IllegalArgumentException("the loca")
--[ 2019.10.29.22.01.09.567.0 ]--
r 72         if(loc == null) throw new IllegalArgumentException("the locat")
--[ 2019.10.29.22.01.09.684.0 ]--
r 72         if(loc == null) throw new IllegalArgumentException("the locati")
--[ 2019.10.29.22.01.09.826.0 ]--
r 72         if(loc == null) throw new IllegalArgumentException("the locatio")
--[ 2019.10.29.22.01.09.895.0 ]--
r 72         if(loc == null) throw new IllegalArgumentException("the location")
--[ 2019.10.29.22.01.11.882.0 ]--
r 72         if(loc == null) throw new IllegalArgumentException("the location ")
--[ 2019.10.29.22.01.12.067.0 ]--
r 72         if(loc == null) throw new IllegalArgumentException("the location i")
--[ 2019.10.29.22.01.12.187.0 ]--
r 72         if(loc == null) throw new IllegalArgumentException("the location is")
--[ 2019.10.29.22.01.12.350.0 ]--
r 72         if(loc == null) throw new IllegalArgumentException("the location is ")
--[ 2019.10.29.22.01.12.843.0 ]--
r 72         if(loc == null) throw new IllegalArgumentException("the location is n")
--[ 2019.10.29.22.01.13.034.0 ]--
r 72         if(loc == null) throw new IllegalArgumentException("the location is nu")
--[ 2019.10.29.22.01.13.274.0 ]--
r 72         if(loc == null) throw new IllegalArgumentException("the location is nul")
--[ 2019.10.29.22.01.13.416.0 ]--
r 72         if(loc == null) throw new IllegalArgumentException("the location is null")
--[ 2019.10.29.22.01.16.849.0 ]--
r 72         if(loc == null) throw new IllegalArgumentException("he location is null")
--[ 2019.10.29.22.01.17.359.0 ]--
r 72         if(loc == null) throw new IllegalArgumentException("The location is null")
--[ 2019.10.29.22.01.19.766.0 ]--
r 72         if(loc == null) throw new IllegalArgumentException("The location is null");
--[ 2019.10.29.22.01.23.999.0 ]--
r 72         if(loc == null) throw new IllegalArgumentException("The location is null.");
--[ 2019.10.29.22.01.52.872.0 ]--
+ 81         
--[ 2019.10.29.22.01.53.150.0 ]--
r 81         if(loc == null) throw new IllegalArgumentException("The location is null.");
--[ 2019.10.29.22.02.38.721.0 ]--
+ 103         
--[ 2019.10.29.22.02.40.585.0 ]--
r 103         i
--[ 2019.10.29.22.02.40.866.0 ]--
r 103         if
--[ 2019.10.29.22.02.42.969.0 ]--
r 103         if()
--[ 2019.10.29.22.03.14.633.0 ]--
r 103         if(g)
--[ 2019.10.29.22.03.14.816.0 ]--
r 103         if(ge)
--[ 2019.10.29.22.03.14.938.0 ]--
r 103         if(get)
--[ 2019.10.29.22.03.15.536.0 ]--
r 103         if(getP)
--[ 2019.10.29.22.03.15.667.0 ]--
r 103         if(getPA)
--[ 2019.10.29.22.03.16.617.0 ]--
r 103         if(getPathEnd)
--[ 2019.10.29.22.03.16.642.0 ]--
r 103         if(getPathEnd())
--[ 2019.10.29.22.03.18.311.0 ]--
r 103         if(getPathEnd() )
--[ 2019.10.29.22.03.18.466.0 ]--
r 103         if(getPathEnd() =)
--[ 2019.10.29.22.03.18.602.0 ]--
r 103         if(getPathEnd() ==)
--[ 2019.10.29.22.03.19.133.0 ]--
r 103         if(getPathEnd() == )
--[ 2019.10.29.22.03.19.262.0 ]--
r 103         if(getPathEnd() == n)
--[ 2019.10.29.22.03.19.384.0 ]--
r 103         if(getPathEnd() == nu)
--[ 2019.10.29.22.03.19.633.0 ]--
r 103         if(getPathEnd() == nul)
--[ 2019.10.29.22.03.19.801.0 ]--
r 103         if(getPathEnd() == null)
--[ 2019.10.29.22.03.21.543.0 ]--
r 103         if(getPathEnd() == null )
--[ 2019.10.29.22.03.23.491.0 ]--
r 103         if(getPathEnd() == null |)
--[ 2019.10.29.22.03.23.773.0 ]--
r 103         if(getPathEnd() == null ||)
--[ 2019.10.29.22.03.24.407.0 ]--
r 103         if(getPathEnd() == null || )
--[ 2019.10.29.22.03.25.486.0 ]--
r 103         if(getPathEnd() == null || g)
--[ 2019.10.29.22.03.25.826.0 ]--
r 103         if(getPathEnd() == null || get)
--[ 2019.10.29.22.03.28.771.0 ]--
r 103         if(getPathEnd() == null || getPathStart)
--[ 2019.10.29.22.03.28.784.0 ]--
r 103         if(getPathEnd() == null || getPathStart())
--[ 2019.10.29.22.03.30.134.0 ]--
r 103         if(getPathEnd() == null || getPathStart() )
--[ 2019.10.29.22.03.30.259.0 ]--
r 103         if(getPathEnd() == null || getPathStart() =)
--[ 2019.10.29.22.03.30.377.0 ]--
r 103         if(getPathEnd() == null || getPathStart() ==)
--[ 2019.10.29.22.03.31.135.0 ]--
r 103         if(getPathEnd() == null || getPathStart() == )
--[ 2019.10.29.22.03.31.336.0 ]--
r 103         if(getPathEnd() == null || getPathStart() == n)
--[ 2019.10.29.22.03.31.573.0 ]--
r 103         if(getPathEnd() == null || getPathStart() == nu)
--[ 2019.10.29.22.03.31.934.0 ]--
r 103         if(getPathEnd() == null || getPathStart() == nul)
--[ 2019.10.29.22.03.32.049.0 ]--
r 103         if(getPathEnd() == null || getPathStart() == null)
--[ 2019.10.29.22.03.34.636.0 ]--
r 103         if(getPathEnd() == null || getPathStart() == null) 
--[ 2019.10.29.22.03.35.074.0 ]--
r 103         if(getPathEnd() == null || getPathStart() == null) t
--[ 2019.10.29.22.03.35.540.0 ]--
r 103         if(getPathEnd() == null || getPathStart() == null) th
--[ 2019.10.29.22.03.37.583.0 ]--
r 103         if(getPathEnd() == null || getPathStart() == null) throw
--[ 2019.10.29.22.03.37.618.0 ]--
r 103         if(getPathEnd() == null || getPathStart() == null) throw 
--[ 2019.10.29.22.03.38.749.0 ]--
r 103         if(getPathEnd() == null || getPathStart() == null) throw n
--[ 2019.10.29.22.03.39.104.0 ]--
r 103         if(getPathEnd() == null || getPathStart() == null) throw new
--[ 2019.10.29.22.03.39.218.0 ]--
r 103         if(getPathEnd() == null || getPathStart() == null) throw new 
--[ 2019.10.29.22.03.50.191.0 ]--
r 103         if(getPathEnd() == null || getPathStart() == null) throw new I
--[ 2019.10.29.22.03.50.462.0 ]--
r 103         if(getPathEnd() == null || getPathStart() == null) throw new Il
--[ 2019.10.29.22.03.50.708.0 ]--
r 103         if(getPathEnd() == null || getPathStart() == null) throw new Ill
--[ 2019.10.29.22.03.50.870.0 ]--
r 103         if(getPathEnd() == null || getPathStart() == null) throw new Ille
--[ 2019.10.29.22.03.51.484.0 ]--
r 103         if(getPathEnd() == null || getPathStart() == null) throw new IllegalArgumentException
--[ 2019.10.29.22.03.51.566.0 ]--
r 103         if(getPathEnd() == null || getPathStart() == null) throw new IllegalArgumentException()
--[ 2019.10.29.22.03.53.468.0 ]--
r 103         if(getPathEnd() == null || getPathStart() == null) throw new IllegalArgumentException("")
--[ 2019.10.29.22.03.55.427.0 ]--
r 103         if(getPathEnd() == null || getPathStart() == null) throw new IllegalArgumentException("E")
--[ 2019.10.29.22.03.55.950.0 ]--
r 103         if(getPathEnd() == null || getPathStart() == null) throw new IllegalArgumentException("Ei")
--[ 2019.10.29.22.03.56.239.0 ]--
r 103         if(getPathEnd() == null || getPathStart() == null) throw new IllegalArgumentException("Eit")
--[ 2019.10.29.22.03.56.359.0 ]--
r 103         if(getPathEnd() == null || getPathStart() == null) throw new IllegalArgumentException("Eith")
--[ 2019.10.29.22.03.56.494.0 ]--
r 103         if(getPathEnd() == null || getPathStart() == null) throw new IllegalArgumentException("Eithe")
--[ 2019.10.29.22.03.56.551.0 ]--
r 103         if(getPathEnd() == null || getPathStart() == null) throw new IllegalArgumentException("Either")
--[ 2019.10.29.22.03.56.730.0 ]--
r 103         if(getPathEnd() == null || getPathStart() == null) throw new IllegalArgumentException("Either ")
--[ 2019.10.29.22.04.03.167.0 ]--
r 103         if(getPathEnd() == null || getPathStart() == null) throw new IllegalArgumentException("Either o")
--[ 2019.10.29.22.04.03.446.0 ]--
r 103         if(getPathEnd() == null || getPathStart() == null) throw new IllegalArgumentException("Either or")
--[ 2019.10.29.22.04.03.771.0 ]--
r 103         if(getPathEnd() == null || getPathStart() == null) throw new IllegalArgumentException("Either or ")
--[ 2019.10.29.22.04.04.451.0 ]--
r 103         if(getPathEnd() == null || getPathStart() == null) throw new IllegalArgumentException("Either or b")
--[ 2019.10.29.22.04.04.633.0 ]--
r 103         if(getPathEnd() == null || getPathStart() == null) throw new IllegalArgumentException("Either or bo")
--[ 2019.10.29.22.04.05.384.0 ]--
r 103         if(getPathEnd() == null || getPathStart() == null) throw new IllegalArgumentException("Either or bot")
--[ 2019.10.29.22.04.05.484.0 ]--
r 103         if(getPathEnd() == null || getPathStart() == null) throw new IllegalArgumentException("Either or both")
--[ 2019.10.29.22.04.05.616.0 ]--
r 103         if(getPathEnd() == null || getPathStart() == null) throw new IllegalArgumentException("Either or both ")
--[ 2019.10.29.22.04.05.823.0 ]--
r 103         if(getPathEnd() == null || getPathStart() == null) throw new IllegalArgumentException("Either or both o")
--[ 2019.10.29.22.04.05.938.0 ]--
r 103         if(getPathEnd() == null || getPathStart() == null) throw new IllegalArgumentException("Either or both of")
--[ 2019.10.29.22.04.06.163.0 ]--
r 103         if(getPathEnd() == null || getPathStart() == null) throw new IllegalArgumentException("Either or both of ")
--[ 2019.10.29.22.04.10.301.0 ]--
r 103         if(getPathEnd() == null || getPathStart() == null) throw new IllegalArgumentException("Either or both of s")
--[ 2019.10.29.22.04.11.175.0 ]--
r 103         if(getPathEnd() == null || getPathStart() == null) throw new IllegalArgumentException("Either or both of st")
--[ 2019.10.29.22.04.11.348.0 ]--
r 103         if(getPathEnd() == null || getPathStart() == null) throw new IllegalArgumentException("Either or both of sta")
--[ 2019.10.29.22.04.11.752.0 ]--
r 103         if(getPathEnd() == null || getPathStart() == null) throw new IllegalArgumentException("Either or both of star")
--[ 2019.10.29.22.04.11.931.0 ]--
r 103         if(getPathEnd() == null || getPathStart() == null) throw new IllegalArgumentException("Either or both of start")
--[ 2019.10.29.22.04.12.121.0 ]--
r 103         if(getPathEnd() == null || getPathStart() == null) throw new IllegalArgumentException("Either or both of start ")
--[ 2019.10.29.22.04.12.884.0 ]--
r 103         if(getPathEnd() == null || getPathStart() == null) throw new IllegalArgumentException("Either or both of start p")
--[ 2019.10.29.22.04.12.984.0 ]--
r 103         if(getPathEnd() == null || getPathStart() == null) throw new IllegalArgumentException("Either or both of start pa")
--[ 2019.10.29.22.04.13.239.0 ]--
r 103         if(getPathEnd() == null || getPathStart() == null) throw new IllegalArgumentException("Either or both of start pat")
--[ 2019.10.29.22.04.13.360.0 ]--
r 103         if(getPathEnd() == null || getPathStart() == null) throw new IllegalArgumentException("Either or both of start pat ")
--[ 2019.10.29.22.04.13.533.0 ]--
r 103         if(getPathEnd() == null || getPathStart() == null) throw new IllegalArgumentException("Either or both of start pat h")
--[ 2019.10.29.22.04.14.150.0 ]--
r 103         if(getPathEnd() == null || getPathStart() == null) throw new IllegalArgumentException("Either or both of start pat ")
--[ 2019.10.29.22.04.14.325.0 ]--
r 103         if(getPathEnd() == null || getPathStart() == null) throw new IllegalArgumentException("Either or both of start pat")
--[ 2019.10.29.22.04.15.050.0 ]--
r 103         if(getPathEnd() == null || getPathStart() == null) throw new IllegalArgumentException("Either or both of start path")
--[ 2019.10.29.22.04.15.317.0 ]--
r 103         if(getPathEnd() == null || getPathStart() == null) throw new IllegalArgumentException("Either or both of start path ")
--[ 2019.10.29.22.04.16.735.0 ]--
r 103         if(getPathEnd() == null || getPathStart() == null) throw new IllegalArgumentException("Either or both of start path o")
--[ 2019.10.29.22.04.16.867.0 ]--
r 103         if(getPathEnd() == null || getPathStart() == null) throw new IllegalArgumentException("Either or both of start path or")
--[ 2019.10.29.22.04.17.111.0 ]--
r 103         if(getPathEnd() == null || getPathStart() == null) throw new IllegalArgumentException("Either or both of start path or ")
--[ 2019.10.29.22.04.17.752.0 ]--
r 103         if(getPathEnd() == null || getPathStart() == null) throw new IllegalArgumentException("Either or both of start path or e")
--[ 2019.10.29.22.04.17.887.0 ]--
r 103         if(getPathEnd() == null || getPathStart() == null) throw new IllegalArgumentException("Either or both of start path or en")
--[ 2019.10.29.22.04.18.042.0 ]--
r 103         if(getPathEnd() == null || getPathStart() == null) throw new IllegalArgumentException("Either or both of start path or end")
--[ 2019.10.29.22.04.18.182.0 ]--
r 103         if(getPathEnd() == null || getPathStart() == null) throw new IllegalArgumentException("Either or both of start path or end ")
--[ 2019.10.29.22.04.18.754.0 ]--
r 103         if(getPathEnd() == null || getPathStart() == null) throw new IllegalArgumentException("Either or both of start path or end p")
--[ 2019.10.29.22.04.18.887.0 ]--
r 103         if(getPathEnd() == null || getPathStart() == null) throw new IllegalArgumentException("Either or both of start path or end pa")
--[ 2019.10.29.22.04.19.217.0 ]--
r 103         if(getPathEnd() == null || getPathStart() == null) throw new IllegalArgumentException("Either or both of start path or end pat")
--[ 2019.10.29.22.04.19.311.0 ]--
r 103         if(getPathEnd() == null || getPathStart() == null) throw new IllegalArgumentException("Either or both of start path or end path")
--[ 2019.10.29.22.04.22.355.0 ]--
r 103         if(getPathEnd() == null || getPathStart() == null) throw new IllegalArgumentException("Either or both of start path or end path ")
--[ 2019.10.29.22.04.22.785.0 ]--
r 103         if(getPathEnd() == null || getPathStart() == null) throw new IllegalArgumentException("Either or both of start path or end path h")
--[ 2019.10.29.22.04.22.868.0 ]--
r 103         if(getPathEnd() == null || getPathStart() == null) throw new IllegalArgumentException("Either or both of start path or end path ha")
--[ 2019.10.29.22.04.23.185.0 ]--
r 103         if(getPathEnd() == null || getPathStart() == null) throw new IllegalArgumentException("Either or both of start path or end path hav")
--[ 2019.10.29.22.04.23.361.0 ]--
r 103         if(getPathEnd() == null || getPathStart() == null) throw new IllegalArgumentException("Either or both of start path or end path have")
--[ 2019.10.29.22.04.23.517.0 ]--
r 103         if(getPathEnd() == null || getPathStart() == null) throw new IllegalArgumentException("Either or both of start path or end path have ")
--[ 2019.10.29.22.04.23.934.0 ]--
r 103         if(getPathEnd() == null || getPathStart() == null) throw new IllegalArgumentException("Either or both of start path or end path have N")
--[ 2019.10.29.22.04.24.100.0 ]--
r 103         if(getPathEnd() == null || getPathStart() == null) throw new IllegalArgumentException("Either or both of start path or end path have NO")
--[ 2019.10.29.22.04.24.273.0 ]--
r 103         if(getPathEnd() == null || getPathStart() == null) throw new IllegalArgumentException("Either or both of start path or end path have NOT")
--[ 2019.10.29.22.04.24.600.0 ]--
r 103         if(getPathEnd() == null || getPathStart() == null) throw new IllegalArgumentException("Either or both of start path or end path have NOT ")
--[ 2019.10.29.22.04.25.141.0 ]--
r 103         if(getPathEnd() == null || getPathStart() == null) throw new IllegalArgumentException("Either or both of start path or end path have NOT b")
--[ 2019.10.29.22.04.25.292.0 ]--
r 103         if(getPathEnd() == null || getPathStart() == null) throw new IllegalArgumentException("Either or both of start path or end path have NOT be")
--[ 2019.10.29.22.04.25.918.0 ]--
r 103         if(getPathEnd() == null || getPathStart() == null) throw new IllegalArgumentException("Either or both of start path or end path have NOT bee")
--[ 2019.10.29.22.04.26.001.0 ]--
r 103         if(getPathEnd() == null || getPathStart() == null) throw new IllegalArgumentException("Either or both of start path or end path have NOT been")
--[ 2019.10.29.22.04.26.152.0 ]--
r 103         if(getPathEnd() == null || getPathStart() == null) throw new IllegalArgumentException("Either or both of start path or end path have NOT been ")
--[ 2019.10.29.22.04.26.380.0 ]--
r 103         if(getPathEnd() == null || getPathStart() == null) throw new IllegalArgumentException("Either or both of start path or end path have NOT been s")
--[ 2019.10.29.22.04.26.638.0 ]--
r 103         if(getPathEnd() == null || getPathStart() == null) throw new IllegalArgumentException("Either or both of start path or end path have NOT been se")
--[ 2019.10.29.22.04.26.874.0 ]--
r 103         if(getPathEnd() == null || getPathStart() == null) throw new IllegalArgumentException("Either or both of start path or end path have NOT been set")
--[ 2019.10.29.22.04.27.034.0 ]--
r 103         if(getPathEnd() == null || getPathStart() == null) throw new IllegalArgumentException("Either or both of start path or end path have NOT been set.")
--[ 2019.10.29.22.04.30.449.0 ]--
r 103         if(getPathEnd() == null || getPathStart() == null) throw new IllegalArgumentException("Either or both of start path or end path have NOT been set.");
--[ 2019.10.29.22.05.42.027.0 ]--
+ 73         
--[ 2019.10.29.22.05.42.212.0 ]--
r 73         if(loc == null) throw new IllegalArgumentException("The location is null.");
--[ 2019.10.29.22.05.47.276.0 ]--
r 73         if(loc == nul) throw new IllegalArgumentException("The location is null.");
--[ 2019.10.29.22.05.47.452.0 ]--
r 73         if(loc == nu) throw new IllegalArgumentException("The location is null.");
--[ 2019.10.29.22.05.47.621.0 ]--
r 73         if(loc == n) throw new IllegalArgumentException("The location is null.");
--[ 2019.10.29.22.05.47.777.0 ]--
r 73         if(loc == ) throw new IllegalArgumentException("The location is null.");
--[ 2019.10.29.22.05.47.951.0 ]--
r 73         if(loc ==) throw new IllegalArgumentException("The location is null.");
--[ 2019.10.29.22.05.48.104.0 ]--
r 73         if(loc =) throw new IllegalArgumentException("The location is null.");
--[ 2019.10.29.22.05.48.292.0 ]--
r 73         if(loc ) throw new IllegalArgumentException("The location is null.");
--[ 2019.10.29.22.05.48.423.0 ]--
r 73         if(loc) throw new IllegalArgumentException("The location is null.");
--[ 2019.10.29.22.05.49.453.0 ]--
r 73         if(loc.) throw new IllegalArgumentException("The location is null.");
--[ 2019.10.29.22.05.49.935.0 ]--
r 73         if(loc.i) throw new IllegalArgumentException("The location is null.");
--[ 2019.10.29.22.05.50.035.0 ]--
r 73         if(loc.is) throw new IllegalArgumentException("The location is null.");
--[ 2019.10.29.22.05.51.679.0 ]--
r 73         if(loc.isInBounds) throw new IllegalArgumentException("The location is null.");
--[ 2019.10.29.22.05.51.690.0 ]--
r 73         if(loc.isInBounds()) throw new IllegalArgumentException("The location is null.");
--[ 2019.10.29.22.05.54.901.0 ]--
r 73         if(!loc.isInBounds()) throw new IllegalArgumentException("The location is null.");
--[ 2019.10.29.22.06.05.188.0 ]--
r 73         if(!loc.isInBounds() throw new IllegalArgumentException("The location is null.");
--[ 2019.10.29.22.06.05.420.0 ]--
r 73         if(!loc.isInBounds) throw new IllegalArgumentException("The location is null.");
--[ 2019.10.29.22.06.10.275.0 ]--
r 73         if(!loc.isInBound) throw new IllegalArgumentException("The location is null.");
--[ 2019.10.29.22.06.10.741.0 ]--
r 73         if(!loc.isInBoun) throw new IllegalArgumentException("The location is null.");
--[ 2019.10.29.22.06.10.770.0 ]--
r 73         if(!loc.isInBou) throw new IllegalArgumentException("The location is null.");
--[ 2019.10.29.22.06.10.810.0 ]--
r 73         if(!loc.isInBo) throw new IllegalArgumentException("The location is null.");
--[ 2019.10.29.22.06.10.838.0 ]--
r 73         if(!loc.isInB) throw new IllegalArgumentException("The location is null.");
--[ 2019.10.29.22.06.10.868.0 ]--
r 73         if(!loc.isIn) throw new IllegalArgumentException("The location is null.");
--[ 2019.10.29.22.06.10.897.0 ]--
r 73         if(!loc.isI) throw new IllegalArgumentException("The location is null.");
--[ 2019.10.29.22.06.11.290.0 ]--
r 73         if(!loc.is) throw new IllegalArgumentException("The location is null.");
--[ 2019.10.29.22.06.11.575.0 ]--
r 73         if(!loc.i) throw new IllegalArgumentException("The location is null.");
--[ 2019.10.29.22.06.11.840.0 ]--
r 73         if(!loc.) throw new IllegalArgumentException("The location is null.");
--[ 2019.10.29.22.06.39.703.0 ]--
r 73         if(!oc.) throw new IllegalArgumentException("The location is null.");
--[ 2019.10.29.22.06.41.291.0 ]--
r 73         if(oc.) throw new IllegalArgumentException("The location is null.");
--[ 2019.10.29.22.06.41.974.0 ]--
r 73         if(loc.) throw new IllegalArgumentException("The location is null.");
--[ 2019.10.29.22.06.44.637.0 ]--
r 73         if(loc.i) throw new IllegalArgumentException("The location is null.");
--[ 2019.10.29.22.06.44.855.0 ]--
r 73         if(loc.is) throw new IllegalArgumentException("The location is null.");
--[ 2019.10.29.22.06.52.444.0 ]--
r 73         if(loc.isInBounds) throw new IllegalArgumentException("The location is null.");
--[ 2019.10.29.22.06.52.456.0 ]--
r 73         if(loc.isInBounds()) throw new IllegalArgumentException("The location is null.");
--[ 2019.10.29.22.06.55.180.0 ]--
r 73         if(loc.isInBounds() ) throw new IllegalArgumentException("The location is null.");
--[ 2019.10.29.22.06.57.327.0 ]--
r 73         if(loc.isInBounds() =) throw new IllegalArgumentException("The location is null.");
--[ 2019.10.29.22.06.58.537.0 ]--
r 73         if(loc.isInBounds() ) throw new IllegalArgumentException("The location is null.");
--[ 2019.10.29.22.06.58.971.0 ]--
r 73         if(loc.isInBounds()) throw new IllegalArgumentException("The location is null.");
--[ 2019.10.29.22.07.08.730.0 ]--
r 73         if(locisInBounds()) throw new IllegalArgumentException("The location is null.");
--[ 2019.10.29.22.07.08.918.0 ]--
r 73         if(loisInBounds()) throw new IllegalArgumentException("The location is null.");
--[ 2019.10.29.22.07.09.162.0 ]--
r 73         if(lisInBounds()) throw new IllegalArgumentException("The location is null.");
--[ 2019.10.29.22.07.09.538.0 ]--
r 73         if(isInBounds()) throw new IllegalArgumentException("The location is null.");
--[ 2019.10.29.22.07.14.789.0 ]--
r 73         if(lisInBounds()) throw new IllegalArgumentException("The location is null.");
--[ 2019.10.29.22.07.15.004.0 ]--
r 73         if(loisInBounds()) throw new IllegalArgumentException("The location is null.");
--[ 2019.10.29.22.07.15.344.0 ]--
r 73         if(locisInBounds()) throw new IllegalArgumentException("The location is null.");
--[ 2019.10.29.22.07.15.772.0 ]--
r 73         if(loc.isInBounds()) throw new IllegalArgumentException("The location is null.");
--[ 2019.10.29.22.07.20.955.0 ]--
r 73         if(loc.isInBoundsisInBounds()) throw new IllegalArgumentException("The location is null.");
--[ 2019.10.29.22.07.20.979.0 ]--
r 73         if(loc.isInBounds()isInBounds()) throw new IllegalArgumentException("The location is null.");
--[ 2019.10.29.22.07.24.921.0 ]--
r 73         if(loc.isInBounds()isInBounds() throw new IllegalArgumentException("The location is null.");
--[ 2019.10.29.22.07.25.381.0 ]--
r 73         if(loc.isInBounds()isInBounds) throw new IllegalArgumentException("The location is null.");
--[ 2019.10.29.22.07.25.409.0 ]--
r 73         if(loc.isInBounds()isInBound) throw new IllegalArgumentException("The location is null.");
--[ 2019.10.29.22.07.25.441.0 ]--
r 73         if(loc.isInBounds()isInBoun) throw new IllegalArgumentException("The location is null.");
--[ 2019.10.29.22.07.25.492.0 ]--
r 73         if(loc.isInBounds()isInBou) throw new IllegalArgumentException("The location is null.");
--[ 2019.10.29.22.07.25.559.0 ]--
r 73         if(loc.isInBounds()isInB) throw new IllegalArgumentException("The location is null.");
--[ 2019.10.29.22.07.25.621.0 ]--
r 73         if(loc.isInBounds()isIn) throw new IllegalArgumentException("The location is null.");
--[ 2019.10.29.22.07.25.651.0 ]--
r 73         if(loc.isInBounds()isI) throw new IllegalArgumentException("The location is null.");
--[ 2019.10.29.22.07.25.821.0 ]--
r 73         if(loc.isInBounds()is) throw new IllegalArgumentException("The location is null.");
--[ 2019.10.29.22.07.26.107.0 ]--
r 73         if(loc.isInBounds()i) throw new IllegalArgumentException("The location is null.");
--[ 2019.10.29.22.07.26.747.0 ]--
r 73         if(loc.isInBounds()) throw new IllegalArgumentException("The location is null.");
--[ 2019.10.29.22.07.32.771.0 ]--
r 73         if(loc.isInBounds()) throw new IllegalArgumentException("The location is o.");
--[ 2019.10.29.22.07.32.917.0 ]--
r 73         if(loc.isInBounds()) throw new IllegalArgumentException("The location is ou.");
--[ 2019.10.29.22.07.33.144.0 ]--
r 73         if(loc.isInBounds()) throw new IllegalArgumentException("The location is out.");
--[ 2019.10.29.22.07.33.253.0 ]--
r 73         if(loc.isInBounds()) throw new IllegalArgumentException("The location is out .");
--[ 2019.10.29.22.07.33.498.0 ]--
r 73         if(loc.isInBounds()) throw new IllegalArgumentException("The location is out o.");
--[ 2019.10.29.22.07.33.629.0 ]--
r 73         if(loc.isInBounds()) throw new IllegalArgumentException("The location is out of.");
--[ 2019.10.29.22.07.33.762.0 ]--
r 73         if(loc.isInBounds()) throw new IllegalArgumentException("The location is out of .");
--[ 2019.10.29.22.07.35.076.0 ]--
r 73         if(loc.isInBounds()) throw new IllegalArgumentException("The location is out of b.");
--[ 2019.10.29.22.07.35.222.0 ]--
r 73         if(loc.isInBounds()) throw new IllegalArgumentException("The location is out of bo.");
--[ 2019.10.29.22.07.35.463.0 ]--
r 73         if(loc.isInBounds()) throw new IllegalArgumentException("The location is out of bou.");
--[ 2019.10.29.22.07.35.539.0 ]--
r 73         if(loc.isInBounds()) throw new IllegalArgumentException("The location is out of boun.");
--[ 2019.10.29.22.07.35.708.0 ]--
r 73         if(loc.isInBounds()) throw new IllegalArgumentException("The location is out of bound.");
--[ 2019.10.29.22.07.35.806.0 ]--
r 73         if(loc.isInBounds()) throw new IllegalArgumentException("The location is out of bounds.");
--[ 2019.10.29.22.07.41.323.0 ]--
r 73         if(!loc.isInBounds()) throw new IllegalArgumentException("The location is out of bounds.");
--[ 2019.10.29.22.07.56.507.0 ]--
+ 83         
--[ 2019.10.29.22.07.56.793.0 ]--
r 83         if(!loc.isInBounds()) throw new IllegalArgumentException("The location is out of bounds.");
--[ 2019.10.29.22.08.17.174.0 ]--
r 73         /if(!loc.isInBounds()) throw new IllegalArgumentException("The location is out of bounds.");
--[ 2019.10.29.22.08.17.321.0 ]--
r 73         //if(!loc.isInBounds()) throw new IllegalArgumentException("The location is out of bounds.");
--[ 2019.10.29.22.08.20.519.0 ]--
r 83         /if(!loc.isInBounds()) throw new IllegalArgumentException("The location is out of bounds.");
--[ 2019.10.29.22.08.20.654.0 ]--
r 83         //if(!loc.isInBounds()) throw new IllegalArgumentException("The location is out of bounds.");
--[ 2019.10.29.22.09.02.593.0 ]--
r 73         /if(!loc.isInBounds()) throw new IllegalArgumentException("The location is out of bounds.");
--[ 2019.10.29.22.09.02.768.0 ]--
r 73         if(!loc.isInBounds()) throw new IllegalArgumentException("The location is out of bounds.");
--[ 2019.10.29.22.09.06.297.0 ]--
r 73         if(!loc.isInBounds() ) throw new IllegalArgumentException("The location is out of bounds.");
--[ 2019.10.29.22.09.06.392.0 ]--
r 73         if(!loc.isInBounds() =) throw new IllegalArgumentException("The location is out of bounds.");
--[ 2019.10.29.22.09.06.524.0 ]--
r 73         if(!loc.isInBounds() ==) throw new IllegalArgumentException("The location is out of bounds.");
--[ 2019.10.29.22.09.06.692.0 ]--
r 73         if(!loc.isInBounds() == ) throw new IllegalArgumentException("The location is out of bounds.");
--[ 2019.10.29.22.09.08.532.0 ]--
r 73         if(!loc.isInBounds() == t) throw new IllegalArgumentException("The location is out of bounds.");
--[ 2019.10.29.22.09.08.876.0 ]--
r 73         if(!loc.isInBounds() == tr) throw new IllegalArgumentException("The location is out of bounds.");
--[ 2019.10.29.22.09.08.995.0 ]--
r 73         if(!loc.isInBounds() == try) throw new IllegalArgumentException("The location is out of bounds.");
--[ 2019.10.29.22.09.09.101.0 ]--
r 73         if(!loc.isInBounds() == trye) throw new IllegalArgumentException("The location is out of bounds.");
--[ 2019.10.29.22.09.09.824.0 ]--
r 73         if(!loc.isInBounds() == try) throw new IllegalArgumentException("The location is out of bounds.");
--[ 2019.10.29.22.09.09.926.0 ]--
r 73         if(!loc.isInBounds() == tr) throw new IllegalArgumentException("The location is out of bounds.");
--[ 2019.10.29.22.09.10.874.0 ]--
r 73         if(!loc.isInBounds() == tru) throw new IllegalArgumentException("The location is out of bounds.");
--[ 2019.10.29.22.09.11.108.0 ]--
r 73         if(!loc.isInBounds() == true) throw new IllegalArgumentException("The location is out of bounds.");
--[ 2019.10.29.22.09.33.622.0 ]--
r 73         if(!loc.isInBounds() == tr) throw new IllegalArgumentException("The location is out of bounds.");
--[ 2019.10.29.22.09.34.011.0 ]--
r 73         if(!loc.isInBounds() == trye) throw new IllegalArgumentException("The location is out of bounds.");
--[ 2019.10.29.22.09.34.296.0 ]--
r 73         if(!loc.isInBounds()) throw new IllegalArgumentException("The location is out of bounds.");
--[ 2019.10.29.22.09.35.421.0 ]--
r 73         //if(!loc.isInBounds()) throw new IllegalArgumentException("The location is out of bounds.");
--[ 2019.10.29.22.20.46.763.0 ]--
+ 106         
--[ 2019.10.29.22.20.46.900.0 ]--
+ 106         
--[ 2019.10.29.22.20.48.039.0 ]--
r 107         /
--[ 2019.10.29.22.20.48.167.0 ]--
r 107         //
--[ 2019.10.29.22.20.57.668.0 ]--
r 107         //s
--[ 2019.10.29.22.20.57.932.0 ]--
r 107         //st
--[ 2019.10.29.22.20.58.054.0 ]--
r 107         //sta
--[ 2019.10.29.22.20.58.195.0 ]--
r 107         //star
--[ 2019.10.29.22.20.58.329.0 ]--
r 107         //start
--[ 2019.10.29.22.20.58.508.0 ]--
r 107         //start 
--[ 2019.10.29.22.20.59.241.0 ]--
r 107         //start b
--[ 2019.10.29.22.20.59.410.0 ]--
r 107         //start bu
--[ 2019.10.29.22.20.59.862.0 ]--
r 107         //start b
--[ 2019.10.29.22.21.00.264.0 ]--
r 107         //start by
--[ 2019.10.29.22.21.00.520.0 ]--
r 107         //start by 
--[ 2019.10.29.22.21.00.791.0 ]--
r 107         //start by f
--[ 2019.10.29.22.21.00.901.0 ]--
r 107         //start by fi
--[ 2019.10.29.22.21.01.065.0 ]--
r 107         //start by fin
--[ 2019.10.29.22.21.06.546.0 ]--
r 107         //start by find
--[ 2019.10.29.22.21.06.597.0 ]--
r 107         //start by findi
--[ 2019.10.29.22.21.06.694.0 ]--
r 107         //start by findin
--[ 2019.10.29.22.21.06.830.0 ]--
r 107         //start by finding
--[ 2019.10.29.22.21.08.976.0 ]--
r 107         //start by finding 
--[ 2019.10.29.22.21.09.580.0 ]--
r 107         //start by finding a
--[ 2019.10.29.22.21.09.713.0 ]--
r 107         //start by finding a 
--[ 2019.10.29.22.21.10.731.0 ]--
r 107         //start by finding a p
--[ 2019.10.29.22.21.10.801.0 ]--
r 107         //start by finding a pa
--[ 2019.10.29.22.21.10.948.0 ]--
r 107         //start by finding a pat
--[ 2019.10.29.22.21.11.019.0 ]--
r 107         //start by finding a path
--[ 2019.10.29.22.21.11.671.0 ]--
+ 108         
--[ 2019.10.29.22.22.38.714.0 ]--
r 106 
--[ 2019.10.29.22.24.59.271.0 ]--
r 83         /if(!loc.isInBounds()) throw new IllegalArgumentException("The location is out of bounds.");
--[ 2019.10.29.22.24.59.495.0 ]--
r 83         if(!loc.isInBounds()) throw new IllegalArgumentException("The location is out of bounds.");
--[ 2019.10.29.22.25.10.746.0 ]--
r 83         if(!loc.gisInBounds()) throw new IllegalArgumentException("The location is out of bounds.");
--[ 2019.10.29.22.25.10.999.0 ]--
r 83         if(!loc.geisInBounds()) throw new IllegalArgumentException("The location is out of bounds.");
--[ 2019.10.29.22.25.11.147.0 ]--
r 83         if(!loc.getisInBounds()) throw new IllegalArgumentException("The location is out of bounds.");
--[ 2019.10.29.22.25.12.411.0 ]--
r 83         if(!loc.getIisInBounds()) throw new IllegalArgumentException("The location is out of bounds.");
--[ 2019.10.29.22.25.12.423.0 ]--
r 83         if(!loc.getI()isInBounds()) throw new IllegalArgumentException("The location is out of bounds.");
--[ 2019.10.29.22.25.13.731.0 ]--
r 83         if(!loc.getI().isInBounds()) throw new IllegalArgumentException("The location is out of bounds.");
--[ 2019.10.29.22.25.16.887.0 ]--
r 83         if(!loc.getI()isInBounds()) throw new IllegalArgumentException("The location is out of bounds.");
--[ 2019.10.29.22.25.17.283.0 ]--
r 83         if(!loc.getisInBounds()) throw new IllegalArgumentException("The location is out of bounds.");
--[ 2019.10.29.22.25.17.556.0 ]--
r 83         if(!loc.isInBounds()) throw new IllegalArgumentException("The location is out of bounds.");
--[ 2019.10.29.22.25.18.368.0 ]--
r 83         //if(!loc.isInBounds()) throw new IllegalArgumentException("The location is out of bounds.");
--[ 2019.10.29.22.25.25.834.0 ]--
+ 108         
--[ 2019.10.29.22.26.34.295.0 ]--
r 108         /
--[ 2019.10.29.22.26.34.441.0 ]--
r 108         //
--[ 2019.10.29.22.26.35.747.0 ]--
r 108         //d
--[ 2019.10.29.22.26.35.869.0 ]--
r 108         //do
--[ 2019.10.29.22.26.35.977.0 ]--
r 108         //do 
--[ 2019.10.29.22.26.36.370.0 ]--
r 108         //do I
--[ 2019.10.29.22.26.36.568.0 ]--
r 108         //do I 
--[ 2019.10.29.22.26.36.702.0 ]--
r 108         //do I s
--[ 2019.10.29.22.26.36.809.0 ]--
r 108         //do I se
--[ 2019.10.29.22.26.37.009.0 ]--
r 108         //do I set
--[ 2019.10.29.22.26.37.146.0 ]--
r 108         //do I set 
--[ 2019.10.29.22.26.37.384.0 ]--
r 108         //do I set u
--[ 2019.10.29.22.26.37.480.0 ]--
r 108         //do I set up
--[ 2019.10.29.22.26.37.642.0 ]--
r 108         //do I set up 
--[ 2019.10.29.22.26.37.771.0 ]--
r 108         //do I set up a
--[ 2019.10.29.22.26.37.871.0 ]--
r 108         //do I set up a 
--[ 2019.10.29.22.26.38.214.0 ]--
r 108         //do I set up a l
--[ 2019.10.29.22.26.38.412.0 ]--
r 108         //do I set up a li
--[ 2019.10.29.22.26.38.693.0 ]--
r 108         //do I set up a lin
--[ 2019.10.29.22.26.38.850.0 ]--
r 108         //do I set up a link
--[ 2019.10.29.22.26.38.962.0 ]--
r 108         //do I set up a linke
--[ 2019.10.29.22.26.39.168.0 ]--
r 108         //do I set up a linked
--[ 2019.10.29.22.26.39.290.0 ]--
r 108         //do I set up a linked 
--[ 2019.10.29.22.26.39.845.0 ]--
r 108         //do I set up a linked l
--[ 2019.10.29.22.26.39.997.0 ]--
r 108         //do I set up a linked li
--[ 2019.10.29.22.26.40.110.0 ]--
r 108         //do I set up a linked lis
--[ 2019.10.29.22.26.40.339.0 ]--
r 108         //do I set up a linked list
--[ 2019.10.29.22.26.40.516.0 ]--
r 108         //do I set up a linked list 
--[ 2019.10.29.22.26.40.697.0 ]--
r 108         //do I set up a linked list h
--[ 2019.10.29.22.26.40.755.0 ]--
r 108         //do I set up a linked list he
--[ 2019.10.29.22.26.40.854.0 ]--
r 108         //do I set up a linked list her
--[ 2019.10.29.22.26.41.195.0 ]--
r 108         //do I set up a linked list here
--[ 2019.10.29.22.26.41.602.0 ]--
r 108         //do I set up a linked list here?
--[ 2019.10.29.22.26.45.274.0 ]--
r 109 
--[ 2019.10.30.19.06.18.835.0 ]--
NewLogger: P04_Pathfinding
Version: 1.3
--[ 2019.10.30.19.06.18.988.0 ]--
InitTree:
/out/production/P04_Pathfinding/.donotlog
/out/production/P04_Pathfinding/algs4.jar
/out/production/P04_Pathfinding/stdlib.jar
/out/production/P04_Pathfinding/Coord.class
/out/production/P04_Pathfinding/png2emap.py
/out/production/P04_Pathfinding/Walker.class
/out/production/P04_Pathfinding/ramp.png.emap
/out/production/P04_Pathfinding/Terrain.class
/out/production/P04_Pathfinding/ramp2.png.emap
/out/production/P04_Pathfinding/ramp3.png.emap
/out/production/P04_Pathfinding/mazeAB.png.emap
/out/production/P04_Pathfinding/usa128.png.emap
/out/production/P04_Pathfinding/usa256.png.emap
/out/production/P04_Pathfinding/Pathfinder.class
/out/production/P04_Pathfinding/usa1024.png.emap
/out/production/P04_Pathfinding/maze32_0.png.emap
/out/production/P04_Pathfinding/maze32_1.png.emap
/out/production/P04_Pathfinding/maze232_0.png.emap
/out/production/P04_Pathfinding/maze320_0.png.emap
/out/production/P04_Pathfinding/mazeBrain.png.emap
/out/production/P04_Pathfinding/TerrainEditor.class
/out/production/P04_Pathfinding/Pathfinder$PFNode.class
/out/production/P04_Pathfinding/PathfinderVisualizer.class
/out/production/P04_Pathfinding/InteractivePathfinderVisualizer.class
/src/algs4.jar
/src/Coord.java
/src/stdlib.jar
/src/Walker.java
/src/Terrain.java
/src/Pathfinder.java
/src/TerrainEditor.java
/src/PathfinderVisualizer.java
/src/InteractivePathfinderVisualizer.java
/.log/history.log
/.idea/copyright/profiles_settings.xml
/.idea/libraries/algs4.xml
/.idea/libraries/stdlib.xml
/.idea/.name
/.idea/misc.xml
/.idea/modules.xml
/.idea/compiler.xml
/.idea/workspace.xml
/.idea/uiDesigner.xml
/heightmaps/.donotlog
/heightmaps/png2emap.py
/heightmaps/ramp.png.emap
/heightmaps/ramp2.png.emap
/heightmaps/ramp3.png.emap
/heightmaps/mazeAB.png.emap
/heightmaps/usa128.png.emap
/heightmaps/usa256.png.emap
/heightmaps/usa1024.png.emap
/heightmaps/maze32_0.png.emap
/heightmaps/maze32_1.png.emap
/heightmaps/maze232_0.png.emap
/heightmaps/maze320_0.png.emap
/heightmaps/mazeBrain.png.emap
/.cos265
/readme.html
/P04_Pathfinding.iml

--[ 2019.10.30.19.06.18.991.0 ]--
InitFile: /src/PathfinderVisualizer.java
/**
 * PathfinderVisualizer visualizes the terrain and found path.
 */

import java.awt.Color;
import java.awt.Font;

public class PathfinderVisualizer {

    // delay in milliseconds (controls animation speed)
    private final static int DELAY = 100;

    // color for different elevations.  must be in ascending order!
    private final static int[][] elevationColors = {
            // h    r   g   b   where h=height, r=red, g=green, b=blue
            {  0,   0,  0,  0},
            {  2,   0,  0,160},
            {  4,   0,224,224},
            { 16, 192,192,  0},
            { 64,  16,255, 16},
            {128,  32,224, 32},
            {192, 128,128,  8},
            {224, 164,164,164},
            {255, 255,255,255}
    };

    private final static Color cStart    = new Color(128, 128, 255);
    private final static Color cEnd      = new Color(255, 128, 128);
    private final static Color cSolution = new Color(255, 128, 255);
    private final static Color cSearched = new Color(128,   0, 128);

    // linearly interpolating between the corresponding rgb values
    private static Color colorLERP(float v1, int r0, int g0, int b0, int r1, int g1, int b1) {
        v1 = Math.max(0.0f, Math.min(1.0f, v1));
        float v0 = 1.0f - v1;
        int r = (int)(v0 * r0 + v1 * r1);
        int g = (int)(v0 * g0 + v1 * g1);
        int b = (int)(v0 * b0 + v1 * b1);
        return new Color(r, g, b);
    }
    private static Color colorLERP(float v1, Color c0, Color c1) {
        v1 = Math.max(0.0f, Math.min(1.0f, v1));
        float v0 = 1.0f - v1;
        int r = (int)(v0 * c0.getRed()   + v1 * c1.getRed());
        int g = (int)(v0 * c0.getGreen() + v1 * c1.getGreen());
        int b = (int)(v0 * c0.getBlue()  + v1 * c1.getBlue());
        int a = (int)(v0 * c0.getAlpha() + v1 * c1.getAlpha());
        return new Color(r, g, b, a);
    }

    // returns color for given height
    private static Color height2Color(int h) {
        h = Math.max(0, Math.min(255, h));

        int[] ec0 = elevationColors[0];  // default lower bound
        int[] ec1 = elevationColors[1];  // default upper bound

        // find upper bound while updating lower bound
        for(int i = 1; i < elevationColors.length; i++) {
            ec1 = elevationColors[i];
            if(h >= ec0[0] && h <= ec1[0]) break;
            ec0 = ec1;
        }

        int h0=ec0[0], r0=ec0[1], g0=ec0[2], b0=ec0[3];
        int h1=ec1[0], r1=ec1[1], g1=ec1[2], b1=ec1[3];
        float v1 = ((float)(h - h0)) / ((float)(h1 - h0));

        return colorLERP(v1, r0, g0, b0, r1, g1, b1);
    }

    private static void drawCircle(int i, int j, int N, double rad) {
        int c = (int)((i+0.5f) * 464.0f / N);
        int r = (int)((j+0.5f) * 464.0f / N);
        StdDraw.circle(c + 24, 464 - r + 36, rad);
    }
    public static void drawCircle(Coord loc, int N, double rad) {
        drawCircle(loc.getI(), loc.getJ(), N, rad);
    }

    private static void drawPath(Iterable<Coord> path, int N) {
        boolean first = true;
        int c0 = 0, r0 = 0;
        for (Coord loc : path) {
            int c1 = (int)((loc.getI()+0.5f) * 464.0f / N);
            int r1 = (int)((loc.getJ()+0.5f) * 464.0f / N);
            if(!first) {
                StdDraw.line(c0 + 24, 464 - r0 + 36, c1 + 24, 464 - r1 + 36);
            }
            first = false;
            c0 = c1; r0 = r1;
        }
    }

    // draw N-by-N pathfinding map
    public static void draw(Terrain terrain, Pathfinder pf, Walker walker, int N) {
        StdDraw.clear();
        StdDraw.setXscale(0, 512);
        StdDraw.setYscale(0, 512);
        StdDraw.setPenColor(StdDraw.BLACK);
        StdDraw.filledSquare(256, 256 + 12, 464 / 2);

        // draw terrain
        for(int row = 0; row < 464; row++) {
            int j = (int)((float)row/464.0f * N);
            for(int col = 0; col < 464; col++) {
                int i = (int)((float)col/464.0f * N);
                Coord loc = new Coord(i,j);
                Color c = height2Color(terrain.getHeight(loc));
                if(pf.wasSearched(loc)) {
                    c = colorLERP(0.50f, c, cSearched);
                }
                StdDraw.setPenColor(c);
                StdDraw.filledSquare(col + 24, 464 - row + 36, 1);
            }
        }

        // draw path start
        if(pf.getPathStart() != null) {
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            drawCircle(pf.getPathStart(), N, 4.0);

            StdDraw.setPenColor(cStart);
            StdDraw.setPenRadius(0.002);
            drawCircle(pf.getPathStart(), N, 4.0);
        }

        // draw path end
        if(pf.getPathEnd() != null) {
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            drawCircle(pf.getPathEnd(), N, 4.0);

            StdDraw.setPenColor(cEnd);
            StdDraw.setPenRadius(0.002);
            drawCircle(pf.getPathEnd(), N, 4.0);
        }

        // draw found path
        if(pf.foundPath()) {
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            drawPath(pf.getPathSolution(), N);

            StdDraw.setPenColor(cSolution);
            StdDraw.setPenRadius(0.002);
            drawPath(pf.getPathSolution(), N);
        }

        // draw walker
        if(walker != null) {
            Coord loc = walker.getLocation();
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            PathfinderVisualizer.drawCircle(loc, N, 2.0);

            StdDraw.setPenColor(StdDraw.WHITE);
            StdDraw.setPenRadius(0.002);
            PathfinderVisualizer.drawCircle(loc, N, 2.0);
        }

        // write status text
        StdDraw.setFont(new Font("SansSerif", Font.PLAIN, 12));
        StdDraw.setPenColor(StdDraw.BLACK);
        StdDraw.text(96, 12, "heuristic: " + pf.getHeuristic());
        if(pf.foundPath()) StdDraw.text(256, 12, "path: " + pf.getPathCost());
        else               StdDraw.text(256, 12, "no path found");
        StdDraw.text(512-96, 12, "searched: " + pf.getSearchSize() + " (" + (int)(100.0f * pf.getSearchSize() / (N*N)) + "%)");
    }
}

--[ 2019.10.30.19.06.18.993.0 ]--
InitFile: /P04_Pathfinding.iml
<?xml version="1.0" encoding="UTF-8"?>
<module type="JAVA_MODULE" version="4">
  <component name="NewModuleRootManager" inherit-compiler-output="true">
    <exclude-output />
    <content url="file://$MODULE_DIR$">
      <sourceFolder url="file://$MODULE_DIR$/src" isTestSource="false" />
      <sourceFolder url="file://$MODULE_DIR$/heightmaps" type="java-resource" />
      <excludeFolder url="file://$MODULE_DIR$/.log" />
    </content>
    <orderEntry type="inheritedJdk" />
    <orderEntry type="sourceFolder" forTests="false" />
    <orderEntry type="library" name="algs4" level="project" />
    <orderEntry type="library" name="stdlib" level="project" />
  </component>
</module>

--[ 2019.10.30.19.06.18.994.0 ]--
InitFile: /src/Coord.java
/**
 * Coordinates is an immutable type that store the tuple (i, j)
 */
public final class Coord {
    private final int i;
    private final int j;

    public Coord(int i, int j) {
        this.i = i;
        this.j = j;
    }

    public int getI() { return i; }
    public int getJ() { return j; }

    public boolean isInBounds(int minI, int minJ, int maxI, int maxJ) {
        return i >= minI && j >= minJ && i <= maxI && j <= maxJ;
    }
    public boolean isInBounds(Coord min, Coord max) {
        return i >= min.i && i <= max.i && j >= min.j && j <= max.j;
    }

    public Coord add(int addI, int addJ) {
        return new Coord(i + addI, j + addJ);
    }
    public Coord add(Coord that) { return new Coord(i + that.i, j + that.j); }

    public String toString() { return "(" + i + "," + j + ")"; }

    public boolean equals(Object o) {
        if(this == o) return true;
        if(o == null) return false;
        if(o.getClass() != this.getClass()) return false;
        Coord that = (Coord) o;
        if(this.i != that.i) return false;
        if(this.j != that.j) return false;
        return true;
    }
}

--[ 2019.10.30.19.06.18.996.0 ]--
InitFile: /src/Walker.java
import java.util.Iterator;

/**
 * Walker takes an Iterable of Coords and simulates an individual
 * walking along the path over the given Terrain
 */
public class Walker {

    // terrain: the Terrain the Walker traverses
    // path: the sequence of Coords the Walker follows
    public Walker(Terrain terrain, Iterable<Coord> path) {
    }

    // returns the Walker's current location
    public Coord getLocation() {
        return null;
    }

    // returns true if Walker has reached the end Coord (last in path)
    public boolean doneWalking() {
        return true;
    }

    // advances the Walker along path
    // byTime: how long the Walker should traverse (may be any non-negative value)
    public void advance(float byTime) {
    }

}

--[ 2019.10.30.19.06.18.997.0 ]--
InitFile: /src/TerrainEditor.java
/**
 * The following class provides some simple terrain editing functions.
 */
public class TerrainEditor {
    private static float rndRadius(float d) {
        return (float)StdRandom.uniform(-d,d);
    }

    private static float getFractalHeight(int i, int j, float dh, Terrain terrain, boolean[] isset) {
        int N = terrain.getN();
        dh = Math.max(-64, Math.min(255+64, dh));   // allow the height to go just a bit out of range
        if(!isset[i + j * N]) {
            isset[i + j * N] = true;
            terrain.setHeight(i, j, dh);
        }
        return terrain.getHeight(i,j);
    }

    private static void setFractalHeights(int i0, int j0, int i1, int j1, Terrain terrain, boolean[] isset) {
        int id = i1-i0;
        int jd = j1-j0;
        int i01 = (i0+i1)/2;
        int j01 = (j0+j1)/2;

        if(id <= 1 && jd <= 1) return;

        float h00 = getFractalHeight(i0,j0,32,terrain,isset);
        float h01 = getFractalHeight(i0,j1,32,terrain,isset);
        float h10 = getFractalHeight(i1,j0,32,terrain,isset);
        float h11 = getFractalHeight(i1,j1,32,terrain,isset);

        float d = (float)(Math.sqrt((i1-i0)*(i1-i0) + (j1-j0)*(j1-j0)) * 0.5);

        float d0001 = (h00 + h01) / 2 + rndRadius(d);
        float d0010 = (h00 + h10) / 2 + rndRadius(d);
        float d1101 = (h11 + h01) / 2 + rndRadius(d);
        float d1110 = (h11 + h10) / 2 + rndRadius(d);

        float h0001 = getFractalHeight(i0, j01, d0001, terrain,isset);
        float h0010 = getFractalHeight(i01, j0, d0010, terrain,isset);
        float h1101 = getFractalHeight(i01, j1, d1101, terrain,isset);
        float h1110 = getFractalHeight(i1, j01, d1110, terrain,isset);

        float dm = (float)((h0001 + h0010 + h1101 + h1110) / 4.0);
        float hm = getFractalHeight(i01, j01, dm, terrain,isset);

        if(id > 1 && jd > 1) {
            setFractalHeights(i0, j0, i01, j01, terrain, isset);
            setFractalHeights(i01, j0, i1, j01, terrain, isset);
            setFractalHeights(i0, j01, i01, j1, terrain, isset);
            setFractalHeights(i01, j01, i1, j1, terrain, isset);
        } else if(jd > 1) {
            setFractalHeights(i0, j0, i1, j01, terrain, isset);
            setFractalHeights(i0, j01, i1, j1, terrain, isset);
        } else {
            setFractalHeights(i0, j0, i01, j1, terrain, isset);
            setFractalHeights(i01, j0, i1, j1, terrain, isset);
        }
    }

    public static void setFractalHeights(Terrain terrain) {
        int N = terrain.getN();
        boolean[] isset = new boolean[N*N];
        setFractalHeights(0, 0, N - 1, N - 1, terrain, isset);
    }

    public static void smoothHeights(Terrain terrain) {
        int N = terrain.getN();
        int radius = (int)Math.ceil(Math.sqrt(N*N/2.0f));
        smoothHeights(N/2, N/2, radius, false, terrain);
    }

    public static void smoothHeights(int ic, int jc, int radius, boolean fallOff, Terrain terrain) {
        final int N = terrain.getN();
        final int w = 2*radius+1;
        float[] s = new float[w*w];
        for(int ia = -radius; ia <= radius; ia++) {
            int i = ic + ia;
            if(i < 0 || i >= N) continue;
            for(int ja = -radius; ja <= radius; ja++) {
                int j = jc + ja;
                if(j < 0 || j >= N) continue;
                int sidx = (ia+radius) + (ja+radius)*w;

                float m = computeEffect(i, j, ic, jc, radius, fallOff, N);
                if(m <= 0.0000001) {
                    s[sidx] = terrain.getHeight(i,j);
                    continue;
                }
                float h = 0;
                int c = 0;
                if(i > 0 && j > 0) {
                    h += terrain.getHeight(i-1,j-1);
                    c += 1;
                }
                if(i < N-1 && j > 0) {
                    h += terrain.getHeight(i+1,j-1);
                    c += 1;
                }
                if(i > 0 && j < N-1) {
                    h += terrain.getHeight(i-1,j+1);
                    c += 1;
                }
                if(i < N-1 && j < N-1) {
                    h += terrain.getHeight(i+1,j+1);
                    c += 1;
                }
                if(i > 0) {
                    h += terrain.getHeight(i-1,j);
                    c += 1;
                }
                if(j > 0) {
                    h += terrain.getHeight(i,j-1);
                    c += 1;
                }
                if(i < N-1) {
                    h += terrain.getHeight(i+1,j);
                    c += 1;
                }
                if(j < N-1) {
                    h += terrain.getHeight(i,j+1);
                    c += 1;
                }
                s[sidx] = (1-m) * terrain.getHeight(i,j) + m * h / c;
            }
        }
        for(int ia = -radius; ia <= radius; ia++) {
            int i = ic + ia;
            if(i < 0 || i >= N) continue;
            for(int ja = -radius; ja <= radius; ja++) {
                int j = jc + ja;
                if(j < 0 || j >= N) continue;
                int sidx = (ia+radius) + (ja+radius)*w;
                terrain.setHeight(i, j, s[sidx]);
            }
        }
    }

    public static void clampHeights(Terrain terrain) {
        int N = terrain.getN();
        for(int i = 0; i < N; i++) {
            for(int j = 0; j < N; j++) {
                terrain.setHeight(i, j, Math.max(0, Math.min(255, terrain.getHeight(i, j))));
            }
        }
    }

    private static float computeEffect(int i, int j, int ic, int jc, int radius, boolean fallOff, int N) {
        if(i < 0 || j < 0 || i >= N || j >= N) return 0;
        if(!fallOff) return 1;
        int d2 = (ic-i)*(ic-i)+(jc-j)*(jc-j);
        if(d2 > radius*radius) return 0;
        return ((float)radius - (float)Math.sqrt(d2)) / (float)radius;
    }

    public static void addHeight(int i, int j, int radius, float add, Terrain terrain) {
        final int N = terrain.getN();
        for(int ja = -radius; ja <= radius; ja++) {
            int r = j + ja;
            if(r < 0 || r >= N) continue;
            for(int ia = -radius; ia <= radius; ia++) {
                int c = i + ia;
                if(c < 0 || c >= N) continue;
                float v = add * computeEffect(c, r, i, j, radius, true, N);
                float h = terrain.getHeight(c, r) + v;
                h = Math.max(0, Math.min(255, h));
                terrain.setHeight(c, r, h);
            }
        }
    }
}

--[ 2019.10.30.19.06.18.999.0 ]--
InitFile: /src/Terrain.java
import java.lang.IndexOutOfBoundsException;

/**
 * Terrain stores elevations for map and computes distance and
 * cost in traversing the terrain.
 */

public class Terrain {
    private int N;
    private int[][] heights;

    public Terrain(int N) {
        this.N = N;
        this.heights = new int[N][N];
    }

    public Terrain(int[][] heights) {
        this.N = heights.length;
        this.heights = heights;
    }

    public Terrain(String emapfile) {
        In in = new In(emapfile);
        this.N = in.readInt();
        this.heights = new int[N][N];
        for (int j = 0; j < N; j++) {
            for (int i = 0; i < N; i++) {
                this.heights[i][j] = in.readInt();
            }
        }
    }

    public int getN() {
        return N;
    }

    public void setHeight(int i, int j, int h) {
        if(i < 0 || j < 0 || i >= N || j >= N)
            throw new IndexOutOfBoundsException("i and j must be in [0,N)");
        heights[i][j] = h;
    }
    public void setHeight(int i, int j, float h) {
        setHeight(i, j, (int) h);
    }
    public void setHeight(Coord loc, int h) {
        setHeight(loc.getI(), loc.getJ(), h);
    }
    public void setHeight(Coord loc, float h) {
        setHeight(loc.getI(), loc.getJ(), h);
    }

    public int getHeight(int i, int j) {
        if(i < 0 || j < 0 || i >= N || j >= N)
            throw new IndexOutOfBoundsException("i and j must be in [0,N)");
        return heights[i][j];
    }
    public int getHeight(Coord loc) {
        return getHeight(loc.getI(), loc.getJ());
    }

    // computes distance between (i0,j0) and (i1,j1) as the crow flies
    public float computeDistance(int i0, int j0, int i1, int j1) {
        return (float)Math.sqrt((i0 - i1) * (i0 - i1) + (j0 - j1) * (j0 - j1));
    }
    public float computeDistance(Coord c0, Coord c1) {
        return computeDistance(c0.getI(), c0.getJ(), c1.getI(), c1.getJ());
    }

    public float computeTravelCost(int i0, int j0, int i1, int j1) {
        float h0 = getHeight(i0, j0), h1 = getHeight(i1, j1);
        float climb = (float)Math.pow(Math.abs(h0 - h1) * 1000.0, 1.5);
        float dist = computeDistance(i0,j0, i1,j1);
        return (1.0f + climb) * dist;
    }
    public float computeTravelCost(Coord c0, Coord c1) {
        return computeTravelCost(c0.getI(), c0.getJ(), c1.getI(), c1.getJ());
    }
    public float computeTravelCost(Iterable<Coord> cs) {
        Coord c0 = null;
        float cost = 0.0f;
        for(Coord c1 : cs) {
            if(c0 != null) cost += computeTravelCost(c0, c1);
            c0 = c1;
        }
        return cost;
    }
}

--[ 2019.10.30.19.06.19.000.0 ]--
InitFile: /src/InteractivePathfinderVisualizer.java
import java.awt.event.KeyEvent;

/**
 * InteractivePathfinderVisualizer visualizes the terrain and the computed
 * path and allows the user to change parameters of the Pathfinder.  Below
 * is a list of commands and what they do.  Note: some of the commands
 * modify the properties of the path finder and some modify the terrain.
 *
 * Command        Action                                      Terrain
 * C              clear path
 * space          recompute path
 * S/E            set start/end location to mouse
 * left/right     halve/double path search heuristic value
 * 0/1            set path search heuristic to 0 or 1
 * W              start a walker to show the path
 * R              randomly generate a new terrain                *
 * M              smooths terrain under mouse                    *
 * shift+M        smooths all terrain                            *
 * up/down        increase/decrease terrain under mouse          *
 */

public class InteractivePathfinderVisualizer {
    private final static int DELAY = 10;

    // sets how many redraws it should take for the walker to reach its destination
    private final static float STEPS_TO_WALK = 100.0f;

    // for convenience, here are the emap files that are located under heightmaps/ folder
    // the python script in that folder converts png files to emap. \
    // you can use it to create your own maps to test your code
    private final static String[] emaps = {
            "maze32_0.png.emap",    // 0   (32x32 maze)
            "maze32_1.png.emap",    // 1   (another 32x32 maze)
            "maze232_0.png.emap",   // 2   (232x232 maze)
            "maze320_0.png.emap",   // 3   (same as maze32_0, only scaled up by 10x)
            "mazeAB.png.emap",      // 4   (a maze from a site no longer online :( )
            "mazeBrain.png.emap",   // 5   (...)
            "ramp.png.emap",        // 6   (some tests)
            "ramp2.png.emap",       // 7   (...)
            "ramp3.png.emap",       // 8   (...)
            "usa128.png.emap",      // 9   (elevation map of USA from https://bananas.openttd.org/en/heightmap/)
            "usa256.png.emap",      // 10  (same as usa128, only higher resolution)
            "usa1024.png.emap",     // 11  (same as usa128, only higher resolution
    };

    private final static String emapFilename = emaps[2];        // change index to load a different elevation map



    public static void main(String[] args) {
        Terrain terrain = new Terrain(emapFilename);
        Pathfinder pf = new Pathfinder(terrain);
        int N = terrain.getN();

        StdDraw.show(0);

        // set default starting and ending locations
        pf.setPathStart(new Coord(1, 1));
        pf.setPathEnd(new Coord(N-3, N-3));

        // find a path
        pf.computePath();

        PathfinderVisualizer.draw(terrain, pf, null, N);
        StdDraw.show(DELAY);

        // prevent repeated applications
        boolean keyboardR = false;
        boolean keyboardM = false;

        Walker walker = null;

        while(true) {
            boolean recompute = false;
            boolean redraw = false;

            // mouse location on map
            int mouseI = (int) ((StdDraw.mouseX()-24) / 464 * N);
            int mouseJ = (int) ((464 - (StdDraw.mouseY()-36)) / 464 * N);
            boolean isMouseOnMap = (mouseI >=0 && mouseI < N && mouseJ >= 0 && mouseJ < N);

            if(StdDraw.isKeyPressed(KeyEvent.VK_LEFT) || StdDraw.isKeyPressed(KeyEvent.VK_RIGHT)) {
                boolean keyboardLeft = StdDraw.isKeyPressed(KeyEvent.VK_LEFT);
                float m = keyboardLeft ? 0.5f : 2.0f;
                float h = pf.getHeuristic() * m;
                h = Math.max(1.0f/1024.0f, Math.min(1048576.0f, h));
                pf.setHeuristic(h);
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_0) || StdDraw.isKeyPressed(KeyEvent.VK_1)) {
                boolean keyboard0 = StdDraw.isKeyPressed(KeyEvent.VK_0);
                float h = keyboard0 ? 0 : 1;
                pf.setHeuristic(h);
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_C)) {
                pf.resetPath();
                walker = null;
                redraw = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_R) && !keyboardR) {
                TerrainEditor.setFractalHeights(terrain);
                TerrainEditor.clampHeights(terrain);
                recompute = true;
            }
            keyboardR = StdDraw.isKeyPressed(KeyEvent.VK_R);

            if(StdDraw.isKeyPressed(KeyEvent.VK_M)) {
                if(StdDraw.isKeyPressed(KeyEvent.VK_SHIFT)) {
                    if(!keyboardM) {
                        TerrainEditor.smoothHeights(terrain);
                        recompute = true;
                    }
                } else {
                    TerrainEditor.smoothHeights(mouseI, mouseJ, N / 20, true, terrain);
                    recompute = true;
                }
            }
            keyboardM = StdDraw.isKeyPressed(KeyEvent.VK_M);

            if(StdDraw.isKeyPressed(KeyEvent.VK_SPACE)) {
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_UP) || StdDraw.isKeyPressed(KeyEvent.VK_DOWN)) {
                boolean keyboardUp = StdDraw.isKeyPressed(KeyEvent.VK_UP);
                float add = keyboardUp ? 8.0f : -8.0f;
                TerrainEditor.addHeight(mouseI, mouseJ, N / 20, add, terrain);
                recompute = true;
            }

            if(isMouseOnMap && StdDraw.isKeyPressed(KeyEvent.VK_S)) {
                pf.setPathStart(new Coord(mouseI, mouseJ));
                recompute = true;
            }

            if(isMouseOnMap && StdDraw.isKeyPressed(KeyEvent.VK_E)) {
                pf.setPathEnd(new Coord(mouseI, mouseJ));
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_W)) {
                Iterable<Coord> path = pf.getPathSolution();
                if(path != null) {
                    walker = new Walker(terrain, pf.getPathSolution());
                }
            }

            if(walker != null) {
                if(walker.doneWalking()) {
                    walker = null;
                } else {
                    walker.advance(pf.getPathCost() / STEPS_TO_WALK);
                }
                redraw = true;
            }

            if(recompute) {
                walker = null;
                pf.resetPath();
                if(pf.getPathStart() != null && pf.getPathEnd() != null) {
                    pf.computePath();
                }
                redraw = true;
            }

            if(redraw) {
                PathfinderVisualizer.draw(terrain, pf, walker, N);
                StdDraw.show(DELAY);
            } else {
                try {
                    Thread.sleep(10);
                } catch (InterruptedException e) {
                    /* do nothing */
                }
            }
        }
    }
}

--[ 2019.10.30.19.06.19.002.0 ]--
InitFile: /src/Pathfinder.java
import java.lang.IndexOutOfBoundsException;
import java.lang.IllegalArgumentException;

/**
 * Pathfinder uses A* search to find a near optimal path
 * between to locations with given terrain.
 */

public class Pathfinder {
    private Coord end;
    private Coord start;
    private Terrain terrain;
    private float heur;
    private boolean pathFound = false;  //implement in compute path, set to true when found
    private int searchSize;
    private int N = getN(); //what do I do about this?
    private int board[Terrain.getN()][N];

    /**
     * PFNode will be the key for MinPQ (used in computePath())
     */
    private class PFNode implements Comparable<PFNode> {
        private boolean isUsed;
        private boolean invalid;
        // loc: the location of the PFNode
        // fromNode: how did we get here? (linked list back to start)
        public PFNode(Coord loc, PFNode fromNode) { }

        // compares this with that, used to find minimum cost PFNode
        public int compareTo(PFNode that) {
            //return PFNode.loc.compareTo(that); //help
            return 0;
        }

        // returns the cost to travel from starting point to this
        // via the fromNode chain
        public float getCost(float heuristic) {
            return 0;
        }

        // returns if this PFNode is not marked invalid
        public boolean isValid() {
            return invalid;
        }

        // marks the PFNode as invalid
        public void invalidate() {
            invalid = true;
        }

        // returns if the PFNode is marked as used
        public boolean isUsed() {
            return isUsed;
        }

        // marks the PFNode as used
        public void use() {
            isUsed = true;
        }

        // returns an Iterable of PFNodes that surround this
        public Iterable<PFNode> neighbors() {
            Stack<PFNode> s = new Stack<>();
            s.push(new PFNode(null, null));
            return s;
        }
    }

    public Pathfinder(Terrain terrain) {
        this.terrain = terrain;
    }

    public void setPathStart(Coord loc) {
        if(loc == null) throw new IllegalArgumentException("The location is null.");
        //if(!loc.isInBounds()) throw new IllegalArgumentException("The location is out of bounds.");
        start = loc;
    }

    public Coord getPathStart() {
        return start;
    }

    public void setPathEnd(Coord loc) {
        if(loc == null) throw new IllegalArgumentException("The location is null.");
        //if(!loc.isInBounds()) throw new IllegalArgumentException("The location is out of bounds.");
        end = loc;
    }

    public Coord getPathEnd() {
        return end;
    }

    public void setHeuristic(float v) { // is this correct?
        heur = v;
    }

    public float getHeuristic() {
        return heur;
    }

    public void resetPath() {
    }

    public void computePath() {
        //start doing all the work of finding the shortest path
        //looking at the terrain to see its size, cost, etc.
        if(getPathEnd() == null || getPathStart() == null) throw new IllegalArgumentException("Either or both of start path or end path have NOT been set.");

        //start by finding a path
        MinPQ<PFNode> pq = new MinPQ<>();

        PFNode s = new PFNode(getPathStart(), null);
        board[getPathStart().i][getPathStart().j] = s;
        pq.insert(s);



        // later on put all the items from your fastest linked list into a stack to be read by the PathfinderVisualizer

    }

    public boolean foundPath() {
        return pathFound;
    }  //implement in compute path

    public float getPathCost() {
        return 0;
    }

    public int getSearchSize() {
        return searchSize;
    } //implement in compute path

    public Iterable<Coord> getPathSolution() {
        return null;
    }

    public boolean wasSearched(Coord loc) {
        return false;
    }

}

--[ 2019.10.30.19.06.19.004.0 ]--
InitFile: /.cos265


--[ 2019.10.30.19.07.18.866.0 ]--
:/src/Pathfinder.java
r 113         board[s.i][getPathStart().j] = s;
--[ 2019.10.30.19.07.22.773.0 ]--
r 113         board[s.i][s.j] = s;
--[ 2019.10.30.19.07.31.615.0 ]--
r 113         board[s.i][getPathStart().j] = s;
--[ 2019.10.30.19.07.32.428.0 ]--
r 113         board[getPathStart().i][getPathStart().j] = s;
--[ 2019.10.30.19.11.17.658.0 ]--
r 17     private int board[TerraingetN()][N];
--[ 2019.10.30.19.11.19.054.0 ]--
r 17     private int board[Terrain-getN()][N];
--[ 2019.10.30.19.11.20.851.0 ]--
r 17     private int board[Terrain->getN()][N];
--[ 2019.10.30.19.11.33.632.0 ]--
r 17     private int board[Terrain-getN()][N];
--[ 2019.10.30.19.11.33.839.0 ]--
r 17     private int board[TerraingetN()][N];
--[ 2019.10.30.19.11.35.695.0 ]--
r 17     private int board[Terrain.getN()][N];
--[ 2019.10.30.19.11.48.126.0 ]--
r 17     private int board[()][N];
--[ 2019.10.30.19.11.53.108.0 ]--
r 16     private int N = Terrain.getNgetN(); //what do I do about this?
--[ 2019.10.30.19.11.55.474.0 ]--
r 16     private int N = Terrain.getgetN(); //what do I do about this?
--[ 2019.10.30.19.11.55.690.0 ]--
r 16     private int N = Terrain.gegetN(); //what do I do about this?
--[ 2019.10.30.19.11.55.992.0 ]--
r 16     private int N = Terrain.ggetN(); //what do I do about this?
--[ 2019.10.30.19.11.56.256.0 ]--
r 16     private int N = Terrain.getN(); //what do I do about this?
--[ 2019.10.30.19.12.12.304.0 ]--
r 16     private int N = errain.getN(); //what do I do about this?
--[ 2019.10.30.19.12.12.868.0 ]--
r 16     private int N = terrain.getN(); //what do I do about this?
--[ 2019.10.30.19.13.36.699.0 ]--
r 9 publicclass Pathfinder {
--[ 2019.10.30.19.13.36.876.0 ]--
r 9 publiclass Pathfinder {
--[ 2019.10.30.19.13.37.053.0 ]--
r 9 publclass Pathfinder {
--[ 2019.10.30.19.13.37.216.0 ]--
r 9 pubclass Pathfinder {
--[ 2019.10.30.19.13.37.473.0 ]--
r 9 puclass Pathfinder {
--[ 2019.10.30.19.13.37.739.0 ]--
r 9 pclass Pathfinder {
--[ 2019.10.30.19.13.38.007.0 ]--
r 9 class Pathfinder {
--[ 2019.10.30.19.13.48.166.0 ]--
r 9 public class Pathfinder {
--[ 2019.10.30.19.14.07.817.0 ]--
r 17     private int board[(][N];
--[ 2019.10.30.19.14.08.101.0 ]--
r 17     private int board[][N];
--[ 2019.10.30.19.14.10.490.0 ]--
r 17     private int board[N][N];
--[ 2019.10.30.19.14.28.711.0 ]--
r 16     private int N = terrain.getN(; //what do I do about this?
--[ 2019.10.30.19.14.29.065.0 ]--
r 16     private int N = terrain.getN; //what do I do about this?
--[ 2019.10.30.19.14.32.119.0 ]--
r 16     private int N = terrain.getN(); //what do I do about this?
--[ 2019.10.30.19.16.58.871.0 ]--
r 16     /private int N = terrain.getN(); //what do I do about this?
--[ 2019.10.30.19.16.59.006.0 ]--
r 16     //private int N = terrain.getN(); //what do I do about this?
--[ 2019.10.30.19.17.22.354.0 ]--
r 16     /private int N = terrain.getN(); //what do I do about this?
--[ 2019.10.30.19.17.22.515.0 ]--
r 16     private int N = terrain.getN(); //what do I do about this?
--[ 2019.10.30.19.17.35.922.0 ]--
- 16
r 16 
--[ 2019.10.30.19.17.37.152.0 ]--
- 16
--[ 2019.10.30.19.17.45.466.0 ]--
+ 103         
--[ 2019.10.30.19.17.45.849.0 ]--
+ 103             private int N = terrain.getN(); //what do I do about this?
r 104     private int board[N][N];
--[ 2019.10.30.19.17.45.951.0 ]--
r 103         private int N = terrain.getN(); //what do I do about this?
r 104         private int board[N][N];
--[ 2019.10.30.19.17.50.409.0 ]--
r 103         privateint N = terrain.getN(); //what do I do about this?
--[ 2019.10.30.19.17.50.549.0 ]--
r 103         privatint N = terrain.getN(); //what do I do about this?
--[ 2019.10.30.19.17.50.688.0 ]--
r 103         privaint N = terrain.getN(); //what do I do about this?
--[ 2019.10.30.19.17.50.844.0 ]--
r 103         privint N = terrain.getN(); //what do I do about this?
--[ 2019.10.30.19.17.50.974.0 ]--
r 103         priint N = terrain.getN(); //what do I do about this?
--[ 2019.10.30.19.17.51.121.0 ]--
r 103         print N = terrain.getN(); //what do I do about this?
--[ 2019.10.30.19.17.51.260.0 ]--
r 103         pint N = terrain.getN(); //what do I do about this?
--[ 2019.10.30.19.17.52.268.0 ]--
r 103         int N = terrain.getN(); //what do I do about this?
--[ 2019.10.30.19.17.55.105.0 ]--
r 104         privateint board[N][N];
--[ 2019.10.30.19.17.55.226.0 ]--
r 104         privatint board[N][N];
--[ 2019.10.30.19.17.55.376.0 ]--
r 104         privaint board[N][N];
--[ 2019.10.30.19.17.55.542.0 ]--
r 104         privint board[N][N];
--[ 2019.10.30.19.17.55.662.0 ]--
r 104         priint board[N][N];
--[ 2019.10.30.19.17.55.815.0 ]--
r 104         print board[N][N];
--[ 2019.10.30.19.17.56.135.0 ]--
r 104         pint board[N][N];
--[ 2019.10.30.19.17.56.284.0 ]--
r 104         int board[N][N];
--[ 2019.10.30.19.18.12.049.0 ]--
r 104 
--[ 2019.10.30.19.18.13.077.0 ]--
- 104
--[ 2019.10.30.19.18.18.720.0 ]--
+ 16     
--[ 2019.10.30.19.18.19.011.0 ]--
r 16             int board[N][N];
--[ 2019.10.30.19.18.19.118.0 ]--
r 16     int board[N][N];
--[ 2019.10.30.19.18.26.159.0 ]--
r 16     int board[][N];
--[ 2019.10.30.19.18.28.570.0 ]--
r 16     int board[][];
--[ 2019.10.30.19.18.32.540.0 ]--
r 16     pint board[][];
--[ 2019.10.30.19.18.32.882.0 ]--
r 16     print board[][];
--[ 2019.10.30.19.18.33.030.0 ]--
r 16     priint board[][];
--[ 2019.10.30.19.18.33.290.0 ]--
r 16     privint board[][];
--[ 2019.10.30.19.18.33.416.0 ]--
r 16     privaint board[][];
--[ 2019.10.30.19.18.33.640.0 ]--
r 16     privatint board[][];
--[ 2019.10.30.19.18.33.755.0 ]--
r 16     privateint board[][];
--[ 2019.10.30.19.18.33.950.0 ]--
r 16     private int board[][];
--[ 2019.10.30.19.18.41.293.0 ]--
r 16     private int[] board[][];
--[ 2019.10.30.19.18.41.502.0 ]--
r 16     private int[][] board[][];
--[ 2019.10.30.19.18.43.822.0 ]--
r 16     private int[][] board[][;
--[ 2019.10.30.19.18.43.929.0 ]--
r 16     private int[][] board[];
--[ 2019.10.30.19.18.44.070.0 ]--
r 16     private int[][] board[;
--[ 2019.10.30.19.18.44.229.0 ]--
r 16     private int[][] board;
--[ 2019.10.30.19.19.29.682.0 ]--
+ 105         
--[ 2019.10.30.19.19.32.267.0 ]--
r 105                 int board[N][N];
--[ 2019.10.30.19.19.32.354.0 ]--
r 105         int board[N][N];
--[ 2019.10.30.19.19.49.083.0 ]--
r 105         intboard[N][N];
--[ 2019.10.30.19.19.49.203.0 ]--
r 105         inboard[N][N];
--[ 2019.10.30.19.19.49.602.0 ]--
r 105         iboard[N][N];
--[ 2019.10.30.19.19.49.917.0 ]--
r 105         board[N][N];
--[ 2019.10.30.19.19.52.703.0 ]--
r 105         board[N][];
--[ 2019.10.30.19.19.54.651.0 ]--
r 105         board[][];
--[ 2019.10.30.19.19.57.256.0 ]--
r 105         board[[];
--[ 2019.10.30.19.19.57.488.0 ]--
r 105         board[];
--[ 2019.10.30.19.19.57.787.0 ]--
r 105         board[;
--[ 2019.10.30.19.19.59.197.0 ]--
r 105         board;
--[ 2019.10.30.19.20.00.672.0 ]--
r 105         board ;
--[ 2019.10.30.19.20.00.923.0 ]--
r 105         board =;
--[ 2019.10.30.19.20.01.546.0 ]--
r 105         board = ;
--[ 2019.10.30.19.20.02.724.0 ]--
r 105         board = n;
--[ 2019.10.30.19.20.02.808.0 ]--
r 105         board = ne;
--[ 2019.10.30.19.20.02.892.0 ]--
r 105         board = new;
--[ 2019.10.30.19.20.03.115.0 ]--
r 105         board = new ;
--[ 2019.10.30.19.20.03.768.0 ]--
r 105         board = new i;
--[ 2019.10.30.19.20.03.904.0 ]--
r 105         board = new in;
--[ 2019.10.30.19.20.04.947.0 ]--
r 105         board = new int;
--[ 2019.10.30.19.20.05.116.0 ]--
r 105         board = new int ;
--[ 2019.10.30.19.20.05.380.0 ]--
r 105         board = new int b;
--[ 2019.10.30.19.20.05.631.0 ]--
r 105         board = new int bo;
--[ 2019.10.30.19.20.06.541.0 ]--
r 105         board = new int boa;
--[ 2019.10.30.19.20.08.139.0 ]--
r 105         board = new int bo;
--[ 2019.10.30.19.20.08.323.0 ]--
r 105         board = new int b;
--[ 2019.10.30.19.20.09.208.0 ]--
r 105         board = new int ;
--[ 2019.10.30.19.20.09.367.0 ]--
r 105         board = new int;
--[ 2019.10.30.19.20.10.647.0 ]--
r 105         board = new int[];
--[ 2019.10.30.19.20.11.037.0 ]--
r 105         board = new int[][];
--[ 2019.10.30.19.20.14.588.0 ]--
r 105         board = new int[N][];
--[ 2019.10.30.19.20.16.856.0 ]--
r 105         board = new int[N][N];
--[ 2019.10.30.19.21.26.210.0 ]--
r 114         board[getPathStart().][getPathStart().j] = s;
--[ 2019.10.30.19.21.27.285.0 ]--
r 114         board[getPathStart().g][getPathStart().j] = s;
--[ 2019.10.30.19.21.27.395.0 ]--
r 114         board[getPathStart().ge][getPathStart().j] = s;
--[ 2019.10.30.19.21.27.586.0 ]--
r 114         board[getPathStart().get][getPathStart().j] = s;
--[ 2019.10.30.19.21.28.888.0 ]--
r 114         board[getPathStart().getI][getPathStart().j] = s;
--[ 2019.10.30.19.21.28.909.0 ]--
r 114         board[getPathStart().getI()][getPathStart().j] = s;
--[ 2019.10.30.19.21.32.225.0 ]--
r 114         board[getPathStart().getI()][getPathStart().] = s;
--[ 2019.10.30.19.21.32.576.0 ]--
r 114         board[getPathStart().getI()][getPathStart().g] = s;
--[ 2019.10.30.19.21.32.764.0 ]--
r 114         board[getPathStart().getI()][getPathStart().ge] = s;
--[ 2019.10.30.19.21.32.874.0 ]--
r 114         board[getPathStart().getI()][getPathStart().get] = s;
--[ 2019.10.30.19.21.34.523.0 ]--
r 114         board[getPathStart().getI()][getPathStart().getJ] = s;
--[ 2019.10.30.19.21.34.535.0 ]--
r 114         board[getPathStart().getI()][getPathStart().getJ()] = s;
--[ 2019.10.30.19.22.07.384.0 ]--
r 105         board = new P[N][N];
--[ 2019.10.30.19.22.07.973.0 ]--
r 105         board = new PF[N][N];
--[ 2019.10.30.19.22.08.675.0 ]--
r 105         board = new PFNode[N][N];
--[ 2019.10.30.19.22.16.828.0 ]--
r 16     private P[][] board;
--[ 2019.10.30.19.22.17.165.0 ]--
r 16     private PF[][] board;
--[ 2019.10.30.19.22.18.836.0 ]--
r 16     private PFNode[][] board;
--[ 2019.10.30.19.22.49.161.0 ]--
r 107 
--[ 2019.10.30.19.22.49.338.0 ]--
- 107
--[ 2019.10.30.19.22.53.004.0 ]--
r 106 
--[ 2019.10.30.19.22.55.853.0 ]--
- 104
r 104 
--[ 2019.10.30.19.22.57.534.0 ]--
- 104
r 104         
--[ 2019.10.30.19.22.58.266.0 ]--
- 104
--[ 2019.10.30.19.23.00.938.0 ]--
+ 105         
--[ 2019.10.30.19.23.01.341.0 ]--
+ 105         
--[ 2019.10.30.19.23.04.734.0 ]--
- 105
--[ 2019.10.30.19.23.05.104.0 ]--
- 105
--[ 2019.10.30.19.23.05.846.0 ]--
+ 104         
--[ 2019.10.30.19.23.06.288.0 ]--
+ 104 
r 105 
--[ 2019.10.30.19.23.07.101.0 ]--
+ 104         int N = terrain.getN(); //what do I do about this?
r 105         board = new PFNode[N][N];
--[ 2019.10.30.19.23.11.216.0 ]--
- 104
r 104 
--[ 2019.10.30.19.23.12.561.0 ]--
- 104
r 104         
--[ 2019.10.30.19.23.12.736.0 ]--
- 104
--[ 2019.10.30.19.23.15.994.0 ]--
+ 106         
--[ 2019.10.30.19.23.16.326.0 ]--
+ 106                 int N = terrain.getN(); //what do I do about this?
r 107         board = new PFNode[N][N];
--[ 2019.10.30.19.23.16.446.0 ]--
r 106         int N = terrain.getN(); //what do I do about this?
--[ 2019.10.30.19.23.21.279.0 ]--
r 108 
--[ 2019.10.30.19.23.21.823.0 ]--
- 108
--[ 2019.10.30.19.23.24.618.0 ]--
r 106         int N = terrain.getN(); 
--[ 2019.10.30.19.23.25.095.0 ]--
r 106         int N = terrain.getN();
--[ 2019.10.30.19.25.36.844.0 ]--
+ 106         
--[ 2019.10.30.19.25.37.052.0 ]--
r 106         /
--[ 2019.10.30.19.25.37.187.0 ]--
r 106         //
--[ 2019.10.30.19.25.37.876.0 ]--
r 106         //s
--[ 2019.10.30.19.25.38.050.0 ]--
r 106         //se
--[ 2019.10.30.19.25.38.237.0 ]--
r 106         //set
--[ 2019.10.30.19.25.38.318.0 ]--
r 106         //set 
--[ 2019.10.30.19.25.38.485.0 ]--
r 106         //set u
--[ 2019.10.30.19.25.38.636.0 ]--
r 106         //set up
--[ 2019.10.30.19.25.38.734.0 ]--
r 106         //set up 
--[ 2019.10.30.19.25.42.125.0 ]--
r 106         //set up l
--[ 2019.10.30.19.25.42.402.0 ]--
r 106         //set up lo
--[ 2019.10.30.19.25.42.629.0 ]--
r 106         //set up log
--[ 2019.10.30.19.25.42.764.0 ]--
r 106         //set up logi
--[ 2019.10.30.19.25.43.005.0 ]--
r 106         //set up logic
--[ 2019.10.30.19.25.43.216.0 ]--
r 106         //set up logic 
--[ 2019.10.30.19.25.43.895.0 ]--
r 106         //set up logic b
--[ 2019.10.30.19.25.43.997.0 ]--
r 106         //set up logic bo
--[ 2019.10.30.19.25.44.206.0 ]--
r 106         //set up logic boa
--[ 2019.10.30.19.25.44.360.0 ]--
r 106         //set up logic boar
--[ 2019.10.30.19.25.44.555.0 ]--
r 106         //set up logic board
--[ 2019.10.30.19.25.44.698.0 ]--
r 106         //set up logic board 
--[ 2019.10.30.19.25.45.080.0 ]--
r 106         //set up logic board w
--[ 2019.10.30.19.25.45.153.0 ]--
r 106         //set up logic board wi
--[ 2019.10.30.19.25.45.289.0 ]--
r 106         //set up logic board wit
--[ 2019.10.30.19.25.45.334.0 ]--
r 106         //set up logic board with
--[ 2019.10.30.19.25.45.636.0 ]--
r 106         //set up logic board with 
--[ 2019.10.30.19.25.47.599.0 ]--
r 106         //set up logic board with 2
--[ 2019.10.30.19.25.47.890.0 ]--
r 106         //set up logic board with 2D
--[ 2019.10.30.19.25.48.298.0 ]--
r 106         //set up logic board with 2D 
--[ 2019.10.30.19.25.48.561.0 ]--
r 106         //set up logic board with 2D a
--[ 2019.10.30.19.25.48.769.0 ]--
r 106         //set up logic board with 2D ar
--[ 2019.10.30.19.25.48.933.0 ]--
r 106         //set up logic board with 2D arr
--[ 2019.10.30.19.25.49.049.0 ]--
r 106         //set up logic board with 2D arra
--[ 2019.10.30.19.25.49.136.0 ]--
r 106         //set up logic board with 2D array
--[ 2019.10.30.19.25.51.513.0 ]--
+ 109         
--[ 2019.10.30.19.25.52.061.0 ]--
+ 109         
--[ 2019.10.30.19.25.53.020.0 ]--
r 110         /
--[ 2019.10.30.19.25.53.120.0 ]--
r 110         //
--[ 2019.10.30.19.25.53.936.0 ]--
r 110         //s
--[ 2019.10.30.19.25.54.057.0 ]--
r 110         //se
--[ 2019.10.30.19.25.54.238.0 ]--
r 110         //set
--[ 2019.10.30.19.25.54.364.0 ]--
r 110         //set 
--[ 2019.10.30.19.25.54.518.0 ]--
r 110         //set u
--[ 2019.10.30.19.25.54.606.0 ]--
r 110         //set up
--[ 2019.10.30.19.25.54.757.0 ]--
r 110         //set up 
--[ 2019.10.30.19.26.03.100.0 ]--
r 110         //set up M
--[ 2019.10.30.19.26.03.745.0 ]--
r 110         //set up Mi
--[ 2019.10.30.19.26.03.882.0 ]--
r 110         //set up Min
--[ 2019.10.30.19.26.04.720.0 ]--
r 110         //set up Mini
--[ 2019.10.30.19.26.04.854.0 ]--
r 110         //set up Minim
--[ 2019.10.30.19.26.05.086.0 ]--
r 110         //set up Minimu
--[ 2019.10.30.19.26.05.506.0 ]--
r 110         //set up Minimum
--[ 2019.10.30.19.26.05.625.0 ]--
r 110         //set up Minimum 
--[ 2019.10.30.19.26.06.056.0 ]--
r 110         //set up Minimum P
--[ 2019.10.30.19.26.06.338.0 ]--
r 110         //set up Minimum Pr
--[ 2019.10.30.19.26.06.502.0 ]--
r 110         //set up Minimum Pri
--[ 2019.10.30.19.26.06.638.0 ]--
r 110         //set up Minimum Prio
--[ 2019.10.30.19.26.07.206.0 ]--
r 110         //set up Minimum Prior
--[ 2019.10.30.19.26.07.496.0 ]--
r 110         //set up Minimum Priori
--[ 2019.10.30.19.26.07.692.0 ]--
r 110         //set up Minimum Priorit
--[ 2019.10.30.19.26.07.827.0 ]--
r 110         //set up Minimum Priority
--[ 2019.10.30.19.26.08.699.0 ]--
r 110         //set up Minimum Priority 
--[ 2019.10.30.19.26.09.099.0 ]--
r 110         //set up Minimum Priority Q
--[ 2019.10.30.19.26.09.385.0 ]--
r 110         //set up Minimum Priority Qu
--[ 2019.10.30.19.26.09.626.0 ]--
r 110         //set up Minimum Priority Que
--[ 2019.10.30.19.26.09.703.0 ]--
r 110         //set up Minimum Priority Queu
--[ 2019.10.30.19.26.09.777.0 ]--
r 110         //set up Minimum Priority Queue
--[ 2019.10.30.19.27.46.190.0 ]--
- 116
r 116         
--[ 2019.10.30.19.27.46.295.0 ]--
- 116
--[ 2019.10.30.19.27.47.273.0 ]--
+ 116         
--[ 2019.10.30.19.27.47.743.0 ]--
r 116         w
--[ 2019.10.30.19.27.47.847.0 ]--
r 116         wh
--[ 2019.10.30.19.27.47.915.0 ]--
r 116         whi
--[ 2019.10.30.19.27.48.061.0 ]--
r 116         whil
--[ 2019.10.30.19.27.48.127.0 ]--
r 116         while
--[ 2019.10.30.19.27.49.270.0 ]--
r 116         while{
--[ 2019.10.30.19.27.50.723.0 ]--
+ 117 
+ 118 }
--[ 2019.10.30.19.27.50.778.0 ]--
r 118         }
--[ 2019.10.30.19.27.50.799.0 ]--
r 117             
--[ 2019.10.30.19.27.59.332.0 ]--
r 116         while(){
--[ 2019.10.30.19.28.32.640.0 ]--
r 116         while(p){
--[ 2019.10.30.19.28.32.884.0 ]--
r 116         while(pa){
--[ 2019.10.30.19.28.33.114.0 ]--
r 116         while(pat){
--[ 2019.10.30.19.28.33.200.0 ]--
r 116         while(path){
--[ 2019.10.30.19.28.34.958.0 ]--
r 116         while(pathFound){
--[ 2019.10.30.19.28.35.579.0 ]--
r 116         while(pathFound ){
--[ 2019.10.30.19.28.35.683.0 ]--
r 116         while(pathFound =){
--[ 2019.10.30.19.28.36.516.0 ]--
r 116         while(pathFound ==){
--[ 2019.10.30.19.28.37.329.0 ]--
r 116         while(pathFound == ){
--[ 2019.10.30.19.28.37.698.0 ]--
r 116         while(pathFound == f){
--[ 2019.10.30.19.28.37.813.0 ]--
r 116         while(pathFound == fa){
--[ 2019.10.30.19.28.37.971.0 ]--
r 116         while(pathFound == fal){
--[ 2019.10.30.19.28.38.033.0 ]--
r 116         while(pathFound == fals){
--[ 2019.10.30.19.28.38.187.0 ]--
r 116         while(pathFound == false){
--[ 2019.10.30.19.28.44.179.0 ]--
r 116         while(!pathFound){
--[ 2019.10.30.19.28.54.705.0 ]--
r 14 
--[ 2019.10.30.19.28.56.301.0 ]--
- 14
--[ 2019.10.30.19.28.58.971.0 ]--
+ 14 
--[ 2019.10.30.19.28.59.664.0 ]--
r 14     private boolean pathFound = false;  //implement in compute path, set to true when found
--[ 2019.10.30.19.29.27.813.0 ]--
r 109 
--[ 2019.10.30.19.31.55.066.0 ]--
r 117 
--[ 2019.10.30.19.31.55.475.0 ]--
DisposeComponent
--[ 2019.10.30.19.32.02.215.0 ]--
DisposeComponent
--[ 2019.10.30.19.32.07.124.0 ]--
- 117
--[ 2019.10.30.19.32.07.938.0 ]--
+ 117             
--[ 2019.10.30.19.32.19.501.0 ]--
r 117             /
--[ 2019.10.30.19.32.19.612.0 ]--
r 117             //
--[ 2019.10.30.19.32.23.649.0 ]--
r 117             //r
--[ 2019.10.30.19.32.23.776.0 ]--
r 117             //re
--[ 2019.10.30.19.32.23.950.0 ]--
r 117             //rem
--[ 2019.10.30.19.32.24.068.0 ]--
r 117             //remo
--[ 2019.10.30.19.32.24.212.0 ]--
r 117             //remov
--[ 2019.10.30.19.32.24.425.0 ]--
r 117             //remove
--[ 2019.10.30.19.32.24.544.0 ]--
r 117             //remove 
--[ 2019.10.30.19.32.24.660.0 ]--
r 117             //remove f
--[ 2019.10.30.19.32.24.883.0 ]--
r 117             //remove fr
--[ 2019.10.30.19.32.24.976.0 ]--
r 117             //remove fro
--[ 2019.10.30.19.32.25.093.0 ]--
r 117             //remove from
--[ 2019.10.30.19.32.25.356.0 ]--
r 117             //remove from 
--[ 2019.10.30.19.32.25.927.0 ]--
r 117             //remove from p
--[ 2019.10.30.19.32.27.183.0 ]--
r 117             //remove from pq
--[ 2019.10.30.19.32.27.286.0 ]--
+ 118             
--[ 2019.10.30.19.32.28.679.0 ]--
r 118             /
--[ 2019.10.30.19.32.28.846.0 ]--
r 118             //
--[ 2019.10.30.19.32.30.193.0 ]--
r 118             //"
--[ 2019.10.30.19.32.30.571.0 ]--
r 118             //"p
--[ 2019.10.30.19.32.30.769.0 ]--
r 118             //"pr
--[ 2019.10.30.19.32.30.865.0 ]--
r 118             //"pro
--[ 2019.10.30.19.32.31.147.0 ]--
r 118             //"proc
--[ 2019.10.30.19.32.31.389.0 ]--
r 118             //"proce
--[ 2019.10.30.19.32.31.548.0 ]--
r 118             //"proces
--[ 2019.10.30.19.32.31.704.0 ]--
r 118             //"process
--[ 2019.10.30.19.32.31.935.0 ]--
r 118             //"process"
--[ 2019.10.30.19.32.33.116.0 ]--
r 118             //"process" 
--[ 2019.10.30.19.32.33.411.0 ]--
r 118             //"process" n
--[ 2019.10.30.19.32.33.476.0 ]--
r 118             //"process" no
--[ 2019.10.30.19.32.33.638.0 ]--
r 118             //"process" nod
--[ 2019.10.30.19.32.33.824.0 ]--
r 118             //"process" node
--[ 2019.10.30.19.32.33.925.0 ]--
+ 119             
--[ 2019.10.30.19.32.36.428.0 ]--
- 119
--[ 2019.10.30.19.32.37.202.0 ]--
r 118             //"process" node 
--[ 2019.10.30.19.32.37.462.0 ]--
r 118             //"process" node j
--[ 2019.10.30.19.32.37.644.0 ]--
r 118             //"process" node ju
--[ 2019.10.30.19.32.37.756.0 ]--
r 118             //"process" node jus
--[ 2019.10.30.19.32.38.007.0 ]--
r 118             //"process" node just
--[ 2019.10.30.19.32.38.141.0 ]--
r 118             //"process" node just 
--[ 2019.10.30.19.32.38.296.0 ]--
r 118             //"process" node just r
--[ 2019.10.30.19.32.38.416.0 ]--
r 118             //"process" node just re
--[ 2019.10.30.19.32.38.615.0 ]--
r 118             //"process" node just rem
--[ 2019.10.30.19.32.38.845.0 ]--
r 118             //"process" node just remo
--[ 2019.10.30.19.32.39.051.0 ]--
r 118             //"process" node just remov
--[ 2019.10.30.19.32.39.278.0 ]--
r 118             //"process" node just remove
--[ 2019.10.30.19.32.40.246.0 ]--
r 118             //"process" node just removed
--[ 2019.10.30.19.32.40.338.0 ]--
+ 119             
--[ 2019.10.30.19.32.41.469.0 ]--
r 119             /
--[ 2019.10.30.19.32.41.583.0 ]--
r 119             //
--[ 2019.10.30.19.32.45.556.0 ]--
r 119             //a
--[ 2019.10.30.19.32.45.916.0 ]--
r 119             //ab
--[ 2019.10.30.19.32.46.148.0 ]--
r 119             //abc
--[ 2019.10.30.19.32.46.435.0 ]--
r 119             //abcd
--[ 2019.10.30.19.33.00.466.0 ]--
+ 118             
--[ 2019.10.30.19.33.00.917.0 ]--
r 118             /
--[ 2019.10.30.19.33.01.032.0 ]--
r 118             //
--[ 2019.10.30.19.33.01.877.0 ]--
r 118             //c
--[ 2019.10.30.19.33.01.995.0 ]--
r 118             //ch
--[ 2019.10.30.19.33.02.103.0 ]--
r 118             //che
--[ 2019.10.30.19.33.02.288.0 ]--
r 118             //chec
--[ 2019.10.30.19.33.02.433.0 ]--
r 118             //check
--[ 2019.10.30.19.33.02.587.0 ]--
r 118             //check 
--[ 2019.10.30.19.33.02.754.0 ]--
r 118             //check i
--[ 2019.10.30.19.33.03.027.0 ]--
r 118             //check if
--[ 2019.10.30.19.33.03.133.0 ]--
r 118             //check if 
--[ 2019.10.30.19.33.03.314.0 ]--
r 118             //check if n
--[ 2019.10.30.19.33.03.384.0 ]--
r 118             //check if no
--[ 2019.10.30.19.33.03.718.0 ]--
r 118             //check if nod
--[ 2019.10.30.19.33.03.877.0 ]--
r 118             //check if node
--[ 2019.10.30.19.33.03.989.0 ]--
r 118             //check if node 
--[ 2019.10.30.19.33.04.152.0 ]--
r 118             //check if node i
--[ 2019.10.30.19.33.04.210.0 ]--
r 118             //check if node is
--[ 2019.10.30.19.33.04.329.0 ]--
r 118             //check if node is 
--[ 2019.10.30.19.33.04.599.0 ]--
r 118             //check if node is a
--[ 2019.10.30.19.33.04.877.0 ]--
r 118             //check if node is at
--[ 2019.10.30.19.33.05.061.0 ]--
r 118             //check if node is at 
--[ 2019.10.30.19.33.05.412.0 ]--
r 118             //check if node is at e
--[ 2019.10.30.19.33.05.483.0 ]--
r 118             //check if node is at en
--[ 2019.10.30.19.33.05.643.0 ]--
r 118             //check if node is at end
--[ 2019.10.30.19.39.37.066.0 ]--
+ 115         
--[ 2019.10.30.19.39.37.282.0 ]--
+ 115                 PFNode s = new PFNode(getPathStart(), null);
r 116         board[getPathStart().getI()][getPathStart().getJ()] = s;
--[ 2019.10.30.19.39.37.354.0 ]--
r 115         PFNode s = new PFNode(getPathStart(), null);
--[ 2019.10.30.19.39.53.024.0 ]--
- 115
r 115         
--[ 2019.10.30.19.39.53.656.0 ]--
- 115
--[ 2019.10.30.19.42.24.878.0 ]--
+ 118             
--[ 2019.10.30.19.42.34.124.0 ]--
r 118             p
--[ 2019.10.30.19.42.34.822.0 ]--
r 118             pq
--[ 2019.10.30.19.42.35.155.0 ]--
r 118             pq.
--[ 2019.10.30.19.42.36.637.0 ]--
r 118             pq.delMin
--[ 2019.10.30.19.42.36.648.0 ]--
r 118             pq.delMin()
--[ 2019.10.30.19.42.37.893.0 ]--
r 118             pq.delMin();
--[ 2019.10.30.19.42.46.396.0 ]--
+ 120             
--[ 2019.10.30.19.43.02.234.0 ]--
r 118             rpq.delMin();
--[ 2019.10.30.19.43.02.337.0 ]--
r 118             repq.delMin();
--[ 2019.10.30.19.43.02.621.0 ]--
r 118             rempq.delMin();
--[ 2019.10.30.19.43.02.718.0 ]--
r 118             remopq.delMin();
--[ 2019.10.30.19.43.02.803.0 ]--
r 118             removpq.delMin();
--[ 2019.10.30.19.43.03.024.0 ]--
r 118             removepq.delMin();
--[ 2019.10.30.19.43.03.218.0 ]--
r 118             removedpq.delMin();
--[ 2019.10.30.19.43.03.424.0 ]--
r 118             removed pq.delMin();
--[ 2019.10.30.19.43.04.503.0 ]--
r 118             removed =pq.delMin();
--[ 2019.10.30.19.43.04.603.0 ]--
r 118             removed = pq.delMin();
--[ 2019.10.30.19.43.17.066.0 ]--
r 118             Premoved = pq.delMin();
--[ 2019.10.30.19.43.17.538.0 ]--
r 118             PFremoved = pq.delMin();
--[ 2019.10.30.19.43.18.032.0 ]--
r 118             PFNremoved = pq.delMin();
--[ 2019.10.30.19.43.18.563.0 ]--
r 118             PFNoremoved = pq.delMin();
--[ 2019.10.30.19.43.18.965.0 ]--
r 118             PFNodremoved = pq.delMin();
--[ 2019.10.30.19.43.19.122.0 ]--
r 118             PFNoderemoved = pq.delMin();
--[ 2019.10.30.19.43.19.483.0 ]--
r 118             PFNode removed = pq.delMin();
--[ 2019.10.30.19.43.23.386.0 ]--
r 120             i
--[ 2019.10.30.19.43.23.649.0 ]--
r 120             if
--[ 2019.10.30.19.43.25.525.0 ]--
r 120             if()
--[ 2019.10.30.19.43.26.424.0 ]--
r 120             if(r)
--[ 2019.10.30.19.43.26.531.0 ]--
r 120             if(re)
--[ 2019.10.30.19.43.26.831.0 ]--
r 120             if(rem)
--[ 2019.10.30.19.43.26.907.0 ]--
r 120             if(remo)
--[ 2019.10.30.19.43.27.091.0 ]--
r 120             if(remov)
--[ 2019.10.30.19.43.27.257.0 ]--
r 120             if(remove)
--[ 2019.10.30.19.43.27.481.0 ]--
r 120             if(removed)
--[ 2019.10.30.19.43.31.274.0 ]--
r 120             if(removed )
--[ 2019.10.30.19.43.31.407.0 ]--
r 120             if(removed =)
--[ 2019.10.30.19.43.31.628.0 ]--
r 120             if(removed ==\)
--[ 2019.10.30.19.43.32.242.0 ]--
r 120             if(removed ==)
--[ 2019.10.30.19.43.46.532.0 ]--
r 120             if(removed =)
--[ 2019.10.30.19.43.46.664.0 ]--
r 120             if(removed )
--[ 2019.10.30.19.43.46.906.0 ]--
r 120             if(removed)
--[ 2019.10.30.19.43.47.759.0 ]--
r 120             if(removed.)
--[ 2019.10.30.19.43.48.421.0 ]--
r 120             if(removed.g)
--[ 2019.10.30.19.43.48.554.0 ]--
r 120             if(removed.ge)
--[ 2019.10.30.19.43.48.705.0 ]--
r 120             if(removed.get)
--[ 2019.10.30.19.43.54.529.0 ]--
r 120             if(removed.getI)
--[ 2019.10.30.19.43.55.021.0 ]--
r 120             if(removed.getI())
--[ 2019.10.30.19.43.57.323.0 ]--
r 120             if(removed.getI()
--[ 2019.10.30.19.43.57.424.0 ]--
r 120             if(removed.getI)
--[ 2019.10.30.19.43.57.589.0 ]--
r 120             if(removed.get)
--[ 2019.10.30.19.43.57.784.0 ]--
r 120             if(removed.ge)
--[ 2019.10.30.19.43.58.223.0 ]--
r 120             if(removed.g)
--[ 2019.10.30.19.43.58.907.0 ]--
r 120             if(removed.)
--[ 2019.10.30.19.43.59.111.0 ]--
r 120             if(removed)
--[ 2019.10.30.19.46.33.836.0 ]--
r 120             if(removed.)
--[ 2019.10.30.19.46.34.255.0 ]--
r 120             if(removed.i)
--[ 2019.10.30.19.46.36.710.0 ]--
r 120             if(removed.)
--[ 2019.10.30.19.46.36.845.0 ]--
r 120             if(removed)
--[ 2019.10.30.19.47.05.964.0 ]--
r 120             if(removed.)
--[ 2019.10.30.19.47.06.265.0 ]--
r 120             if(removed.l)
--[ 2019.10.30.19.47.06.438.0 ]--
r 120             if(removed.lo)
--[ 2019.10.30.19.47.06.917.0 ]--
r 120             if(removed.loc)
--[ 2019.10.30.20.23.59.020.0 ]--
r 120             if(removed.loc
--[ 2019.10.30.20.23.59.159.0 ]--
r 120             if(removed.lo
--[ 2019.10.30.20.23.59.343.0 ]--
r 120             if(removed.l
--[ 2019.10.30.20.23.59.474.0 ]--
r 120             if(removed.
--[ 2019.10.30.20.23.59.643.0 ]--
r 120             if(removed
--[ 2019.10.30.20.24.00.169.0 ]--
r 120             if(removed 
--[ 2019.10.30.20.24.00.516.0 ]--
r 120             if(removed =
--[ 2019.10.30.20.24.00.631.0 ]--
r 120             if(removed ==
--[ 2019.10.30.20.24.01.076.0 ]--
r 120             if(removed == 
--[ 2019.10.30.20.24.01.489.0 ]--
r 120             if(removed == g
--[ 2019.10.30.20.24.01.666.0 ]--
r 120             if(removed == ge
--[ 2019.10.30.20.24.01.764.0 ]--
r 120             if(removed == get
--[ 2019.10.30.20.24.04.762.0 ]--
r 120             if(removed == getPathEnd
--[ 2019.10.30.20.24.04.776.0 ]--
r 120             if(removed == getPathEnd()
--[ 2019.10.30.20.24.06.886.0 ]--
r 120             if(removed == getPathEnd())
--[ 2019.10.30.20.24.09.467.0 ]--
r 120             if(removed == getPathEnd()){
--[ 2019.10.30.20.24.09.776.0 ]--
+ 121 
+ 122 }
--[ 2019.10.30.20.24.09.823.0 ]--
r 122             }
--[ 2019.10.30.20.24.09.862.0 ]--
r 121                 
--[ 2019.10.30.20.32.03.419.0 ]--
r 118             C removed = pq.delMin();
--[ 2019.10.30.20.32.03.836.0 ]--
r 118             Co removed = pq.delMin();
--[ 2019.10.30.20.32.03.958.0 ]--
r 118             Coo removed = pq.delMin();
--[ 2019.10.30.20.32.04.069.0 ]--
r 118             Coor removed = pq.delMin();
--[ 2019.10.30.20.32.04.305.0 ]--
r 118             Coord removed = pq.delMin();
--[ 2019.10.30.20.33.03.920.0 ]--
r 118             P removed = pq.delMin();
--[ 2019.10.30.20.33.04.181.0 ]--
r 118             PF removed = pq.delMin();
--[ 2019.10.30.20.33.04.981.0 ]--
r 118             PFNode removed = pq.delMin();
--[ 2019.10.30.20.34.51.851.0 ]--
r 120             if(removed. == getPathEnd()){
--[ 2019.10.30.20.34.52.265.0 ]--
r 120             if(removed.c == getPathEnd()){
--[ 2019.10.30.20.34.52.416.0 ]--
r 120             if(removed.co == getPathEnd()){
--[ 2019.10.30.20.34.52.516.0 ]--
r 120             if(removed.coo == getPathEnd()){
--[ 2019.10.30.20.34.52.589.0 ]--
r 120             if(removed.cood == getPathEnd()){
--[ 2019.10.30.20.34.53.046.0 ]--
r 120             if(removed.coo == getPathEnd()){
--[ 2019.10.30.20.34.54.187.0 ]--
r 120             if(removed.coor == getPathEnd()){
--[ 2019.10.30.20.34.54.805.0 ]--
r 120             if(removed.coord == getPathEnd()){
--[ 2019.10.30.20.35.22.970.0 ]--
r 113         PFNode s = new PFNode(n, null);
--[ 2019.10.30.20.35.23.210.0 ]--
r 113         PFNode s = new PFNode(nu, null);
--[ 2019.10.30.20.35.23.347.0 ]--
r 113         PFNode s = new PFNode(nul, null);
--[ 2019.10.30.20.35.23.495.0 ]--
r 113         PFNode s = new PFNode(null, null);
--[ 2019.10.30.20.35.46.726.0 ]--
r 113         PFNode s = new PFNode(nul, null);
--[ 2019.10.30.20.35.46.849.0 ]--
r 113         PFNode s = new PFNode(nu, null);
--[ 2019.10.30.20.35.47.028.0 ]--
r 113         PFNode s = new PFNode(n, null);
--[ 2019.10.30.20.35.47.521.0 ]--
r 113         PFNode s = new PFNode(, null);
--[ 2019.10.30.20.35.48.660.0 ]--
r 113         PFNode s = new PFNode(9, null);
--[ 2019.10.30.20.35.48.761.0 ]--
r 113         PFNode s = new PFNode(90, null);
--[ 2019.10.30.20.35.49.426.0 ]--
r 113         PFNode s = new PFNode(9, null);
--[ 2019.10.30.20.35.49.576.0 ]--
r 113         PFNode s = new PFNode(, null);
--[ 2019.10.30.20.35.50.423.0 ]--
r 113         PFNode s = new PFNode((), null);
--[ 2019.10.30.20.36.11.987.0 ]--
r 113         PFNode s = new PFNode((getPathStart().getI()), null);
--[ 2019.10.30.20.36.13.484.0 ]--
r 113         PFNode s = new PFNode((getPathStart().getI(),), null);
--[ 2019.10.30.20.36.20.956.0 ]--
r 113         PFNode s = new PFNode((getPathStart().getI(),getPathStart().getJ()), null);
--[ 2019.10.30.20.40.43.269.0 ]--
r 113         PFNode s = new PFNode(b), null);
--[ 2019.10.30.20.40.43.351.0 ]--
r 113         PFNode s = new PFNode(bo), null);
--[ 2019.10.30.20.40.43.468.0 ]--
r 113         PFNode s = new PFNode(boa), null);
--[ 2019.10.30.20.40.43.726.0 ]--
r 113         PFNode s = new PFNode(boar), null);
--[ 2019.10.30.20.40.43.945.0 ]--
r 113         PFNode s = new PFNode(board), null);
--[ 2019.10.30.20.40.44.927.0 ]--
r 113         PFNode s = new PFNode(board[]), null);
--[ 2019.10.30.20.40.45.386.0 ]--
r 113         PFNode s = new PFNode(board[][]), null);
--[ 2019.10.30.20.40.59.338.0 ]--
r 113         PFNode s = new PFNode(board[getPathStart().getI()][]), null);
--[ 2019.10.30.20.41.04.335.0 ]--
r 113         PFNode s = new PFNode(board[getPathStart().getI()][getPathStart().getJ()]), null);
--[ 2019.10.30.20.41.18.177.0 ]--
r 113         PFNode s = new PFNode(board[getPathStart().getI()][getPathStart().getJ()], null);
--[ 2019.10.30.20.43.30.176.0 ]--
r 113         PFNode s = new PFNode(g, null);
--[ 2019.10.30.20.43.30.347.0 ]--
r 113         PFNode s = new PFNode(ge, null);
--[ 2019.10.30.20.43.30.560.0 ]--
r 113         PFNode s = new PFNode(get, null);
--[ 2019.10.30.20.43.31.671.0 ]--
r 113         PFNode s = new PFNode(getPathStart, null);
--[ 2019.10.30.20.43.31.682.0 ]--
r 113         PFNode s = new PFNode(getPathStart(), null);
--[ 2019.10.30.20.45.11.112.0 ]--
r 121 
--[ 2019.10.30.20.51.05.964.0 ]--
r 120             if(removed.coor == getPathEnd()){
--[ 2019.10.30.20.51.06.071.0 ]--
r 120             if(removed.coo == getPathEnd()){
--[ 2019.10.30.20.51.06.168.0 ]--
r 120             if(removed.co == getPathEnd()){
--[ 2019.10.30.20.51.06.354.0 ]--
r 120             if(removed.c == getPathEnd()){
--[ 2019.10.30.20.51.06.467.0 ]--
r 120             if(removed. == getPathEnd()){
--[ 2019.10.30.20.51.06.628.0 ]--
r 120             if(removed == getPathEnd()){
--[ 2019.10.30.20.51.23.414.0 ]--
r 120             if(removed. == getPathEnd()){
--[ 2019.10.30.20.51.23.712.0 ]--
r 120             if(removed.l == getPathEnd()){
--[ 2019.10.30.20.51.23.833.0 ]--
r 120             if(removed.lo == getPathEnd()){
--[ 2019.10.30.20.51.23.930.0 ]--
r 120             if(removed.loc == getPathEnd()){
--[ 2019.10.30.20.52.17.172.0 ]--
r 120             if(pq.delMin() == getPathEnd()){
--[ 2019.10.30.20.52.23.500.0 ]--
r 120             if(pq.delMin(). == getPathEnd()){
--[ 2019.10.30.20.52.23.906.0 ]--
r 120             if(pq.delMin().c == getPathEnd()){
--[ 2019.10.30.20.52.24.074.0 ]--
r 120             if(pq.delMin().co == getPathEnd()){
--[ 2019.10.30.20.52.24.199.0 ]--
r 120             if(pq.delMin().coo == getPathEnd()){
--[ 2019.10.30.20.52.24.293.0 ]--
r 120             if(pq.delMin().coor == getPathEnd()){
--[ 2019.10.30.20.52.24.584.0 ]--
r 120             if(pq.delMin().coord == getPathEnd()){
--[ 2019.10.30.20.52.29.976.0 ]--
r 120             if(pq.delMin() == getPathEnd()){
--[ 2019.10.30.20.52.30.672.0 ]--
r 120             if(removed.loc == getPathEnd()){
--[ 2019.10.30.20.55.33.557.0 ]--
+ 33         
--[ 2019.10.30.20.55.34.081.0 ]--
+ 33         
--[ 2019.10.30.20.55.34.713.0 ]--
r 34         p
--[ 2019.10.30.20.55.35.121.0 ]--
r 34         pu
--[ 2019.10.30.20.55.36.692.0 ]--
r 34         p
--[ 2019.10.30.20.55.36.966.0 ]--
r 34         
--[ 2019.10.30.20.55.37.324.0 ]--
- 33
--[ 2019.10.30.20.55.41.737.0 ]--
- 33
--[ 2019.10.30.20.59.39.373.0 ]--
- 121
--[ 2019.10.30.21.01.29.686.0 ]--
+ 24         
--[ 2019.10.30.21.01.31.150.0 ]--
r 24         p
--[ 2019.10.30.21.01.31.501.0 ]--
r 24         pr
--[ 2019.10.30.21.01.31.652.0 ]--
r 24         pri
--[ 2019.10.30.21.01.31.901.0 ]--
r 24         priv
--[ 2019.10.30.21.01.32.117.0 ]--
r 24         priva
--[ 2019.10.30.21.01.32.460.0 ]--
r 24         privat
--[ 2019.10.30.21.01.32.568.0 ]--
r 24         private
--[ 2019.10.30.21.01.33.330.0 ]--
r 24         private 
--[ 2019.10.30.21.01.48.047.0 ]--
r 24         private C
--[ 2019.10.30.21.01.48.446.0 ]--
r 24         private Co
--[ 2019.10.30.21.01.48.516.0 ]--
r 24         private Coo
--[ 2019.10.30.21.01.48.831.0 ]--
r 24         private Coor
--[ 2019.10.30.21.01.49.097.0 ]--
r 24         private Coord
--[ 2019.10.30.21.01.49.383.0 ]--
r 24         private Coord 
--[ 2019.10.30.21.01.49.757.0 ]--
r 24         private Coord l
--[ 2019.10.30.21.01.49.966.0 ]--
r 24         private Coord lo
--[ 2019.10.30.21.01.50.247.0 ]--
r 24         private Coord loc
--[ 2019.10.30.21.01.51.541.0 ]--
r 24         private Coord loc;
--[ 2019.10.30.21.01.51.958.0 ]--
+ 25         
--[ 2019.10.30.21.02.08.173.0 ]--
r 25         p
--[ 2019.10.30.21.02.08.488.0 ]--
r 25         pr
--[ 2019.10.30.21.02.08.672.0 ]--
r 25         pri
--[ 2019.10.30.21.02.08.895.0 ]--
r 25         priv
--[ 2019.10.30.21.02.09.194.0 ]--
r 25         priva
--[ 2019.10.30.21.02.10.159.0 ]--
r 25         private
--[ 2019.10.30.21.02.10.212.0 ]--
r 25         private 
--[ 2019.10.30.21.02.11.132.0 ]--
r 25         private P
--[ 2019.10.30.21.02.11.499.0 ]--
r 25         private PF
--[ 2019.10.30.21.02.12.005.0 ]--
r 25         private PFN
--[ 2019.10.30.21.02.12.234.0 ]--
r 25         private PFNo
--[ 2019.10.30.21.02.12.760.0 ]--
r 25         private PFNod
--[ 2019.10.30.21.02.12.944.0 ]--
r 25         private PFNode
--[ 2019.10.30.21.02.14.891.0 ]--
r 25         private PFNode 
--[ 2019.10.30.21.02.15.070.0 ]--
r 25         private PFNode l
--[ 2019.10.30.21.02.15.351.0 ]--
r 25         private PFNode lo
--[ 2019.10.30.21.02.15.419.0 ]--
r 25         private PFNode loc
--[ 2019.10.30.21.02.16.133.0 ]--
r 25         private PFNode lo
--[ 2019.10.30.21.02.16.317.0 ]--
r 25         private PFNode l
--[ 2019.10.30.21.02.16.505.0 ]--
r 25         private PFNode 
--[ 2019.10.30.21.02.19.112.0 ]--
r 25         private PFNode f
--[ 2019.10.30.21.02.19.272.0 ]--
r 25         private PFNode fr
--[ 2019.10.30.21.02.19.354.0 ]--
r 25         private PFNode fro
--[ 2019.10.30.21.02.19.471.0 ]--
r 25         private PFNode from
--[ 2019.10.30.21.02.20.253.0 ]--
r 25         private PFNode fromN
--[ 2019.10.30.21.02.20.455.0 ]--
r 25         private PFNode fromNo
--[ 2019.10.30.21.02.20.712.0 ]--
r 25         private PFNode fromNod
--[ 2019.10.30.21.02.20.877.0 ]--
r 25         private PFNode fromNode
--[ 2019.10.30.21.02.21.503.0 ]--
r 25         private PFNode fromNodel
--[ 2019.10.30.21.02.21.903.0 ]--
r 25         private PFNode fromNode
--[ 2019.10.30.21.02.22.487.0 ]--
r 25         private PFNode fromNode;
--[ 2019.10.30.21.03.10.057.0 ]--
+ 28         public PFNode(Coord loc, PFNode fromNode) { 
r 29         }
--[ 2019.10.30.21.03.10.083.0 ]--
+ 29             
--[ 2019.10.30.21.03.12.640.0 ]--
r 29             l
--[ 2019.10.30.21.03.12.980.0 ]--
r 29             lo
--[ 2019.10.30.21.03.13.029.0 ]--
r 29             loc
--[ 2019.10.30.21.03.19.884.0 ]--
r 29             loc 
--[ 2019.10.30.21.03.20.019.0 ]--
r 29             loc =
--[ 2019.10.30.21.03.20.210.0 ]--
r 29             loc = 
--[ 2019.10.30.21.03.21.342.0 ]--
r 29             loc = l
--[ 2019.10.30.21.03.21.567.0 ]--
r 29             loc = lo
--[ 2019.10.30.21.03.21.704.0 ]--
r 29             loc = loc
--[ 2019.10.30.21.03.23.119.0 ]--
r 29             loc = loc;
--[ 2019.10.30.21.03.33.228.0 ]--
r 29             loc = loc
--[ 2019.10.30.21.03.33.405.0 ]--
r 29             loc = lo
--[ 2019.10.30.21.03.33.610.0 ]--
r 29             loc = l
--[ 2019.10.30.21.03.34.008.0 ]--
r 29             loc = 
--[ 2019.10.30.21.03.35.765.0 ]--
r 29             loc = P
--[ 2019.10.30.21.03.36.010.0 ]--
r 29             loc = PF
--[ 2019.10.30.21.03.36.659.0 ]--
r 29             loc = PFN
--[ 2019.10.30.21.03.37.054.0 ]--
r 29             loc = PFNo
--[ 2019.10.30.21.03.37.404.0 ]--
r 29             loc = PFNode
--[ 2019.10.30.21.03.38.785.0 ]--
r 29             loc = PFNode.
--[ 2019.10.30.21.03.42.992.0 ]--
r 29             loc = PFNode.g
--[ 2019.10.30.21.03.43.012.0 ]--
r 29             loc = PFNode.ge
--[ 2019.10.30.21.03.43.186.0 ]--
r 29             loc = PFNode.get
--[ 2019.10.30.21.07.30.672.0 ]--
r 29             l
--[ 2019.10.30.21.07.30.909.0 ]--
r 29             lo
--[ 2019.10.30.21.07.31.097.0 ]--
r 29             loc
--[ 2019.10.30.21.07.32.157.0 ]--
r 29             loc.
--[ 2019.10.30.21.07.32.491.0 ]--
r 29             loc.i
--[ 2019.10.30.21.07.32.591.0 ]--
r 29             loc.i 
--[ 2019.10.30.21.07.34.054.0 ]--
r 29             loc.i =
--[ 2019.10.30.21.07.34.469.0 ]--
r 29             loc.i = 
--[ 2019.10.30.21.08.50.645.0 ]--
r 29             loc.i =
--[ 2019.10.30.21.08.50.794.0 ]--
r 29             loc.i 
--[ 2019.10.30.21.08.51.034.0 ]--
r 29             loc.i
--[ 2019.10.30.21.08.51.204.0 ]--
r 29             loc.
--[ 2019.10.30.21.08.51.418.0 ]--
r 29             loc
--[ 2019.10.30.21.08.51.657.0 ]--
r 29             lo
--[ 2019.10.30.21.08.52.003.0 ]--
r 29             l
--[ 2019.10.30.21.08.52.203.0 ]--
r 29             
--[ 2019.10.30.21.08.54.499.0 ]--
r 29             f
--[ 2019.10.30.21.08.54.678.0 ]--
r 29             fr
--[ 2019.10.30.21.08.54.734.0 ]--
r 29             fro
--[ 2019.10.30.21.08.54.846.0 ]--
r 29             from
--[ 2019.10.30.21.08.55.471.0 ]--
r 29             fromNode
--[ 2019.10.30.21.08.56.435.0 ]--
r 29             fromNode 
--[ 2019.10.30.21.08.56.531.0 ]--
r 29             fromNode =
--[ 2019.10.30.21.08.56.639.0 ]--
r 29             fromNode = 
--[ 2019.10.30.21.09.04.315.0 ]--
r 29             fromNode = P
--[ 2019.10.30.21.09.05.004.0 ]--
r 29             fromNode = PF
--[ 2019.10.30.21.09.05.502.0 ]--
r 29             fromNode = PFNode
--[ 2019.10.30.21.09.06.424.0 ]--
r 29             fromNode = PFNode.
--[ 2019.10.30.21.09.07.026.0 ]--
r 29             fromNode = PFNode.n
--[ 2019.10.30.21.09.07.140.0 ]--
r 29             fromNode = PFNode.ne
--[ 2019.10.30.21.09.07.376.0 ]--
r 29             fromNode = PFNode.nex
--[ 2019.10.30.21.09.07.691.0 ]--
r 29             fromNode = PFNode.next
--[ 2019.10.30.21.09.08.908.0 ]--
r 29             fromNode = PFNode.next;
--[ 2019.10.30.21.10.21.477.0 ]--
r 29             l = PFNode.next;
--[ 2019.10.30.21.10.21.748.0 ]--
r 29             lo = PFNode.next;
--[ 2019.10.30.21.10.21.832.0 ]--
r 29             loc = PFNode.next;
--[ 2019.10.30.21.10.24.291.0 ]--
r 29             loc = C.next;
--[ 2019.10.30.21.10.24.583.0 ]--
r 29             loc = Co.next;
--[ 2019.10.30.21.10.24.819.0 ]--
r 29             loc = Coo.next;
--[ 2019.10.30.21.10.25.018.0 ]--
r 29             loc = Coor.next;
--[ 2019.10.30.21.10.25.172.0 ]--
r 29             loc = Coord.next;
--[ 2019.10.30.21.10.26.000.0 ]--
r 29             loc = Coor.next;
--[ 2019.10.30.21.10.27.192.0 ]--
r 29             loc = Coord.next;
--[ 2019.10.30.21.10.27.465.0 ]--
r 29             loc = Coordnext;
--[ 2019.10.30.21.10.27.680.0 ]--
r 29             loc = Coordext;
--[ 2019.10.30.21.10.27.850.0 ]--
r 29             loc = Coordxt;
--[ 2019.10.30.21.10.28.063.0 ]--
r 29             loc = Coordt;
--[ 2019.10.30.21.10.28.336.0 ]--
r 29             loc = Coord;
--[ 2019.10.30.21.10.29.495.0 ]--
r 29             loc = Coord();
--[ 2019.10.30.21.10.57.622.0 ]--
+ 125                 
--[ 2019.10.30.21.10.58.984.0 ]--
r 125                 p
--[ 2019.10.30.21.10.59.328.0 ]--
r 125                 pa
--[ 2019.10.30.21.10.59.557.0 ]--
r 125                 pas
--[ 2019.10.30.21.10.59.777.0 ]--
r 125                 pass
--[ 2019.10.30.21.11.00.600.0 ]--
r 125                 pas
--[ 2019.10.30.21.11.00.809.0 ]--
r 125                 pa
--[ 2019.10.30.21.11.01.090.0 ]--
r 125                 p
--[ 2019.10.30.21.11.01.651.0 ]--
r 125                 
--[ 2019.10.30.21.11.29.488.0 ]--
r 29 
--[ 2019.10.30.21.11.29.873.0 ]--
- 28
r 28         public PFNode(Coord loc, PFNode fromNode) {
--[ 2019.10.30.21.12.16.898.0 ]--
+ 28         
--[ 2019.10.30.21.12.23.804.0 ]--
r 28 
r 125 
--[ 2019.10.30.21.13.44.758.0 ]--
- 125
--[ 2019.10.30.21.13.45.128.0 ]--
+ 125                 
--[ 2019.10.30.21.28.56.986.0 ]--
r 125                 p
--[ 2019.10.30.21.28.57.100.0 ]--
r 125                 pa
--[ 2019.10.30.21.28.57.388.0 ]--
r 125                 pat
--[ 2019.10.30.21.28.57.473.0 ]--
r 125                 path
--[ 2019.10.30.21.28.58.309.0 ]--
r 125                 pathFound
--[ 2019.10.30.21.28.59.568.0 ]--
r 125                 pathFound 
--[ 2019.10.30.21.28.59.653.0 ]--
r 125                 pathFound =
--[ 2019.10.30.21.28.59.755.0 ]--
r 125                 pathFound ==
--[ 2019.10.30.21.29.00.656.0 ]--
r 125                 pathFound == 
--[ 2019.10.30.21.29.00.830.0 ]--
r 125                 pathFound == t
--[ 2019.10.30.21.29.01.214.0 ]--
r 125                 pathFound == tu
--[ 2019.10.30.21.29.01.227.0 ]--
r 125                 pathFound == tur
--[ 2019.10.30.21.29.01.398.0 ]--
r 125                 pathFound == ture
--[ 2019.10.30.21.29.02.601.0 ]--
r 125                 pathFound == true
--[ 2019.10.30.21.29.03.877.0 ]--
r 125                 pathFound == true;
--[ 2019.10.30.21.29.04.425.0 ]--
+ 126                 
--[ 2019.10.30.21.29.10.157.0 ]--
r 125                 pathFound = true;
--[ 2019.10.30.21.29.13.589.0 ]--
r 126                 b
--[ 2019.10.30.21.29.14.015.0 ]--
r 126                 br
--[ 2019.10.30.21.29.14.267.0 ]--
r 126                 bre
--[ 2019.10.30.21.29.14.900.0 ]--
r 126                 break
--[ 2019.10.30.21.29.14.941.0 ]--
r 126                 break;
--[ 2019.10.30.21.29.15.429.0 ]--
r 126                 break;;
--[ 2019.10.30.21.29.16.466.0 ]--
r 126                 break;
--[ 2019.10.30.21.29.28.467.0 ]--
r 124             if(removed.loc == getPathEnd()){ 
--[ 2019.10.30.21.29.28.648.0 ]--
r 124             if(removed.loc == getPathEnd()){  
--[ 2019.10.30.21.29.29.063.0 ]--
r 124             if(removed.loc == getPathEnd()){  /
--[ 2019.10.30.21.29.29.168.0 ]--
r 124             if(removed.loc == getPathEnd()){  //
--[ 2019.10.30.21.29.30.219.0 ]--
r 124             if(removed.loc == getPathEnd()){  //c
--[ 2019.10.30.21.29.30.368.0 ]--
r 124             if(removed.loc == getPathEnd()){  //cp
--[ 2019.10.30.21.29.30.910.0 ]--
r 124             if(removed.loc == getPathEnd()){  //c
--[ 2019.10.30.21.29.31.267.0 ]--
r 124             if(removed.loc == getPathEnd()){  //co
--[ 2019.10.30.21.29.31.775.0 ]--
r 124             if(removed.loc == getPathEnd()){  //cor
--[ 2019.10.30.21.29.31.905.0 ]--
r 124             if(removed.loc == getPathEnd()){  //core
--[ 2019.10.30.21.29.32.755.0 ]--
r 124             if(removed.loc == getPathEnd()){  //cor
--[ 2019.10.30.21.29.33.516.0 ]--
r 124             if(removed.loc == getPathEnd()){  //corr
--[ 2019.10.30.21.29.33.822.0 ]--
r 124             if(removed.loc == getPathEnd()){  //corre
--[ 2019.10.30.21.29.34.042.0 ]--
r 124             if(removed.loc == getPathEnd()){  //correc
--[ 2019.10.30.21.29.34.297.0 ]--
r 124             if(removed.loc == getPathEnd()){  //correct
--[ 2019.10.30.21.29.34.517.0 ]--
r 124             if(removed.loc == getPathEnd()){  //correct?
--[ 2019.10.30.21.30.57.710.0 ]--
r 117         PFNode s = new PFNode(s, null);
--[ 2019.10.30.21.30.58.119.0 ]--
r 117         PFNode s = new PFNode(s., null);
--[ 2019.10.30.21.30.58.400.0 ]--
r 117         PFNode s = new PFNode(s.l, null);
--[ 2019.10.30.21.30.58.570.0 ]--
r 117         PFNode s = new PFNode(s.lo, null);
--[ 2019.10.30.21.30.58.687.0 ]--
r 117         PFNode s = new PFNode(s.loc, null);
--[ 2019.10.30.21.31.16.659.0 ]--
r 117         PFNode s = new PFNode(getPathStart(), null);
--[ 2019.10.30.21.33.11.866.0 ]--
r 128             //"process" node just removede
--[ 2019.10.30.21.33.12.165.0 ]--
r 128             //"process" node just removedeo
--[ 2019.10.30.21.33.12.468.0 ]--
r 128             //"process" node just removedeoe
--[ 2019.10.30.21.33.12.574.0 ]--
r 128             //"process" node just removedeoe;
--[ 2019.10.30.21.33.12.611.0 ]--
r 128             //"process" node just removedeoe;a
--[ 2019.10.30.21.33.12.787.0 ]--
r 128             //"process" node just removedeoe;ao
--[ 2019.10.30.21.33.17.128.0 ]--
r 128             //"process" node just removedeoe;a
--[ 2019.10.30.21.33.17.602.0 ]--
r 128             //"process" node just removedeoe;
--[ 2019.10.30.21.33.17.807.0 ]--
r 128             //"process" node just removedeoe
--[ 2019.10.30.21.33.18.006.0 ]--
r 128             //"process" node just removedeo
--[ 2019.10.30.21.33.18.217.0 ]--
r 128             //"process" node just removede
--[ 2019.10.30.21.33.18.626.0 ]--
r 128             //"process" node just removed
--[ 2019.10.31.02.48.23.160.0 ]--
NewLogger: P04_Pathfinding
Version: 1.3
--[ 2019.10.31.02.48.23.319.0 ]--
InitTree:
/out/production/P04_Pathfinding/.donotlog
/out/production/P04_Pathfinding/algs4.jar
/out/production/P04_Pathfinding/stdlib.jar
/out/production/P04_Pathfinding/Coord.class
/out/production/P04_Pathfinding/png2emap.py
/out/production/P04_Pathfinding/Walker.class
/out/production/P04_Pathfinding/ramp.png.emap
/out/production/P04_Pathfinding/Terrain.class
/out/production/P04_Pathfinding/ramp2.png.emap
/out/production/P04_Pathfinding/ramp3.png.emap
/out/production/P04_Pathfinding/mazeAB.png.emap
/out/production/P04_Pathfinding/usa128.png.emap
/out/production/P04_Pathfinding/usa256.png.emap
/out/production/P04_Pathfinding/Pathfinder.class
/out/production/P04_Pathfinding/usa1024.png.emap
/out/production/P04_Pathfinding/maze32_0.png.emap
/out/production/P04_Pathfinding/maze32_1.png.emap
/out/production/P04_Pathfinding/maze232_0.png.emap
/out/production/P04_Pathfinding/maze320_0.png.emap
/out/production/P04_Pathfinding/mazeBrain.png.emap
/out/production/P04_Pathfinding/TerrainEditor.class
/out/production/P04_Pathfinding/Pathfinder$PFNode.class
/out/production/P04_Pathfinding/PathfinderVisualizer.class
/out/production/P04_Pathfinding/InteractivePathfinderVisualizer.class
/src/algs4.jar
/src/Coord.java
/src/stdlib.jar
/src/Walker.java
/src/Terrain.java
/src/Pathfinder.java
/src/TerrainEditor.java
/src/PathfinderVisualizer.java
/src/InteractivePathfinderVisualizer.java
/.log/history.log
/.idea/copyright/profiles_settings.xml
/.idea/libraries/algs4.xml
/.idea/libraries/stdlib.xml
/.idea/.name
/.idea/misc.xml
/.idea/modules.xml
/.idea/compiler.xml
/.idea/workspace.xml
/.idea/uiDesigner.xml
/heightmaps/.donotlog
/heightmaps/png2emap.py
/heightmaps/ramp.png.emap
/heightmaps/ramp2.png.emap
/heightmaps/ramp3.png.emap
/heightmaps/mazeAB.png.emap
/heightmaps/usa128.png.emap
/heightmaps/usa256.png.emap
/heightmaps/usa1024.png.emap
/heightmaps/maze32_0.png.emap
/heightmaps/maze32_1.png.emap
/heightmaps/maze232_0.png.emap
/heightmaps/maze320_0.png.emap
/heightmaps/mazeBrain.png.emap
/.cos265
/readme.html
/P04_Pathfinding.iml

--[ 2019.10.31.02.48.23.320.0 ]--
InitFile: /src/PathfinderVisualizer.java
/**
 * PathfinderVisualizer visualizes the terrain and found path.
 */

import java.awt.Color;
import java.awt.Font;

public class PathfinderVisualizer {

    // delay in milliseconds (controls animation speed)
    private final static int DELAY = 100;

    // color for different elevations.  must be in ascending order!
    private final static int[][] elevationColors = {
            // h    r   g   b   where h=height, r=red, g=green, b=blue
            {  0,   0,  0,  0},
            {  2,   0,  0,160},
            {  4,   0,224,224},
            { 16, 192,192,  0},
            { 64,  16,255, 16},
            {128,  32,224, 32},
            {192, 128,128,  8},
            {224, 164,164,164},
            {255, 255,255,255}
    };

    private final static Color cStart    = new Color(128, 128, 255);
    private final static Color cEnd      = new Color(255, 128, 128);
    private final static Color cSolution = new Color(255, 128, 255);
    private final static Color cSearched = new Color(128,   0, 128);

    // linearly interpolating between the corresponding rgb values
    private static Color colorLERP(float v1, int r0, int g0, int b0, int r1, int g1, int b1) {
        v1 = Math.max(0.0f, Math.min(1.0f, v1));
        float v0 = 1.0f - v1;
        int r = (int)(v0 * r0 + v1 * r1);
        int g = (int)(v0 * g0 + v1 * g1);
        int b = (int)(v0 * b0 + v1 * b1);
        return new Color(r, g, b);
    }
    private static Color colorLERP(float v1, Color c0, Color c1) {
        v1 = Math.max(0.0f, Math.min(1.0f, v1));
        float v0 = 1.0f - v1;
        int r = (int)(v0 * c0.getRed()   + v1 * c1.getRed());
        int g = (int)(v0 * c0.getGreen() + v1 * c1.getGreen());
        int b = (int)(v0 * c0.getBlue()  + v1 * c1.getBlue());
        int a = (int)(v0 * c0.getAlpha() + v1 * c1.getAlpha());
        return new Color(r, g, b, a);
    }

    // returns color for given height
    private static Color height2Color(int h) {
        h = Math.max(0, Math.min(255, h));

        int[] ec0 = elevationColors[0];  // default lower bound
        int[] ec1 = elevationColors[1];  // default upper bound

        // find upper bound while updating lower bound
        for(int i = 1; i < elevationColors.length; i++) {
            ec1 = elevationColors[i];
            if(h >= ec0[0] && h <= ec1[0]) break;
            ec0 = ec1;
        }

        int h0=ec0[0], r0=ec0[1], g0=ec0[2], b0=ec0[3];
        int h1=ec1[0], r1=ec1[1], g1=ec1[2], b1=ec1[3];
        float v1 = ((float)(h - h0)) / ((float)(h1 - h0));

        return colorLERP(v1, r0, g0, b0, r1, g1, b1);
    }

    private static void drawCircle(int i, int j, int N, double rad) {
        int c = (int)((i+0.5f) * 464.0f / N);
        int r = (int)((j+0.5f) * 464.0f / N);
        StdDraw.circle(c + 24, 464 - r + 36, rad);
    }
    public static void drawCircle(Coord loc, int N, double rad) {
        drawCircle(loc.getI(), loc.getJ(), N, rad);
    }

    private static void drawPath(Iterable<Coord> path, int N) {
        boolean first = true;
        int c0 = 0, r0 = 0;
        for (Coord loc : path) {
            int c1 = (int)((loc.getI()+0.5f) * 464.0f / N);
            int r1 = (int)((loc.getJ()+0.5f) * 464.0f / N);
            if(!first) {
                StdDraw.line(c0 + 24, 464 - r0 + 36, c1 + 24, 464 - r1 + 36);
            }
            first = false;
            c0 = c1; r0 = r1;
        }
    }

    // draw N-by-N pathfinding map
    public static void draw(Terrain terrain, Pathfinder pf, Walker walker, int N) {
        StdDraw.clear();
        StdDraw.setXscale(0, 512);
        StdDraw.setYscale(0, 512);
        StdDraw.setPenColor(StdDraw.BLACK);
        StdDraw.filledSquare(256, 256 + 12, 464 / 2);

        // draw terrain
        for(int row = 0; row < 464; row++) {
            int j = (int)((float)row/464.0f * N);
            for(int col = 0; col < 464; col++) {
                int i = (int)((float)col/464.0f * N);
                Coord loc = new Coord(i,j);
                Color c = height2Color(terrain.getHeight(loc));
                if(pf.wasSearched(loc)) {
                    c = colorLERP(0.50f, c, cSearched);
                }
                StdDraw.setPenColor(c);
                StdDraw.filledSquare(col + 24, 464 - row + 36, 1);
            }
        }

        // draw path start
        if(pf.getPathStart() != null) {
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            drawCircle(pf.getPathStart(), N, 4.0);

            StdDraw.setPenColor(cStart);
            StdDraw.setPenRadius(0.002);
            drawCircle(pf.getPathStart(), N, 4.0);
        }

        // draw path end
        if(pf.getPathEnd() != null) {
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            drawCircle(pf.getPathEnd(), N, 4.0);

            StdDraw.setPenColor(cEnd);
            StdDraw.setPenRadius(0.002);
            drawCircle(pf.getPathEnd(), N, 4.0);
        }

        // draw found path
        if(pf.foundPath()) {
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            drawPath(pf.getPathSolution(), N);

            StdDraw.setPenColor(cSolution);
            StdDraw.setPenRadius(0.002);
            drawPath(pf.getPathSolution(), N);
        }

        // draw walker
        if(walker != null) {
            Coord loc = walker.getLocation();
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            PathfinderVisualizer.drawCircle(loc, N, 2.0);

            StdDraw.setPenColor(StdDraw.WHITE);
            StdDraw.setPenRadius(0.002);
            PathfinderVisualizer.drawCircle(loc, N, 2.0);
        }

        // write status text
        StdDraw.setFont(new Font("SansSerif", Font.PLAIN, 12));
        StdDraw.setPenColor(StdDraw.BLACK);
        StdDraw.text(96, 12, "heuristic: " + pf.getHeuristic());
        if(pf.foundPath()) StdDraw.text(256, 12, "path: " + pf.getPathCost());
        else               StdDraw.text(256, 12, "no path found");
        StdDraw.text(512-96, 12, "searched: " + pf.getSearchSize() + " (" + (int)(100.0f * pf.getSearchSize() / (N*N)) + "%)");
    }
}

--[ 2019.10.31.02.48.23.321.0 ]--
InitFile: /P04_Pathfinding.iml
<?xml version="1.0" encoding="UTF-8"?>
<module type="JAVA_MODULE" version="4">
  <component name="NewModuleRootManager" inherit-compiler-output="true">
    <exclude-output />
    <content url="file://$MODULE_DIR$">
      <sourceFolder url="file://$MODULE_DIR$/src" isTestSource="false" />
      <sourceFolder url="file://$MODULE_DIR$/heightmaps" type="java-resource" />
      <excludeFolder url="file://$MODULE_DIR$/.log" />
    </content>
    <orderEntry type="inheritedJdk" />
    <orderEntry type="sourceFolder" forTests="false" />
    <orderEntry type="library" name="algs4" level="project" />
    <orderEntry type="library" name="stdlib" level="project" />
  </component>
</module>

--[ 2019.10.31.02.48.23.322.0 ]--
InitFile: /src/Coord.java
/**
 * Coordinates is an immutable type that store the tuple (i, j)
 */
public final class Coord {
    private final int i;
    private final int j;

    public Coord(int i, int j) {
        this.i = i;
        this.j = j;
    }

    public int getI() { return i; }
    public int getJ() { return j; }

    public boolean isInBounds(int minI, int minJ, int maxI, int maxJ) {
        return i >= minI && j >= minJ && i <= maxI && j <= maxJ;
    }
    public boolean isInBounds(Coord min, Coord max) {
        return i >= min.i && i <= max.i && j >= min.j && j <= max.j;
    }

    public Coord add(int addI, int addJ) {
        return new Coord(i + addI, j + addJ);
    }
    public Coord add(Coord that) { return new Coord(i + that.i, j + that.j); }

    public String toString() { return "(" + i + "," + j + ")"; }

    public boolean equals(Object o) {
        if(this == o) return true;
        if(o == null) return false;
        if(o.getClass() != this.getClass()) return false;
        Coord that = (Coord) o;
        if(this.i != that.i) return false;
        if(this.j != that.j) return false;
        return true;
    }
}

--[ 2019.10.31.02.48.23.323.0 ]--
InitFile: /src/Walker.java
import java.util.Iterator;

/**
 * Walker takes an Iterable of Coords and simulates an individual
 * walking along the path over the given Terrain
 */
public class Walker {

    // terrain: the Terrain the Walker traverses
    // path: the sequence of Coords the Walker follows
    public Walker(Terrain terrain, Iterable<Coord> path) {
    }

    // returns the Walker's current location
    public Coord getLocation() {
        return null;
    }

    // returns true if Walker has reached the end Coord (last in path)
    public boolean doneWalking() {
        return true;
    }

    // advances the Walker along path
    // byTime: how long the Walker should traverse (may be any non-negative value)
    public void advance(float byTime) {
    }

}

--[ 2019.10.31.02.48.23.323.1 ]--
InitFile: /src/TerrainEditor.java
/**
 * The following class provides some simple terrain editing functions.
 */
public class TerrainEditor {
    private static float rndRadius(float d) {
        return (float)StdRandom.uniform(-d,d);
    }

    private static float getFractalHeight(int i, int j, float dh, Terrain terrain, boolean[] isset) {
        int N = terrain.getN();
        dh = Math.max(-64, Math.min(255+64, dh));   // allow the height to go just a bit out of range
        if(!isset[i + j * N]) {
            isset[i + j * N] = true;
            terrain.setHeight(i, j, dh);
        }
        return terrain.getHeight(i,j);
    }

    private static void setFractalHeights(int i0, int j0, int i1, int j1, Terrain terrain, boolean[] isset) {
        int id = i1-i0;
        int jd = j1-j0;
        int i01 = (i0+i1)/2;
        int j01 = (j0+j1)/2;

        if(id <= 1 && jd <= 1) return;

        float h00 = getFractalHeight(i0,j0,32,terrain,isset);
        float h01 = getFractalHeight(i0,j1,32,terrain,isset);
        float h10 = getFractalHeight(i1,j0,32,terrain,isset);
        float h11 = getFractalHeight(i1,j1,32,terrain,isset);

        float d = (float)(Math.sqrt((i1-i0)*(i1-i0) + (j1-j0)*(j1-j0)) * 0.5);

        float d0001 = (h00 + h01) / 2 + rndRadius(d);
        float d0010 = (h00 + h10) / 2 + rndRadius(d);
        float d1101 = (h11 + h01) / 2 + rndRadius(d);
        float d1110 = (h11 + h10) / 2 + rndRadius(d);

        float h0001 = getFractalHeight(i0, j01, d0001, terrain,isset);
        float h0010 = getFractalHeight(i01, j0, d0010, terrain,isset);
        float h1101 = getFractalHeight(i01, j1, d1101, terrain,isset);
        float h1110 = getFractalHeight(i1, j01, d1110, terrain,isset);

        float dm = (float)((h0001 + h0010 + h1101 + h1110) / 4.0);
        float hm = getFractalHeight(i01, j01, dm, terrain,isset);

        if(id > 1 && jd > 1) {
            setFractalHeights(i0, j0, i01, j01, terrain, isset);
            setFractalHeights(i01, j0, i1, j01, terrain, isset);
            setFractalHeights(i0, j01, i01, j1, terrain, isset);
            setFractalHeights(i01, j01, i1, j1, terrain, isset);
        } else if(jd > 1) {
            setFractalHeights(i0, j0, i1, j01, terrain, isset);
            setFractalHeights(i0, j01, i1, j1, terrain, isset);
        } else {
            setFractalHeights(i0, j0, i01, j1, terrain, isset);
            setFractalHeights(i01, j0, i1, j1, terrain, isset);
        }
    }

    public static void setFractalHeights(Terrain terrain) {
        int N = terrain.getN();
        boolean[] isset = new boolean[N*N];
        setFractalHeights(0, 0, N - 1, N - 1, terrain, isset);
    }

    public static void smoothHeights(Terrain terrain) {
        int N = terrain.getN();
        int radius = (int)Math.ceil(Math.sqrt(N*N/2.0f));
        smoothHeights(N/2, N/2, radius, false, terrain);
    }

    public static void smoothHeights(int ic, int jc, int radius, boolean fallOff, Terrain terrain) {
        final int N = terrain.getN();
        final int w = 2*radius+1;
        float[] s = new float[w*w];
        for(int ia = -radius; ia <= radius; ia++) {
            int i = ic + ia;
            if(i < 0 || i >= N) continue;
            for(int ja = -radius; ja <= radius; ja++) {
                int j = jc + ja;
                if(j < 0 || j >= N) continue;
                int sidx = (ia+radius) + (ja+radius)*w;

                float m = computeEffect(i, j, ic, jc, radius, fallOff, N);
                if(m <= 0.0000001) {
                    s[sidx] = terrain.getHeight(i,j);
                    continue;
                }
                float h = 0;
                int c = 0;
                if(i > 0 && j > 0) {
                    h += terrain.getHeight(i-1,j-1);
                    c += 1;
                }
                if(i < N-1 && j > 0) {
                    h += terrain.getHeight(i+1,j-1);
                    c += 1;
                }
                if(i > 0 && j < N-1) {
                    h += terrain.getHeight(i-1,j+1);
                    c += 1;
                }
                if(i < N-1 && j < N-1) {
                    h += terrain.getHeight(i+1,j+1);
                    c += 1;
                }
                if(i > 0) {
                    h += terrain.getHeight(i-1,j);
                    c += 1;
                }
                if(j > 0) {
                    h += terrain.getHeight(i,j-1);
                    c += 1;
                }
                if(i < N-1) {
                    h += terrain.getHeight(i+1,j);
                    c += 1;
                }
                if(j < N-1) {
                    h += terrain.getHeight(i,j+1);
                    c += 1;
                }
                s[sidx] = (1-m) * terrain.getHeight(i,j) + m * h / c;
            }
        }
        for(int ia = -radius; ia <= radius; ia++) {
            int i = ic + ia;
            if(i < 0 || i >= N) continue;
            for(int ja = -radius; ja <= radius; ja++) {
                int j = jc + ja;
                if(j < 0 || j >= N) continue;
                int sidx = (ia+radius) + (ja+radius)*w;
                terrain.setHeight(i, j, s[sidx]);
            }
        }
    }

    public static void clampHeights(Terrain terrain) {
        int N = terrain.getN();
        for(int i = 0; i < N; i++) {
            for(int j = 0; j < N; j++) {
                terrain.setHeight(i, j, Math.max(0, Math.min(255, terrain.getHeight(i, j))));
            }
        }
    }

    private static float computeEffect(int i, int j, int ic, int jc, int radius, boolean fallOff, int N) {
        if(i < 0 || j < 0 || i >= N || j >= N) return 0;
        if(!fallOff) return 1;
        int d2 = (ic-i)*(ic-i)+(jc-j)*(jc-j);
        if(d2 > radius*radius) return 0;
        return ((float)radius - (float)Math.sqrt(d2)) / (float)radius;
    }

    public static void addHeight(int i, int j, int radius, float add, Terrain terrain) {
        final int N = terrain.getN();
        for(int ja = -radius; ja <= radius; ja++) {
            int r = j + ja;
            if(r < 0 || r >= N) continue;
            for(int ia = -radius; ia <= radius; ia++) {
                int c = i + ia;
                if(c < 0 || c >= N) continue;
                float v = add * computeEffect(c, r, i, j, radius, true, N);
                float h = terrain.getHeight(c, r) + v;
                h = Math.max(0, Math.min(255, h));
                terrain.setHeight(c, r, h);
            }
        }
    }
}

--[ 2019.10.31.02.48.23.324.0 ]--
InitFile: /src/Terrain.java
import java.lang.IndexOutOfBoundsException;

/**
 * Terrain stores elevations for map and computes distance and
 * cost in traversing the terrain.
 */

public class Terrain {
    private int N;
    private int[][] heights;

    public Terrain(int N) {
        this.N = N;
        this.heights = new int[N][N];
    }

    public Terrain(int[][] heights) {
        this.N = heights.length;
        this.heights = heights;
    }

    public Terrain(String emapfile) {
        In in = new In(emapfile);
        this.N = in.readInt();
        this.heights = new int[N][N];
        for (int j = 0; j < N; j++) {
            for (int i = 0; i < N; i++) {
                this.heights[i][j] = in.readInt();
            }
        }
    }

    public int getN() {
        return N;
    }

    public void setHeight(int i, int j, int h) {
        if(i < 0 || j < 0 || i >= N || j >= N)
            throw new IndexOutOfBoundsException("i and j must be in [0,N)");
        heights[i][j] = h;
    }
    public void setHeight(int i, int j, float h) {
        setHeight(i, j, (int) h);
    }
    public void setHeight(Coord loc, int h) {
        setHeight(loc.getI(), loc.getJ(), h);
    }
    public void setHeight(Coord loc, float h) {
        setHeight(loc.getI(), loc.getJ(), h);
    }

    public int getHeight(int i, int j) {
        if(i < 0 || j < 0 || i >= N || j >= N)
            throw new IndexOutOfBoundsException("i and j must be in [0,N)");
        return heights[i][j];
    }
    public int getHeight(Coord loc) {
        return getHeight(loc.getI(), loc.getJ());
    }

    // computes distance between (i0,j0) and (i1,j1) as the crow flies
    public float computeDistance(int i0, int j0, int i1, int j1) {
        return (float)Math.sqrt((i0 - i1) * (i0 - i1) + (j0 - j1) * (j0 - j1));
    }
    public float computeDistance(Coord c0, Coord c1) {
        return computeDistance(c0.getI(), c0.getJ(), c1.getI(), c1.getJ());
    }

    public float computeTravelCost(int i0, int j0, int i1, int j1) {
        float h0 = getHeight(i0, j0), h1 = getHeight(i1, j1);
        float climb = (float)Math.pow(Math.abs(h0 - h1) * 1000.0, 1.5);
        float dist = computeDistance(i0,j0, i1,j1);
        return (1.0f + climb) * dist;
    }
    public float computeTravelCost(Coord c0, Coord c1) {
        return computeTravelCost(c0.getI(), c0.getJ(), c1.getI(), c1.getJ());
    }
    public float computeTravelCost(Iterable<Coord> cs) {
        Coord c0 = null;
        float cost = 0.0f;
        for(Coord c1 : cs) {
            if(c0 != null) cost += computeTravelCost(c0, c1);
            c0 = c1;
        }
        return cost;
    }
}

--[ 2019.10.31.02.48.23.325.0 ]--
InitFile: /src/InteractivePathfinderVisualizer.java
import java.awt.event.KeyEvent;

/**
 * InteractivePathfinderVisualizer visualizes the terrain and the computed
 * path and allows the user to change parameters of the Pathfinder.  Below
 * is a list of commands and what they do.  Note: some of the commands
 * modify the properties of the path finder and some modify the terrain.
 *
 * Command        Action                                      Terrain
 * C              clear path
 * space          recompute path
 * S/E            set start/end location to mouse
 * left/right     halve/double path search heuristic value
 * 0/1            set path search heuristic to 0 or 1
 * W              start a walker to show the path
 * R              randomly generate a new terrain                *
 * M              smooths terrain under mouse                    *
 * shift+M        smooths all terrain                            *
 * up/down        increase/decrease terrain under mouse          *
 */

public class InteractivePathfinderVisualizer {
    private final static int DELAY = 10;

    // sets how many redraws it should take for the walker to reach its destination
    private final static float STEPS_TO_WALK = 100.0f;

    // for convenience, here are the emap files that are located under heightmaps/ folder
    // the python script in that folder converts png files to emap. \
    // you can use it to create your own maps to test your code
    private final static String[] emaps = {
            "maze32_0.png.emap",    // 0   (32x32 maze)
            "maze32_1.png.emap",    // 1   (another 32x32 maze)
            "maze232_0.png.emap",   // 2   (232x232 maze)
            "maze320_0.png.emap",   // 3   (same as maze32_0, only scaled up by 10x)
            "mazeAB.png.emap",      // 4   (a maze from a site no longer online :( )
            "mazeBrain.png.emap",   // 5   (...)
            "ramp.png.emap",        // 6   (some tests)
            "ramp2.png.emap",       // 7   (...)
            "ramp3.png.emap",       // 8   (...)
            "usa128.png.emap",      // 9   (elevation map of USA from https://bananas.openttd.org/en/heightmap/)
            "usa256.png.emap",      // 10  (same as usa128, only higher resolution)
            "usa1024.png.emap",     // 11  (same as usa128, only higher resolution
    };

    private final static String emapFilename = emaps[2];        // change index to load a different elevation map



    public static void main(String[] args) {
        Terrain terrain = new Terrain(emapFilename);
        Pathfinder pf = new Pathfinder(terrain);
        int N = terrain.getN();

        StdDraw.show(0);

        // set default starting and ending locations
        pf.setPathStart(new Coord(1, 1));
        pf.setPathEnd(new Coord(N-3, N-3));

        // find a path
        pf.computePath();

        PathfinderVisualizer.draw(terrain, pf, null, N);
        StdDraw.show(DELAY);

        // prevent repeated applications
        boolean keyboardR = false;
        boolean keyboardM = false;

        Walker walker = null;

        while(true) {
            boolean recompute = false;
            boolean redraw = false;

            // mouse location on map
            int mouseI = (int) ((StdDraw.mouseX()-24) / 464 * N);
            int mouseJ = (int) ((464 - (StdDraw.mouseY()-36)) / 464 * N);
            boolean isMouseOnMap = (mouseI >=0 && mouseI < N && mouseJ >= 0 && mouseJ < N);

            if(StdDraw.isKeyPressed(KeyEvent.VK_LEFT) || StdDraw.isKeyPressed(KeyEvent.VK_RIGHT)) {
                boolean keyboardLeft = StdDraw.isKeyPressed(KeyEvent.VK_LEFT);
                float m = keyboardLeft ? 0.5f : 2.0f;
                float h = pf.getHeuristic() * m;
                h = Math.max(1.0f/1024.0f, Math.min(1048576.0f, h));
                pf.setHeuristic(h);
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_0) || StdDraw.isKeyPressed(KeyEvent.VK_1)) {
                boolean keyboard0 = StdDraw.isKeyPressed(KeyEvent.VK_0);
                float h = keyboard0 ? 0 : 1;
                pf.setHeuristic(h);
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_C)) {
                pf.resetPath();
                walker = null;
                redraw = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_R) && !keyboardR) {
                TerrainEditor.setFractalHeights(terrain);
                TerrainEditor.clampHeights(terrain);
                recompute = true;
            }
            keyboardR = StdDraw.isKeyPressed(KeyEvent.VK_R);

            if(StdDraw.isKeyPressed(KeyEvent.VK_M)) {
                if(StdDraw.isKeyPressed(KeyEvent.VK_SHIFT)) {
                    if(!keyboardM) {
                        TerrainEditor.smoothHeights(terrain);
                        recompute = true;
                    }
                } else {
                    TerrainEditor.smoothHeights(mouseI, mouseJ, N / 20, true, terrain);
                    recompute = true;
                }
            }
            keyboardM = StdDraw.isKeyPressed(KeyEvent.VK_M);

            if(StdDraw.isKeyPressed(KeyEvent.VK_SPACE)) {
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_UP) || StdDraw.isKeyPressed(KeyEvent.VK_DOWN)) {
                boolean keyboardUp = StdDraw.isKeyPressed(KeyEvent.VK_UP);
                float add = keyboardUp ? 8.0f : -8.0f;
                TerrainEditor.addHeight(mouseI, mouseJ, N / 20, add, terrain);
                recompute = true;
            }

            if(isMouseOnMap && StdDraw.isKeyPressed(KeyEvent.VK_S)) {
                pf.setPathStart(new Coord(mouseI, mouseJ));
                recompute = true;
            }

            if(isMouseOnMap && StdDraw.isKeyPressed(KeyEvent.VK_E)) {
                pf.setPathEnd(new Coord(mouseI, mouseJ));
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_W)) {
                Iterable<Coord> path = pf.getPathSolution();
                if(path != null) {
                    walker = new Walker(terrain, pf.getPathSolution());
                }
            }

            if(walker != null) {
                if(walker.doneWalking()) {
                    walker = null;
                } else {
                    walker.advance(pf.getPathCost() / STEPS_TO_WALK);
                }
                redraw = true;
            }

            if(recompute) {
                walker = null;
                pf.resetPath();
                if(pf.getPathStart() != null && pf.getPathEnd() != null) {
                    pf.computePath();
                }
                redraw = true;
            }

            if(redraw) {
                PathfinderVisualizer.draw(terrain, pf, walker, N);
                StdDraw.show(DELAY);
            } else {
                try {
                    Thread.sleep(10);
                } catch (InterruptedException e) {
                    /* do nothing */
                }
            }
        }
    }
}

--[ 2019.10.31.02.48.23.326.0 ]--
InitFile: /src/Pathfinder.java
import java.lang.IndexOutOfBoundsException;
import java.lang.IllegalArgumentException;

/**
 * Pathfinder uses A* search to find a near optimal path
 * between to locations with given terrain.
 */

public class Pathfinder {
    private Coord end;
    private Coord start;
    private Terrain terrain;
    private float heur;
    private boolean pathFound = false;  //implement in compute path, set to true when found
    private int searchSize;
    private PFNode[][] board;

    /**
     * PFNode will be the key for MinPQ (used in computePath())
     */
    private class PFNode implements Comparable<PFNode> {
        private boolean isUsed;
        private boolean invalid;
        private Coord loc;
        private PFNode fromNode;
        // loc: the location of the PFNode
        // fromNode: how did we get here? (linked list back to start)

        public PFNode(Coord loc, PFNode fromNode) {
        }

        // compares this with that, used to find minimum cost PFNode
        public int compareTo(PFNode that) {
            //return PFNode.loc.compareTo(that); //help
            return 0;
        }

        // returns the cost to travel from starting point to this
        // via the fromNode chain
        public float getCost(float heuristic) {
            return 0;
        }

        // returns if this PFNode is not marked invalid
        public boolean isValid() {
            return invalid;
        }

        // marks the PFNode as invalid
        public void invalidate() {
            invalid = true;
        }

        // returns if the PFNode is marked as used
        public boolean isUsed() {
            return isUsed;
        }

        // marks the PFNode as used
        public void use() {
            isUsed = true;
        }

        // returns an Iterable of PFNodes that surround this
        public Iterable<PFNode> neighbors() {
            Stack<PFNode> s = new Stack<>();
            s.push(new PFNode(null, null));
            return s;
        }
    }

    public Pathfinder(Terrain terrain) {
        this.terrain = terrain;
    }

    public void setPathStart(Coord loc) {
        if(loc == null) throw new IllegalArgumentException("The location is null.");
        //if(!loc.isInBounds()) throw new IllegalArgumentException("The location is out of bounds.");
        start = loc;
    }

    public Coord getPathStart() {
        return start;
    }

    public void setPathEnd(Coord loc) {
        if(loc == null) throw new IllegalArgumentException("The location is null.");
        //if(!loc.isInBounds()) throw new IllegalArgumentException("The location is out of bounds.");
        end = loc;
    }

    public Coord getPathEnd() {
        return end;
    }

    public void setHeuristic(float v) { // is this correct?
        heur = v;
    }

    public float getHeuristic() {
        return heur;
    }

    public void resetPath() {
    }

    public void computePath() {
        if(getPathEnd() == null || getPathStart() == null) throw new IllegalArgumentException("Either or both of start path or end path have NOT been set.");

        //set up logic board with 2D array
        int N = terrain.getN();
        board = new PFNode[N][N];

        //set up Minimum Priority Queue
        MinPQ<PFNode> pq = new MinPQ<>();

        PFNode s = new PFNode(getPathStart(), null);
        board[getPathStart().getI()][getPathStart().getJ()] = s;
        pq.insert(s);
        while(!pathFound){
            //remove from pq
            PFNode removed = pq.delMin();
            //check if node is at end
            if(removed.loc == getPathEnd()){  //correct?
                pathFound = true;
                break;
            }
            //"process" node just removed
            //abcd
        }

        // later on put all the items from your fastest linked list into a stack to be read by the PathfinderVisualizer

    }

    public boolean foundPath() {
        return pathFound;
    }  //implement in compute path

    public float getPathCost() {
        return 0;
    }

    public int getSearchSize() {
        return searchSize;
    } //implement in compute path

    public Iterable<Coord> getPathSolution() {
        return null;
    }

    public boolean wasSearched(Coord loc) {
        return false;
    }

}

--[ 2019.10.31.02.48.23.327.0 ]--
InitFile: /.cos265


--[ 2019.10.31.02.50.38.823.0 ]--
:/src/Pathfinder.java
+ 129             
--[ 2019.10.31.02.51.25.744.0 ]--
r 129             b
--[ 2019.10.31.02.51.25.973.0 ]--
r 129             bo
--[ 2019.10.31.02.51.26.732.0 ]--
r 129             boa
--[ 2019.10.31.02.51.26.965.0 ]--
r 129             boar
--[ 2019.10.31.02.51.27.379.0 ]--
r 129             board
--[ 2019.10.31.02.51.29.806.0 ]--
r 129             board[]
--[ 2019.10.31.02.51.36.263.0 ]--
r 129             board[r]
--[ 2019.10.31.02.51.36.440.0 ]--
r 129             board[re]
--[ 2019.10.31.02.51.36.618.0 ]--
r 129             board[rem]
--[ 2019.10.31.02.51.36.714.0 ]--
r 129             board[remo]
--[ 2019.10.31.02.51.36.947.0 ]--
r 129             board[remov]
--[ 2019.10.31.02.51.37.160.0 ]--
r 129             board[remove]
--[ 2019.10.31.02.51.37.328.0 ]--
r 129             board[removed]
--[ 2019.10.31.02.51.37.457.0 ]--
r 129             board[removed.]
--[ 2019.10.31.02.51.38.506.0 ]--
r 129             board[removed.l]
--[ 2019.10.31.02.51.38.710.0 ]--
r 129             board[removed.lo]
--[ 2019.10.31.02.51.40.016.0 ]--
r 129             board[removed.loc]
--[ 2019.10.31.02.51.40.204.0 ]--
r 129             board[removed.loc.]
--[ 2019.10.31.02.51.41.101.0 ]--
r 129             board[removed.loc.g]
--[ 2019.10.31.02.51.41.268.0 ]--
r 129             board[removed.loc.ge]
--[ 2019.10.31.02.51.43.211.0 ]--
r 129             board[removed.loc.getI]
--[ 2019.10.31.02.51.43.228.0 ]--
r 129             board[removed.loc.getI()]
--[ 2019.10.31.02.51.46.183.0 ]--
r 129             board[removed.loc.getI()][]
--[ 2019.10.31.02.51.47.838.0 ]--
r 129             board[removed.loc.getI()][r]
--[ 2019.10.31.02.51.47.968.0 ]--
r 129             board[removed.loc.getI()][re]
--[ 2019.10.31.02.51.48.152.0 ]--
r 129             board[removed.loc.getI()][rem]
--[ 2019.10.31.02.51.48.245.0 ]--
r 129             board[removed.loc.getI()][remo]
--[ 2019.10.31.02.51.48.839.0 ]--
r 129             board[removed.loc.getI()][removed]
--[ 2019.10.31.02.51.49.907.0 ]--
r 129             board[removed.loc.getI()][removed.]
--[ 2019.10.31.02.51.52.624.0 ]--
r 129             board[removed.loc.getI()][removed.loc]
--[ 2019.10.31.02.51.54.007.0 ]--
r 129             board[removed.loc.getI()][removed.loc.]
--[ 2019.10.31.02.51.56.486.0 ]--
r 129             board[removed.loc.getI()][removed.loc.getJ]
--[ 2019.10.31.02.51.56.498.0 ]--
r 129             board[removed.loc.getI()][removed.loc.getJ()]
--[ 2019.10.31.02.52.47.753.0 ]--
r 129             iboard[removed.loc.getI()][removed.loc.getJ()]
--[ 2019.10.31.02.52.47.933.0 ]--
r 129             ifboard[removed.loc.getI()][removed.loc.getJ()]
--[ 2019.10.31.02.52.49.046.0 ]--
r 129             if(board[removed.loc.getI()][removed.loc.getJ()]
--[ 2019.10.31.02.52.51.361.0 ]--
r 129             if(board[removed.loc.getI()][removed.loc.getJ()].
--[ 2019.10.31.02.52.53.988.0 ]--
r 129             if(board[removed.loc.getI()][removed.loc.getJ()].i
--[ 2019.10.31.02.52.54.158.0 ]--
r 129             if(board[removed.loc.getI()][removed.loc.getJ()].is
--[ 2019.10.31.02.53.53.560.0 ]--
r 129             if(board[removed.loc.getI()][removed.loc.getJ()].i
--[ 2019.10.31.02.53.53.695.0 ]--
r 129             if(board[removed.loc.getI()][removed.loc.getJ()].
--[ 2019.10.31.02.53.55.702.0 ]--
r 129             if(board[removed.loc.getI()][removed.loc.getJ()]
--[ 2019.10.31.02.53.59.000.0 ]--
r 129             ifboard[removed.loc.getI()][removed.loc.getJ()]
--[ 2019.10.31.02.53.59.502.0 ]--
r 129             iboard[removed.loc.getI()][removed.loc.getJ()]
--[ 2019.10.31.02.53.59.986.0 ]--
r 129             board[removed.loc.getI()][removed.loc.getJ()]
--[ 2019.10.31.02.58.07.121.0 ]--
+ 129             
--[ 2019.10.31.02.58.07.545.0 ]--
r 129             /
--[ 2019.10.31.02.58.07.661.0 ]--
r 129             //
--[ 2019.10.31.02.58.08.915.0 ]--
r 129             //s
--[ 2019.10.31.02.58.09.072.0 ]--
r 129             //se
--[ 2019.10.31.02.58.09.238.0 ]--
r 129             //see
--[ 2019.10.31.02.58.09.473.0 ]--
r 129             //see 
--[ 2019.10.31.02.58.09.640.0 ]--
r 129             //see i
--[ 2019.10.31.02.58.09.765.0 ]--
r 129             //see if
--[ 2019.10.31.02.58.10.522.0 ]--
r 129             //see if 
--[ 2019.10.31.02.58.10.763.0 ]--
r 129             //see if t
--[ 2019.10.31.02.58.10.829.0 ]--
r 129             //see if th
--[ 2019.10.31.02.58.10.931.0 ]--
r 129             //see if the
--[ 2019.10.31.02.58.11.022.0 ]--
r 129             //see if the 
--[ 2019.10.31.02.58.11.981.0 ]--
r 129             //see if the l
--[ 2019.10.31.02.58.12.176.0 ]--
r 129             //see if the lo
--[ 2019.10.31.02.58.12.305.0 ]--
r 129             //see if the loc
--[ 2019.10.31.02.58.12.409.0 ]--
r 129             //see if the loca
--[ 2019.10.31.02.58.12.716.0 ]--
r 129             //see if the locat
--[ 2019.10.31.02.58.12.866.0 ]--
r 129             //see if the locati
--[ 2019.10.31.02.58.12.963.0 ]--
r 129             //see if the locatio
--[ 2019.10.31.02.58.13.080.0 ]--
r 129             //see if the location
--[ 2019.10.31.02.58.13.251.0 ]--
r 129             //see if the locations
--[ 2019.10.31.02.58.13.461.0 ]--
r 129             //see if the locations 
--[ 2019.10.31.02.58.13.782.0 ]--
r 129             //see if the locations a
--[ 2019.10.31.02.58.14.330.0 ]--
r 129             //see if the locations ar
--[ 2019.10.31.02.58.14.389.0 ]--
r 129             //see if the locations aro
--[ 2019.10.31.02.58.14.520.0 ]--
r 129             //see if the locations arou
--[ 2019.10.31.02.58.14.659.0 ]--
r 129             //see if the locations aroun
--[ 2019.10.31.02.58.14.898.0 ]--
r 129             //see if the locations around
--[ 2019.10.31.02.58.15.070.0 ]--
r 129             //see if the locations around 
--[ 2019.10.31.02.58.15.391.0 ]--
r 129             //see if the locations around t
--[ 2019.10.31.02.58.15.446.0 ]--
r 129             //see if the locations around th
--[ 2019.10.31.02.58.15.556.0 ]--
r 129             //see if the locations around the
--[ 2019.10.31.02.58.15.691.0 ]--
r 129             //see if the locations around the 
--[ 2019.10.31.02.58.18.729.0 ]--
r 129             //see if the locations around the r
--[ 2019.10.31.02.58.18.859.0 ]--
r 129             //see if the locations around the re
--[ 2019.10.31.02.58.19.070.0 ]--
r 129             //see if the locations around the rem
--[ 2019.10.31.02.58.19.181.0 ]--
r 129             //see if the locations around the remo
--[ 2019.10.31.02.58.19.436.0 ]--
r 129             //see if the locations around the remov
--[ 2019.10.31.02.58.19.602.0 ]--
r 129             //see if the locations around the remove
--[ 2019.10.31.02.58.19.811.0 ]--
r 129             //see if the locations around the removed
--[ 2019.10.31.02.58.19.972.0 ]--
r 129             //see if the locations around the removed 
--[ 2019.10.31.02.58.20.122.0 ]--
r 129             //see if the locations around the removed p
--[ 2019.10.31.02.58.20.287.0 ]--
r 129             //see if the locations around the removed po
--[ 2019.10.31.02.58.20.458.0 ]--
r 129             //see if the locations around the removed pos
--[ 2019.10.31.02.58.21.088.0 ]--
r 129             //see if the locations around the removed posi
--[ 2019.10.31.02.58.21.242.0 ]--
r 129             //see if the locations around the removed posit
--[ 2019.10.31.02.58.21.371.0 ]--
r 129             //see if the locations around the removed positi
--[ 2019.10.31.02.58.21.484.0 ]--
r 129             //see if the locations around the removed positio
--[ 2019.10.31.02.58.21.556.0 ]--
r 129             //see if the locations around the removed position
--[ 2019.10.31.02.58.21.961.0 ]--
r 129             //see if the locations around the removed positions
--[ 2019.10.31.02.58.22.356.0 ]--
r 129             //see if the locations around the removed position
--[ 2019.10.31.02.58.22.636.0 ]--
r 129             //see if the locations around the removed position 
--[ 2019.10.31.02.58.22.726.0 ]--
r 129             //see if the locations around the removed position a
--[ 2019.10.31.02.58.22.840.0 ]--
r 129             //see if the locations around the removed position ar
--[ 2019.10.31.02.58.22.979.0 ]--
r 129             //see if the locations around the removed position are
--[ 2019.10.31.02.58.23.162.0 ]--
r 129             //see if the locations around the removed position are 
--[ 2019.10.31.02.58.23.533.0 ]--
r 129             //see if the locations around the removed position are i
--[ 2019.10.31.02.58.23.624.0 ]--
r 129             //see if the locations around the removed position are in
--[ 2019.10.31.02.58.23.916.0 ]--
r 129             //see if the locations around the removed position are in 
--[ 2019.10.31.02.58.24.126.0 ]--
r 129             //see if the locations around the removed position are in b
--[ 2019.10.31.02.58.24.224.0 ]--
r 129             //see if the locations around the removed position are in bo
--[ 2019.10.31.02.58.24.342.0 ]--
r 129             //see if the locations around the removed position are in bou
--[ 2019.10.31.02.58.24.480.0 ]--
r 129             //see if the locations around the removed position are in boun
--[ 2019.10.31.02.58.24.864.0 ]--
r 129             //see if the locations around the removed position are in bound
--[ 2019.10.31.02.58.24.945.0 ]--
r 129             //see if the locations around the removed position are in bounds
--[ 2019.10.31.02.58.25.475.0 ]--
+ 130             
--[ 2019.10.31.02.58.28.754.0 ]--
r 130             /
--[ 2019.10.31.02.58.28.875.0 ]--
r 130             //
--[ 2019.10.31.02.58.29.686.0 ]--
r 130             //n
--[ 2019.10.31.02.58.29.765.0 ]--
r 130             //no
--[ 2019.10.31.02.58.29.900.0 ]--
r 130             //now
--[ 2019.10.31.02.58.30.061.0 ]--
r 130             //now 
--[ 2019.10.31.02.58.34.154.0 ]--
r 130             //now h
--[ 2019.10.31.02.58.34.307.0 ]--
r 130             //now ha
--[ 2019.10.31.02.58.34.474.0 ]--
r 130             //now hav
--[ 2019.10.31.02.58.34.582.0 ]--
r 130             //now have
--[ 2019.10.31.02.58.34.688.0 ]--
r 130             //now have 
--[ 2019.10.31.02.58.34.847.0 ]--
r 130             //now have t
--[ 2019.10.31.02.58.34.926.0 ]--
r 130             //now have th
--[ 2019.10.31.02.58.35.039.0 ]--
r 130             //now have the
--[ 2019.10.31.02.58.35.182.0 ]--
r 130             //now have them
--[ 2019.10.31.02.58.35.402.0 ]--
r 130             //now have them 
--[ 2019.10.31.02.58.36.055.0 ]--
r 130             //now have them p
--[ 2019.10.31.02.58.36.144.0 ]--
r 130             //now have them po
--[ 2019.10.31.02.58.36.383.0 ]--
r 130             //now have them poi
--[ 2019.10.31.02.58.36.462.0 ]--
r 130             //now have them poin
--[ 2019.10.31.02.58.36.656.0 ]--
r 130             //now have them point
--[ 2019.10.31.02.58.36.816.0 ]--
r 130             //now have them point 
--[ 2019.10.31.02.58.43.469.0 ]--
r 130             //now have them point t
--[ 2019.10.31.02.58.43.559.0 ]--
r 130             //now have them point to
--[ 2019.10.31.02.58.43.664.0 ]--
r 130             //now have them point to 
--[ 2019.10.31.02.58.45.548.0 ]--
r 130             //now have them point to r
--[ 2019.10.31.02.58.45.677.0 ]--
r 130             //now have them point to re
--[ 2019.10.31.02.58.45.845.0 ]--
r 130             //now have them point to rem
--[ 2019.10.31.02.58.45.992.0 ]--
r 130             //now have them point to remo
--[ 2019.10.31.02.58.46.183.0 ]--
r 130             //now have them point to remov
--[ 2019.10.31.02.58.46.360.0 ]--
r 130             //now have them point to remove
--[ 2019.10.31.02.58.46.634.0 ]--
r 130             //now have them point to removed
--[ 2019.10.31.02.58.47.411.0 ]--
r 130             //now have them point to removed,
--[ 2019.10.31.02.58.47.509.0 ]--
r 130             //now have them point to removed, 
--[ 2019.10.31.02.58.48.349.0 ]--
r 130             //now have them point to removed, "
--[ 2019.10.31.02.58.48.896.0 ]--
r 130             //now have them point to removed, "r
--[ 2019.10.31.02.58.49.548.0 ]--
r 130             //now have them point to removed, "
--[ 2019.10.31.02.58.49.732.0 ]--
r 130             //now have them point to removed, "f
--[ 2019.10.31.02.58.49.885.0 ]--
r 130             //now have them point to removed, "fr
--[ 2019.10.31.02.58.50.006.0 ]--
r 130             //now have them point to removed, "fro
--[ 2019.10.31.02.58.50.120.0 ]--
r 130             //now have them point to removed, "from
--[ 2019.10.31.02.58.51.019.0 ]--
r 130             //now have them point to removed, "from 
--[ 2019.10.31.02.58.51.111.0 ]--
r 130             //now have them point to removed, "from =
--[ 2019.10.31.02.58.51.236.0 ]--
r 130             //now have them point to removed, "from = 
--[ 2019.10.31.02.58.53.074.0 ]--
r 130             //now have them point to removed, "from = s
--[ 2019.10.31.02.58.53.307.0 ]--
r 130             //now have them point to removed, "from = s"
--[ 2019.10.31.02.58.54.374.0 ]--
r 130             //now have them point to removed, "from = s
--[ 2019.10.31.02.58.54.530.0 ]--
r 130             //now have them point to removed, "from = 
--[ 2019.10.31.02.58.55.153.0 ]--
r 130             //now have them point to removed, "from = r
--[ 2019.10.31.02.58.55.299.0 ]--
r 130             //now have them point to removed, "from = re
--[ 2019.10.31.02.58.55.491.0 ]--
r 130             //now have them point to removed, "from = rem
--[ 2019.10.31.02.58.55.608.0 ]--
r 130             //now have them point to removed, "from = remo
--[ 2019.10.31.02.58.55.800.0 ]--
r 130             //now have them point to removed, "from = remov
--[ 2019.10.31.02.58.55.957.0 ]--
r 130             //now have them point to removed, "from = remove
--[ 2019.10.31.02.58.56.328.0 ]--
r 130             //now have them point to removed, "from = removed
--[ 2019.10.31.02.58.57.014.0 ]--
r 130             //now have them point to removed, "from = removed"
--[ 2019.10.31.02.58.57.925.0 ]--
r 130             //now have them point to removed, "from = removed";
--[ 2019.10.31.02.58.59.748.0 ]--
r 130             //now have them point to removed, "from = removed"; 
--[ 2019.10.31.02.58.59.973.0 ]--
r 130             //now have them point to removed, "from = removed";  
--[ 2019.10.31.02.59.00.261.0 ]--
r 130             //now have them point to removed, "from = removed";  ?
--[ 2019.11.06.20.23.28.826.0 ]--
NewLogger: P04_Pathfinding
Version: 1.3
--[ 2019.11.06.20.23.28.970.0 ]--
InitTree:
/out/production/P04_Pathfinding/.donotlog
/out/production/P04_Pathfinding/algs4.jar
/out/production/P04_Pathfinding/stdlib.jar
/out/production/P04_Pathfinding/Coord.class
/out/production/P04_Pathfinding/png2emap.py
/out/production/P04_Pathfinding/Walker.class
/out/production/P04_Pathfinding/ramp.png.emap
/out/production/P04_Pathfinding/Terrain.class
/out/production/P04_Pathfinding/ramp2.png.emap
/out/production/P04_Pathfinding/ramp3.png.emap
/out/production/P04_Pathfinding/mazeAB.png.emap
/out/production/P04_Pathfinding/usa128.png.emap
/out/production/P04_Pathfinding/usa256.png.emap
/out/production/P04_Pathfinding/Pathfinder.class
/out/production/P04_Pathfinding/usa1024.png.emap
/out/production/P04_Pathfinding/maze32_0.png.emap
/out/production/P04_Pathfinding/maze32_1.png.emap
/out/production/P04_Pathfinding/maze232_0.png.emap
/out/production/P04_Pathfinding/maze320_0.png.emap
/out/production/P04_Pathfinding/mazeBrain.png.emap
/out/production/P04_Pathfinding/TerrainEditor.class
/out/production/P04_Pathfinding/Pathfinder$PFNode.class
/out/production/P04_Pathfinding/PathfinderVisualizer.class
/out/production/P04_Pathfinding/InteractivePathfinderVisualizer.class
/src/algs4.jar
/src/Coord.java
/src/stdlib.jar
/src/Walker.java
/src/Terrain.java
/src/Pathfinder.java
/src/TerrainEditor.java
/src/PathfinderVisualizer.java
/src/InteractivePathfinderVisualizer.java
/.log/history.log
/.idea/copyright/profiles_settings.xml
/.idea/libraries/algs4.xml
/.idea/libraries/stdlib.xml
/.idea/.name
/.idea/misc.xml
/.idea/modules.xml
/.idea/compiler.xml
/.idea/workspace.xml
/.idea/uiDesigner.xml
/heightmaps/.donotlog
/heightmaps/png2emap.py
/heightmaps/ramp.png.emap
/heightmaps/ramp2.png.emap
/heightmaps/ramp3.png.emap
/heightmaps/mazeAB.png.emap
/heightmaps/usa128.png.emap
/heightmaps/usa256.png.emap
/heightmaps/usa1024.png.emap
/heightmaps/maze32_0.png.emap
/heightmaps/maze32_1.png.emap
/heightmaps/maze232_0.png.emap
/heightmaps/maze320_0.png.emap
/heightmaps/mazeBrain.png.emap
/.cos265
/readme.html
/P04_Pathfinding.iml

--[ 2019.11.06.20.23.28.971.0 ]--
InitFile: /src/PathfinderVisualizer.java
/**
 * PathfinderVisualizer visualizes the terrain and found path.
 */

import java.awt.Color;
import java.awt.Font;

public class PathfinderVisualizer {

    // delay in milliseconds (controls animation speed)
    private final static int DELAY = 100;

    // color for different elevations.  must be in ascending order!
    private final static int[][] elevationColors = {
            // h    r   g   b   where h=height, r=red, g=green, b=blue
            {  0,   0,  0,  0},
            {  2,   0,  0,160},
            {  4,   0,224,224},
            { 16, 192,192,  0},
            { 64,  16,255, 16},
            {128,  32,224, 32},
            {192, 128,128,  8},
            {224, 164,164,164},
            {255, 255,255,255}
    };

    private final static Color cStart    = new Color(128, 128, 255);
    private final static Color cEnd      = new Color(255, 128, 128);
    private final static Color cSolution = new Color(255, 128, 255);
    private final static Color cSearched = new Color(128,   0, 128);

    // linearly interpolating between the corresponding rgb values
    private static Color colorLERP(float v1, int r0, int g0, int b0, int r1, int g1, int b1) {
        v1 = Math.max(0.0f, Math.min(1.0f, v1));
        float v0 = 1.0f - v1;
        int r = (int)(v0 * r0 + v1 * r1);
        int g = (int)(v0 * g0 + v1 * g1);
        int b = (int)(v0 * b0 + v1 * b1);
        return new Color(r, g, b);
    }
    private static Color colorLERP(float v1, Color c0, Color c1) {
        v1 = Math.max(0.0f, Math.min(1.0f, v1));
        float v0 = 1.0f - v1;
        int r = (int)(v0 * c0.getRed()   + v1 * c1.getRed());
        int g = (int)(v0 * c0.getGreen() + v1 * c1.getGreen());
        int b = (int)(v0 * c0.getBlue()  + v1 * c1.getBlue());
        int a = (int)(v0 * c0.getAlpha() + v1 * c1.getAlpha());
        return new Color(r, g, b, a);
    }

    // returns color for given height
    private static Color height2Color(int h) {
        h = Math.max(0, Math.min(255, h));

        int[] ec0 = elevationColors[0];  // default lower bound
        int[] ec1 = elevationColors[1];  // default upper bound

        // find upper bound while updating lower bound
        for(int i = 1; i < elevationColors.length; i++) {
            ec1 = elevationColors[i];
            if(h >= ec0[0] && h <= ec1[0]) break;
            ec0 = ec1;
        }

        int h0=ec0[0], r0=ec0[1], g0=ec0[2], b0=ec0[3];
        int h1=ec1[0], r1=ec1[1], g1=ec1[2], b1=ec1[3];
        float v1 = ((float)(h - h0)) / ((float)(h1 - h0));

        return colorLERP(v1, r0, g0, b0, r1, g1, b1);
    }

    private static void drawCircle(int i, int j, int N, double rad) {
        int c = (int)((i+0.5f) * 464.0f / N);
        int r = (int)((j+0.5f) * 464.0f / N);
        StdDraw.circle(c + 24, 464 - r + 36, rad);
    }
    public static void drawCircle(Coord loc, int N, double rad) {
        drawCircle(loc.getI(), loc.getJ(), N, rad);
    }

    private static void drawPath(Iterable<Coord> path, int N) {
        boolean first = true;
        int c0 = 0, r0 = 0;
        for (Coord loc : path) {
            int c1 = (int)((loc.getI()+0.5f) * 464.0f / N);
            int r1 = (int)((loc.getJ()+0.5f) * 464.0f / N);
            if(!first) {
                StdDraw.line(c0 + 24, 464 - r0 + 36, c1 + 24, 464 - r1 + 36);
            }
            first = false;
            c0 = c1; r0 = r1;
        }
    }

    // draw N-by-N pathfinding map
    public static void draw(Terrain terrain, Pathfinder pf, Walker walker, int N) {
        StdDraw.clear();
        StdDraw.setXscale(0, 512);
        StdDraw.setYscale(0, 512);
        StdDraw.setPenColor(StdDraw.BLACK);
        StdDraw.filledSquare(256, 256 + 12, 464 / 2);

        // draw terrain
        for(int row = 0; row < 464; row++) {
            int j = (int)((float)row/464.0f * N);
            for(int col = 0; col < 464; col++) {
                int i = (int)((float)col/464.0f * N);
                Coord loc = new Coord(i,j);
                Color c = height2Color(terrain.getHeight(loc));
                if(pf.wasSearched(loc)) {
                    c = colorLERP(0.50f, c, cSearched);
                }
                StdDraw.setPenColor(c);
                StdDraw.filledSquare(col + 24, 464 - row + 36, 1);
            }
        }

        // draw path start
        if(pf.getPathStart() != null) {
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            drawCircle(pf.getPathStart(), N, 4.0);

            StdDraw.setPenColor(cStart);
            StdDraw.setPenRadius(0.002);
            drawCircle(pf.getPathStart(), N, 4.0);
        }

        // draw path end
        if(pf.getPathEnd() != null) {
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            drawCircle(pf.getPathEnd(), N, 4.0);

            StdDraw.setPenColor(cEnd);
            StdDraw.setPenRadius(0.002);
            drawCircle(pf.getPathEnd(), N, 4.0);
        }

        // draw found path
        if(pf.foundPath()) {
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            drawPath(pf.getPathSolution(), N);

            StdDraw.setPenColor(cSolution);
            StdDraw.setPenRadius(0.002);
            drawPath(pf.getPathSolution(), N);
        }

        // draw walker
        if(walker != null) {
            Coord loc = walker.getLocation();
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            PathfinderVisualizer.drawCircle(loc, N, 2.0);

            StdDraw.setPenColor(StdDraw.WHITE);
            StdDraw.setPenRadius(0.002);
            PathfinderVisualizer.drawCircle(loc, N, 2.0);
        }

        // write status text
        StdDraw.setFont(new Font("SansSerif", Font.PLAIN, 12));
        StdDraw.setPenColor(StdDraw.BLACK);
        StdDraw.text(96, 12, "heuristic: " + pf.getHeuristic());
        if(pf.foundPath()) StdDraw.text(256, 12, "path: " + pf.getPathCost());
        else               StdDraw.text(256, 12, "no path found");
        StdDraw.text(512-96, 12, "searched: " + pf.getSearchSize() + " (" + (int)(100.0f * pf.getSearchSize() / (N*N)) + "%)");
    }
}

--[ 2019.11.06.20.23.28.973.0 ]--
InitFile: /P04_Pathfinding.iml
<?xml version="1.0" encoding="UTF-8"?>
<module type="JAVA_MODULE" version="4">
  <component name="NewModuleRootManager" inherit-compiler-output="true">
    <exclude-output />
    <content url="file://$MODULE_DIR$">
      <sourceFolder url="file://$MODULE_DIR$/src" isTestSource="false" />
      <sourceFolder url="file://$MODULE_DIR$/heightmaps" type="java-resource" />
      <excludeFolder url="file://$MODULE_DIR$/.log" />
    </content>
    <orderEntry type="inheritedJdk" />
    <orderEntry type="sourceFolder" forTests="false" />
    <orderEntry type="library" name="algs4" level="project" />
    <orderEntry type="library" name="stdlib" level="project" />
  </component>
</module>

--[ 2019.11.06.20.23.28.973.1 ]--
InitFile: /src/Coord.java
/**
 * Coordinates is an immutable type that store the tuple (i, j)
 */
public final class Coord {
    private final int i;
    private final int j;

    public Coord(int i, int j) {
        this.i = i;
        this.j = j;
    }

    public int getI() { return i; }
    public int getJ() { return j; }

    public boolean isInBounds(int minI, int minJ, int maxI, int maxJ) {
        return i >= minI && j >= minJ && i <= maxI && j <= maxJ;
    }
    public boolean isInBounds(Coord min, Coord max) {
        return i >= min.i && i <= max.i && j >= min.j && j <= max.j;
    }

    public Coord add(int addI, int addJ) {
        return new Coord(i + addI, j + addJ);
    }
    public Coord add(Coord that) { return new Coord(i + that.i, j + that.j); }

    public String toString() { return "(" + i + "," + j + ")"; }

    public boolean equals(Object o) {
        if(this == o) return true;
        if(o == null) return false;
        if(o.getClass() != this.getClass()) return false;
        Coord that = (Coord) o;
        if(this.i != that.i) return false;
        if(this.j != that.j) return false;
        return true;
    }
}

--[ 2019.11.06.20.23.28.974.0 ]--
InitFile: /src/Walker.java
import java.util.Iterator;

/**
 * Walker takes an Iterable of Coords and simulates an individual
 * walking along the path over the given Terrain
 */
public class Walker {
    private Terrain terrain;
    private Iterable<Coord> path;
    private boolean finishedWalking = false;

    // terrain: the Terrain the Walker traverses
    // path: the sequence of Coords the Walker follows
    public Walker(Terrain terrain, Iterable<Coord> path) {
        this.terrain = terrain;
        this.path = path;
    }

    // returns the Walker's current location
    public Coord getLocation() {
        //Stack<Coord> s = new Stack<>();
        return null;
    }

    // returns true if Walker has reached the end Coord (last in path)
    public boolean doneWalking() {
        return finishedWalking;
    }

    // advances the Walker along path
    // byTime: how long the Walker should traverse (may be any non-negative value)
    public void advance(float byTime) {
    }

}
//compute travel cost to know how long it takes to go to each spot
//start walker at first coord
//getlocation always calls beginning until advance is called
//when advance is caled, move walker to next thing in iterable


//byTime take into account travel cost
//keep track of how many times advance is called and then compare that to the travel cost.

--[ 2019.11.06.20.23.28.975.0 ]--
InitFile: /src/TerrainEditor.java
/**
 * The following class provides some simple terrain editing functions.
 */
public class TerrainEditor {
    private static float rndRadius(float d) {
        return (float)StdRandom.uniform(-d,d);
    }

    private static float getFractalHeight(int i, int j, float dh, Terrain terrain, boolean[] isset) {
        int N = terrain.getN();
        dh = Math.max(-64, Math.min(255+64, dh));   // allow the height to go just a bit out of range
        if(!isset[i + j * N]) {
            isset[i + j * N] = true;
            terrain.setHeight(i, j, dh);
        }
        return terrain.getHeight(i,j);
    }

    private static void setFractalHeights(int i0, int j0, int i1, int j1, Terrain terrain, boolean[] isset) {
        int id = i1-i0;
        int jd = j1-j0;
        int i01 = (i0+i1)/2;
        int j01 = (j0+j1)/2;

        if(id <= 1 && jd <= 1) return;

        float h00 = getFractalHeight(i0,j0,32,terrain,isset);
        float h01 = getFractalHeight(i0,j1,32,terrain,isset);
        float h10 = getFractalHeight(i1,j0,32,terrain,isset);
        float h11 = getFractalHeight(i1,j1,32,terrain,isset);

        float d = (float)(Math.sqrt((i1-i0)*(i1-i0) + (j1-j0)*(j1-j0)) * 0.5);

        float d0001 = (h00 + h01) / 2 + rndRadius(d);
        float d0010 = (h00 + h10) / 2 + rndRadius(d);
        float d1101 = (h11 + h01) / 2 + rndRadius(d);
        float d1110 = (h11 + h10) / 2 + rndRadius(d);

        float h0001 = getFractalHeight(i0, j01, d0001, terrain,isset);
        float h0010 = getFractalHeight(i01, j0, d0010, terrain,isset);
        float h1101 = getFractalHeight(i01, j1, d1101, terrain,isset);
        float h1110 = getFractalHeight(i1, j01, d1110, terrain,isset);

        float dm = (float)((h0001 + h0010 + h1101 + h1110) / 4.0);
        float hm = getFractalHeight(i01, j01, dm, terrain,isset);

        if(id > 1 && jd > 1) {
            setFractalHeights(i0, j0, i01, j01, terrain, isset);
            setFractalHeights(i01, j0, i1, j01, terrain, isset);
            setFractalHeights(i0, j01, i01, j1, terrain, isset);
            setFractalHeights(i01, j01, i1, j1, terrain, isset);
        } else if(jd > 1) {
            setFractalHeights(i0, j0, i1, j01, terrain, isset);
            setFractalHeights(i0, j01, i1, j1, terrain, isset);
        } else {
            setFractalHeights(i0, j0, i01, j1, terrain, isset);
            setFractalHeights(i01, j0, i1, j1, terrain, isset);
        }
    }

    public static void setFractalHeights(Terrain terrain) {
        int N = terrain.getN();
        boolean[] isset = new boolean[N*N];
        setFractalHeights(0, 0, N - 1, N - 1, terrain, isset);
    }

    public static void smoothHeights(Terrain terrain) {
        int N = terrain.getN();
        int radius = (int)Math.ceil(Math.sqrt(N*N/2.0f));
        smoothHeights(N/2, N/2, radius, false, terrain);
    }

    public static void smoothHeights(int ic, int jc, int radius, boolean fallOff, Terrain terrain) {
        final int N = terrain.getN();
        final int w = 2*radius+1;
        float[] s = new float[w*w];
        for(int ia = -radius; ia <= radius; ia++) {
            int i = ic + ia;
            if(i < 0 || i >= N) continue;
            for(int ja = -radius; ja <= radius; ja++) {
                int j = jc + ja;
                if(j < 0 || j >= N) continue;
                int sidx = (ia+radius) + (ja+radius)*w;

                float m = computeEffect(i, j, ic, jc, radius, fallOff, N);
                if(m <= 0.0000001) {
                    s[sidx] = terrain.getHeight(i,j);
                    continue;
                }
                float h = 0;
                int c = 0;
                if(i > 0 && j > 0) {
                    h += terrain.getHeight(i-1,j-1);
                    c += 1;
                }
                if(i < N-1 && j > 0) {
                    h += terrain.getHeight(i+1,j-1);
                    c += 1;
                }
                if(i > 0 && j < N-1) {
                    h += terrain.getHeight(i-1,j+1);
                    c += 1;
                }
                if(i < N-1 && j < N-1) {
                    h += terrain.getHeight(i+1,j+1);
                    c += 1;
                }
                if(i > 0) {
                    h += terrain.getHeight(i-1,j);
                    c += 1;
                }
                if(j > 0) {
                    h += terrain.getHeight(i,j-1);
                    c += 1;
                }
                if(i < N-1) {
                    h += terrain.getHeight(i+1,j);
                    c += 1;
                }
                if(j < N-1) {
                    h += terrain.getHeight(i,j+1);
                    c += 1;
                }
                s[sidx] = (1-m) * terrain.getHeight(i,j) + m * h / c;
            }
        }
        for(int ia = -radius; ia <= radius; ia++) {
            int i = ic + ia;
            if(i < 0 || i >= N) continue;
            for(int ja = -radius; ja <= radius; ja++) {
                int j = jc + ja;
                if(j < 0 || j >= N) continue;
                int sidx = (ia+radius) + (ja+radius)*w;
                terrain.setHeight(i, j, s[sidx]);
            }
        }
    }

    public static void clampHeights(Terrain terrain) {
        int N = terrain.getN();
        for(int i = 0; i < N; i++) {
            for(int j = 0; j < N; j++) {
                terrain.setHeight(i, j, Math.max(0, Math.min(255, terrain.getHeight(i, j))));
            }
        }
    }

    private static float computeEffect(int i, int j, int ic, int jc, int radius, boolean fallOff, int N) {
        if(i < 0 || j < 0 || i >= N || j >= N) return 0;
        if(!fallOff) return 1;
        int d2 = (ic-i)*(ic-i)+(jc-j)*(jc-j);
        if(d2 > radius*radius) return 0;
        return ((float)radius - (float)Math.sqrt(d2)) / (float)radius;
    }

    public static void addHeight(int i, int j, int radius, float add, Terrain terrain) {
        final int N = terrain.getN();
        for(int ja = -radius; ja <= radius; ja++) {
            int r = j + ja;
            if(r < 0 || r >= N) continue;
            for(int ia = -radius; ia <= radius; ia++) {
                int c = i + ia;
                if(c < 0 || c >= N) continue;
                float v = add * computeEffect(c, r, i, j, radius, true, N);
                float h = terrain.getHeight(c, r) + v;
                h = Math.max(0, Math.min(255, h));
                terrain.setHeight(c, r, h);
            }
        }
    }
}

--[ 2019.11.06.20.23.28.976.0 ]--
InitFile: /src/Terrain.java
import java.lang.IndexOutOfBoundsException;

/**
 * Terrain stores elevations for map and computes distance and
 * cost in traversing the terrain.
 */

public class Terrain {
    private int N;
    private int[][] heights;

    public Terrain(int N) {
        this.N = N;
        this.heights = new int[N][N];
    }

    public Terrain(int[][] heights) {
        this.N = heights.length;
        this.heights = heights;
    }

    public Terrain(String emapfile) {
        In in = new In(emapfile);
        this.N = in.readInt();
        this.heights = new int[N][N];
        for (int j = 0; j < N; j++) {
            for (int i = 0; i < N; i++) {
                this.heights[i][j] = in.readInt();
            }
        }
    }

    public int getN() {
        return N;
    }

    public void setHeight(int i, int j, int h) {
        if(i < 0 || j < 0 || i >= N || j >= N)
            throw new IndexOutOfBoundsException("i and j must be in [0,N)");
        heights[i][j] = h;
    }
    public void setHeight(int i, int j, float h) {
        setHeight(i, j, (int) h);
    }
    public void setHeight(Coord loc, int h) {
        setHeight(loc.getI(), loc.getJ(), h);
    }
    public void setHeight(Coord loc, float h) {
        setHeight(loc.getI(), loc.getJ(), h);
    }

    public int getHeight(int i, int j) {
        if(i < 0 || j < 0 || i >= N || j >= N)
            throw new IndexOutOfBoundsException("i and j must be in [0,N)");
        return heights[i][j];
    }
    public int getHeight(Coord loc) {
        return getHeight(loc.getI(), loc.getJ());
    }

    // computes distance between (i0,j0) and (i1,j1) as the crow flies
    public float computeDistance(int i0, int j0, int i1, int j1) {
        return (float)Math.sqrt((i0 - i1) * (i0 - i1) + (j0 - j1) * (j0 - j1));
    }
    public float computeDistance(Coord c0, Coord c1) {
        return computeDistance(c0.getI(), c0.getJ(), c1.getI(), c1.getJ());
    }

    public float computeTravelCost(int i0, int j0, int i1, int j1) {
        float h0 = getHeight(i0, j0), h1 = getHeight(i1, j1);
        float climb = (float)Math.pow(Math.abs(h0 - h1) * 1000.0, 1.5);
        float dist = computeDistance(i0,j0, i1,j1);
        return (1.0f + climb) * dist;
    }
    public float computeTravelCost(Coord c0, Coord c1) {
        return computeTravelCost(c0.getI(), c0.getJ(), c1.getI(), c1.getJ());
    }
    public float computeTravelCost(Iterable<Coord> cs) {
        Coord c0 = null;
        float cost = 0.0f;
        for(Coord c1 : cs) {
            if(c0 != null) cost += computeTravelCost(c0, c1);
            c0 = c1;
        }
        return cost;
    }
}

--[ 2019.11.06.20.23.28.977.0 ]--
InitFile: /src/InteractivePathfinderVisualizer.java
import java.awt.event.KeyEvent;

/**
 * InteractivePathfinderVisualizer visualizes the terrain and the computed
 * path and allows the user to change parameters of the Pathfinder.  Below
 * is a list of commands and what they do.  Note: some of the commands
 * modify the properties of the path finder and some modify the terrain.
 *
 * Command        Action                                      Terrain
 * C              clear path
 * space          recompute path
 * S/E            set start/end location to mouse
 * left/right     halve/double path search heuristic value
 * 0/1            set path search heuristic to 0 or 1
 * W              start a walker to show the path
 * R              randomly generate a new terrain                *
 * M              smooths terrain under mouse                    *
 * shift+M        smooths all terrain                            *
 * up/down        increase/decrease terrain under mouse          *
 */

public class InteractivePathfinderVisualizer {
    private final static int DELAY = 10;

    // sets how many redraws it should take for the walker to reach its destination
    private final static float STEPS_TO_WALK = 100.0f;

    // for convenience, here are the emap files that are located under heightmaps/ folder
    // the python script in that folder converts png files to emap. \
    // you can use it to create your own maps to test your code
    private final static String[] emaps = {
            "maze32_0.png.emap",    // 0   (32x32 maze)
            "maze32_1.png.emap",    // 1   (another 32x32 maze)
            "maze232_0.png.emap",   // 2   (232x232 maze)
            "maze320_0.png.emap",   // 3   (same as maze32_0, only scaled up by 10x)
            "mazeAB.png.emap",      // 4   (a maze from a site no longer online :( )
            "mazeBrain.png.emap",   // 5   (...)
            "ramp.png.emap",        // 6   (some tests)
            "ramp2.png.emap",       // 7   (...)
            "ramp3.png.emap",       // 8   (...)
            "usa128.png.emap",      // 9   (elevation map of USA from https://bananas.openttd.org/en/heightmap/)
            "usa256.png.emap",      // 10  (same as usa128, only higher resolution)
            "usa1024.png.emap",     // 11  (same as usa128, only higher resolution
    };

    private final static String emapFilename = emaps[1];        // change index to load a different elevation map



    public static void main(String[] args) {
        Terrain terrain = new Terrain(emapFilename);
        Pathfinder pf = new Pathfinder(terrain);
        int N = terrain.getN();

        StdDraw.show(0);

        // set default starting and ending locations
        pf.setPathStart(new Coord(1, 1));
        pf.setPathEnd(new Coord(N-3, N-3));

        // find a path
        pf.computePath();

        PathfinderVisualizer.draw(terrain, pf, null, N);
        StdDraw.show(DELAY);

        // prevent repeated applications
        boolean keyboardR = false;
        boolean keyboardM = false;

        Walker walker = null;

        while(true) {
            boolean recompute = false;
            boolean redraw = false;

            // mouse location on map
            int mouseI = (int) ((StdDraw.mouseX()-24) / 464 * N);
            int mouseJ = (int) ((464 - (StdDraw.mouseY()-36)) / 464 * N);
            boolean isMouseOnMap = (mouseI >=0 && mouseI < N && mouseJ >= 0 && mouseJ < N);

            if(StdDraw.isKeyPressed(KeyEvent.VK_LEFT) || StdDraw.isKeyPressed(KeyEvent.VK_RIGHT)) {
                boolean keyboardLeft = StdDraw.isKeyPressed(KeyEvent.VK_LEFT);
                float m = keyboardLeft ? 0.5f : 2.0f;
                float h = pf.getHeuristic() * m;
                h = Math.max(1.0f/1024.0f, Math.min(1048576.0f, h));
                pf.setHeuristic(h);
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_0) || StdDraw.isKeyPressed(KeyEvent.VK_1)) {
                boolean keyboard0 = StdDraw.isKeyPressed(KeyEvent.VK_0);
                float h = keyboard0 ? 0 : 1;
                pf.setHeuristic(h);
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_C)) {
                pf.resetPath();
                walker = null;
                redraw = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_R) && !keyboardR) {
                TerrainEditor.setFractalHeights(terrain);
                TerrainEditor.clampHeights(terrain);
                recompute = true;
            }
            keyboardR = StdDraw.isKeyPressed(KeyEvent.VK_R);

            if(StdDraw.isKeyPressed(KeyEvent.VK_M)) {
                if(StdDraw.isKeyPressed(KeyEvent.VK_SHIFT)) {
                    if(!keyboardM) {
                        TerrainEditor.smoothHeights(terrain);
                        recompute = true;
                    }
                } else {
                    TerrainEditor.smoothHeights(mouseI, mouseJ, N / 20, true, terrain);
                    recompute = true;
                }
            }
            keyboardM = StdDraw.isKeyPressed(KeyEvent.VK_M);

            if(StdDraw.isKeyPressed(KeyEvent.VK_SPACE)) {
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_UP) || StdDraw.isKeyPressed(KeyEvent.VK_DOWN)) {
                boolean keyboardUp = StdDraw.isKeyPressed(KeyEvent.VK_UP);
                float add = keyboardUp ? 8.0f : -8.0f;
                TerrainEditor.addHeight(mouseI, mouseJ, N / 20, add, terrain);
                recompute = true;
            }

            if(isMouseOnMap && StdDraw.isKeyPressed(KeyEvent.VK_S)) {
                pf.setPathStart(new Coord(mouseI, mouseJ));
                recompute = true;
            }

            if(isMouseOnMap && StdDraw.isKeyPressed(KeyEvent.VK_E)) {
                pf.setPathEnd(new Coord(mouseI, mouseJ));
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_W)) {
                Iterable<Coord> path = pf.getPathSolution();
                if(path != null) {
                    walker = new Walker(terrain, pf.getPathSolution());
                }
            }

            if(walker != null) {
                if(walker.doneWalking()) {
                    walker = null;
                } else {
                    walker.advance(pf.getPathCost() / STEPS_TO_WALK);
                }
                redraw = true;
            }

            if(recompute) {
                walker = null;
                pf.resetPath();
                if(pf.getPathStart() != null && pf.getPathEnd() != null) {
                    pf.computePath();
                }
                redraw = true;
            }

            if(redraw) {
                PathfinderVisualizer.draw(terrain, pf, walker, N);
                StdDraw.show(DELAY);
            } else {
                try {
                    Thread.sleep(10);
                } catch (InterruptedException e) {
                    /* do nothing */
                }
            }
        }
    }
}

--[ 2019.11.06.20.23.28.978.0 ]--
InitFile: /src/Pathfinder.java
import java.lang.IndexOutOfBoundsException;
import java.lang.IllegalArgumentException;

/**
 * Pathfinder uses A* search to find a near optimal path
 * between to locations with given terrain.
 */

public class Pathfinder {
    private Coord end;
    private Coord start;
    private Terrain terrain;
    private float heur;
    private boolean pathFound = false;  //implement in compute path, set to true when found
    private int searchSize;
    private PFNode[][] board;
    private PFNode endNode;
    private Stack<Coord> stack = new Stack<>();
    //set up Minimum Priority Queue
    private MinPQ<PFNode> pq = new MinPQ<>();
    private float pathCost;

    /**
     * PFNode will be the key for MinPQ (used in computePath())
     */
    private class PFNode implements Comparable<PFNode> {
        private boolean isUsed;
        private boolean invalid;
        private Coord loc;
        private PFNode fromNode;
        private float cost;
        // loc: the location of the PFNode
        // fromNode: how did we get here? (linked list back to start)

        public PFNode(Coord loc, PFNode fromNode) {
            this.loc = loc;
            this.fromNode = fromNode;
            if(fromNode != null)
                cost = fromNode.cost + terrain.computeTravelCost(loc, fromNode.loc);
        }

        // compares this with that, used to find minimum cost PFNode
        public int compareTo(PFNode that) {
            if(this.getCost(heur) < that.getCost(heur)) return -1;  //this < that
            if(that.getCost(heur) < this.getCost(heur)) return 1;   //that < this
            return 0;  //this == that
        }

        // returns the cost to travel from starting point to this
        // via the fromNode chain
        public float getCost(float heuristic) {  //call getCost with heuristic of 0, get travel cost, do A* search
            //return fromNode.getCost(0) + terrain.computeTravelCost(fromNode.loc, loc) + heuristic*terrain.computeDistance(loc.getI(), loc.getJ(), endNode.loc.getI(), endNode.loc.getJ());
            StdOut.println(heuristic);
            StdOut.println(terrain.computeDistance(loc.getI(), loc.getJ(), end.getI(), end.getJ()));
            StdOut.println("Cost:" + cost);
            return cost + heuristic*terrain.computeDistance(loc.getI(), loc.getJ(), end.getI(), end.getJ());
        }

        // returns if this PFNode is not marked invalid
        public boolean isValid() {
            return invalid;
        }

        // marks the PFNode as invalid
        public void invalidate() {
            invalid = true;
        }

        // returns if the PFNode is marked as used
        public boolean isUsed() {  //help
            return isUsed;
        }

        // marks the PFNode as used
        public void use(PFNode node) {
            node.isUsed = true;
        }

        // returns an Iterable of PFNodes that surround this
        public Iterable<PFNode> neighbors() {
            Stack<PFNode> s = new Stack<>();
            s.push(new PFNode(null, null));
            return s;
        }
    }

    public Pathfinder(Terrain terrain) {
        this.terrain = terrain;
    }

    public void setPathStart(Coord loc) { // I need a check to see how it can stay on the white area.
        if(loc == null) throw new IllegalArgumentException("The location is null.");
        if(!loc.isInBounds(0,0,terrain.getN()-1, terrain.getN()-1)) throw new IndexOutOfBoundsException("The location is out of bounds.");
        start = loc;
    }

    public Coord getPathStart() {
        return start;
    }

    public void setPathEnd(Coord loc) {
        if(loc == null) throw new IllegalArgumentException("The location is null.");
        if(!loc.isInBounds(0,0,terrain.getN()-1, terrain.getN()-1)) throw new IndexOutOfBoundsException("The location is out of bounds.");
        end = loc;
    }

    public Coord getPathEnd() {
        return end;
    }

    public void setHeuristic(float v) { // is this correct?
        heur = v;
    }

    public float getHeuristic() { return heur; }

    public void resetPath() {
        start = getPathStart(); //how do I tell it to find where the mouse is at? setPathStart?
        end = getPathEnd();
        endNode = null;
        pathFound = false;
        searchSize = 0;

        pq = new MinPQ<>();

        stack = new Stack<>();

        //computePath();
    }

    public void computePath() {
        if(getPathEnd() == null || getPathStart() == null) throw new IllegalArgumentException("Either or both of start path or end path have NOT been set.");

        //set up logic board with 2D array
        int N = terrain.getN();
        board = new PFNode[N][N];

        //I added this... is it needed?
        //setHeuristic(3);

        PFNode beginNode = new PFNode(getPathStart(), null);
        board[getPathStart().getI()][getPathStart().getJ()] = beginNode;
        pq.insert(beginNode);
        beginNode.use(beginNode);
        beginNode.cost = 0;
        while(!pathFound){
            //remove from pq
            PFNode removed = pq.delMin();
            //StdOut.println("The minimum has been removed.");  //bug check
            //check if node is at end
            if(removed.loc.equals(getPathEnd())){  //correct?
                pq.insert(removed);
                endNode = removed;
                pathFound = true;
                endNode.use(endNode);
                endNode.cost = removed.cost + terrain.computeTravelCost(removed.loc, endNode.loc);
                pathCost = endNode.cost;
                break;
            }
            //"process" node just removed
            //see if the locations around the removed position are in bounds
            //now have them point to removed, "from = removed";  ?
            if(removed.loc.getJ() -1 > 0 ){
               if(board[removed.loc.getI()][removed.loc.getJ()-1] == null){
                    PFNode node = new PFNode(removed.loc.add(0, -1), removed); //good
                    board[removed.loc.getI()][removed.loc.getJ() - 1] = node;
                    pq.insert(node);
                    node.use(node);
                    node.cost = removed.cost + terrain.computeTravelCost(removed.loc, node.loc);
                }
            }
            if(removed.loc.getI() - 1 > 0){
                if(board[removed.loc.getI()-1][removed.loc.getJ()] == null) {
                    PFNode node = new PFNode(removed.loc.add(-1, 0), removed); //good
                    board[removed.loc.getI() - 1][removed.loc.getJ()] = node;
                    pq.insert(node);
                    node.use(node);
                    node.cost = removed.cost + terrain.computeTravelCost(removed.loc, node.loc);
                }
            }
            if(removed.loc.getJ() + 1 < N-2){
                if(board[removed.loc.getI()][removed.loc.getJ()+1] == null) {
                    PFNode node = new PFNode(removed.loc.add(0, 1), removed); //good
                    board[removed.loc.getI()][removed.loc.getJ() + 1] = node;
                    pq.insert(node);
                    node.use(node);
                    node.cost = removed.cost + terrain.computeTravelCost(removed.loc, node.loc);
                }
            }
            if(removed.loc.getI() + 1 < N-2){
                if(board[removed.loc.getI()+1][removed.loc.getJ()] == null) {
                    PFNode node = new PFNode(removed.loc.add(1, 0), removed); //good
                    board[removed.loc.getI() + 1][removed.loc.getJ()] = node;
                    pq.insert(node);
                    node.use(node);
                    node.cost = removed.cost + terrain.computeTravelCost(removed.loc, node.loc);
                }
            }
        }
        //StdOut.println("A connection has been found!");

        stack.push(endNode.loc);
        searchSize = 1;
        PFNode nextNode = endNode.fromNode;
        while(nextNode.fromNode != beginNode){
            stack.push(nextNode.loc);
            nextNode = nextNode.fromNode;
            searchSize ++;
        }
        //this should be the start node
        stack.push(nextNode.loc);
        searchSize ++;
    }

    public boolean foundPath() { //good
        return pathFound;
    }

    public float getPathCost() { //good
        return pathCost;
    }

    public int getSearchSize() { //good
        return searchSize;
    }

    public Iterable<Coord> getPathSolution() {
        return stack;
    } //good

    public boolean wasSearched(Coord loc) { //good
        return board[loc.getI()][loc.getJ()] != null;
    }

}

--[ 2019.11.06.20.23.28.979.0 ]--
InitFile: /.cos265


--[ 2019.11.06.20.30.19.193.0 ]--
:/src/Pathfinder.java
r 196 
--[ 2019.11.06.20.30.19.810.0 ]--
- 196
--[ 2019.11.06.20.30.23.868.0 ]--
r 187 
--[ 2019.11.06.20.30.24.366.0 ]--
- 187
--[ 2019.11.06.20.30.28.358.0 ]--
r 178 
--[ 2019.11.06.20.30.28.873.0 ]--
- 178
--[ 2019.11.06.20.30.34.187.0 ]--
r 169 
--[ 2019.11.06.20.30.35.308.0 ]--
- 169
--[ 2019.11.06.20.31.31.740.0 ]--
r 151             if(removed.loc.equals(getPathEnd())){ 
--[ 2019.11.06.20.31.32.187.0 ]--
r 151             if(removed.loc.equals(getPathEnd())){
--[ 2019.11.06.20.32.04.934.0 ]--
r 196 
--[ 2019.11.06.20.32.05.462.0 ]--
- 196
--[ 2019.11.06.20.36.43.308.0 ]--
- 138
r 138 
--[ 2019.11.06.20.36.43.871.0 ]--
- 137
r 137         
--[ 2019.11.06.20.40.42.516.0 ]--
r 137 
--[ 2019.11.06.20.40.45.202.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.06.20.41.09.710.0 ]--
r 137         
--[ 2019.11.06.20.41.10.200.0 ]--
+ 137 
r 138 
--[ 2019.11.06.20.41.10.784.0 ]--
+ 138         //I added this... is it needed?
r 139         //setHeuristic(3);
--[ 2019.11.06.20.41.11.520.0 ]--
+ 196 
--[ 2019.11.06.20.41.12.017.0 ]--
r 196         //StdOut.println("A connection has been found!");
--[ 2019.11.06.20.41.12.851.0 ]--
r 151             if(removed.loc.equals(getPathEnd())){  //correct?
--[ 2019.11.06.20.41.13.678.0 ]--
+ 169 
--[ 2019.11.06.20.41.14.077.0 ]--
r 169                     node.cost = removed.cost + terrain.computeTravelCost(removed.loc, node.loc);
--[ 2019.11.06.20.41.15.270.0 ]--
+ 178 
--[ 2019.11.06.20.41.15.717.0 ]--
r 178                     node.cost = removed.cost + terrain.computeTravelCost(removed.loc, node.loc);
--[ 2019.11.06.20.41.16.456.0 ]--
+ 187 
--[ 2019.11.06.20.41.16.832.0 ]--
r 187                     node.cost = removed.cost + terrain.computeTravelCost(removed.loc, node.loc);
--[ 2019.11.06.20.41.17.518.0 ]--
+ 196 
--[ 2019.11.06.20.41.17.913.0 ]--
r 196                     node.cost = removed.cost + terrain.computeTravelCost(removed.loc, node.loc);
--[ 2019.11.06.20.41.24.983.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.06.20.43.42.768.0 ]--
r 169                     /node.cost = removed.cost + terrain.computeTravelCost(removed.loc, node.loc);
--[ 2019.11.06.20.43.42.789.0 ]--
r 169                     //node.cost = removed.cost + terrain.computeTravelCost(removed.loc, node.loc);
--[ 2019.11.06.20.43.57.000.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.11.17.55.03.272.0 ]--
NewLogger: P04_Pathfinding
Version: 1.3
--[ 2019.11.11.17.55.03.404.0 ]--
InitTree:
/out/production/P04_Pathfinding/.donotlog
/out/production/P04_Pathfinding/algs4.jar
/out/production/P04_Pathfinding/stdlib.jar
/out/production/P04_Pathfinding/Coord.class
/out/production/P04_Pathfinding/png2emap.py
/out/production/P04_Pathfinding/Walker.class
/out/production/P04_Pathfinding/ramp.png.emap
/out/production/P04_Pathfinding/Terrain.class
/out/production/P04_Pathfinding/ramp2.png.emap
/out/production/P04_Pathfinding/ramp3.png.emap
/out/production/P04_Pathfinding/mazeAB.png.emap
/out/production/P04_Pathfinding/usa128.png.emap
/out/production/P04_Pathfinding/usa256.png.emap
/out/production/P04_Pathfinding/Pathfinder.class
/out/production/P04_Pathfinding/usa1024.png.emap
/out/production/P04_Pathfinding/maze32_0.png.emap
/out/production/P04_Pathfinding/maze32_1.png.emap
/out/production/P04_Pathfinding/maze232_0.png.emap
/out/production/P04_Pathfinding/maze320_0.png.emap
/out/production/P04_Pathfinding/mazeBrain.png.emap
/out/production/P04_Pathfinding/TerrainEditor.class
/out/production/P04_Pathfinding/Pathfinder$PFNode.class
/out/production/P04_Pathfinding/PathfinderVisualizer.class
/out/production/P04_Pathfinding/InteractivePathfinderVisualizer.class
/src/algs4.jar
/src/Coord.java
/src/stdlib.jar
/src/Walker.java
/src/Terrain.java
/src/Pathfinder.java
/src/TerrainEditor.java
/src/PathfinderVisualizer.java
/src/InteractivePathfinderVisualizer.java
/.log/history.log
/.idea/copyright/profiles_settings.xml
/.idea/libraries/algs4.xml
/.idea/libraries/stdlib.xml
/.idea/.name
/.idea/misc.xml
/.idea/modules.xml
/.idea/compiler.xml
/.idea/workspace.xml
/.idea/uiDesigner.xml
/heightmaps/.donotlog
/heightmaps/png2emap.py
/heightmaps/ramp.png.emap
/heightmaps/ramp2.png.emap
/heightmaps/ramp3.png.emap
/heightmaps/mazeAB.png.emap
/heightmaps/usa128.png.emap
/heightmaps/usa256.png.emap
/heightmaps/usa1024.png.emap
/heightmaps/maze32_0.png.emap
/heightmaps/maze32_1.png.emap
/heightmaps/maze232_0.png.emap
/heightmaps/maze320_0.png.emap
/heightmaps/mazeBrain.png.emap
/.cos265
/readme.html
/P04_Pathfinding.iml

--[ 2019.11.11.17.55.03.405.0 ]--
InitFile: /src/PathfinderVisualizer.java
/**
 * PathfinderVisualizer visualizes the terrain and found path.
 */

import java.awt.Color;
import java.awt.Font;

public class PathfinderVisualizer {

    // delay in milliseconds (controls animation speed)
    private final static int DELAY = 100;

    // color for different elevations.  must be in ascending order!
    private final static int[][] elevationColors = {
            // h    r   g   b   where h=height, r=red, g=green, b=blue
            {  0,   0,  0,  0},
            {  2,   0,  0,160},
            {  4,   0,224,224},
            { 16, 192,192,  0},
            { 64,  16,255, 16},
            {128,  32,224, 32},
            {192, 128,128,  8},
            {224, 164,164,164},
            {255, 255,255,255}
    };

    private final static Color cStart    = new Color(128, 128, 255);
    private final static Color cEnd      = new Color(255, 128, 128);
    private final static Color cSolution = new Color(255, 128, 255);
    private final static Color cSearched = new Color(128,   0, 128);

    // linearly interpolating between the corresponding rgb values
    private static Color colorLERP(float v1, int r0, int g0, int b0, int r1, int g1, int b1) {
        v1 = Math.max(0.0f, Math.min(1.0f, v1));
        float v0 = 1.0f - v1;
        int r = (int)(v0 * r0 + v1 * r1);
        int g = (int)(v0 * g0 + v1 * g1);
        int b = (int)(v0 * b0 + v1 * b1);
        return new Color(r, g, b);
    }
    private static Color colorLERP(float v1, Color c0, Color c1) {
        v1 = Math.max(0.0f, Math.min(1.0f, v1));
        float v0 = 1.0f - v1;
        int r = (int)(v0 * c0.getRed()   + v1 * c1.getRed());
        int g = (int)(v0 * c0.getGreen() + v1 * c1.getGreen());
        int b = (int)(v0 * c0.getBlue()  + v1 * c1.getBlue());
        int a = (int)(v0 * c0.getAlpha() + v1 * c1.getAlpha());
        return new Color(r, g, b, a);
    }

    // returns color for given height
    private static Color height2Color(int h) {
        h = Math.max(0, Math.min(255, h));

        int[] ec0 = elevationColors[0];  // default lower bound
        int[] ec1 = elevationColors[1];  // default upper bound

        // find upper bound while updating lower bound
        for(int i = 1; i < elevationColors.length; i++) {
            ec1 = elevationColors[i];
            if(h >= ec0[0] && h <= ec1[0]) break;
            ec0 = ec1;
        }

        int h0=ec0[0], r0=ec0[1], g0=ec0[2], b0=ec0[3];
        int h1=ec1[0], r1=ec1[1], g1=ec1[2], b1=ec1[3];
        float v1 = ((float)(h - h0)) / ((float)(h1 - h0));

        return colorLERP(v1, r0, g0, b0, r1, g1, b1);
    }

    private static void drawCircle(int i, int j, int N, double rad) {
        int c = (int)((i+0.5f) * 464.0f / N);
        int r = (int)((j+0.5f) * 464.0f / N);
        StdDraw.circle(c + 24, 464 - r + 36, rad);
    }
    public static void drawCircle(Coord loc, int N, double rad) {
        drawCircle(loc.getI(), loc.getJ(), N, rad);
    }

    private static void drawPath(Iterable<Coord> path, int N) {
        boolean first = true;
        int c0 = 0, r0 = 0;
        for (Coord loc : path) {
            int c1 = (int)((loc.getI()+0.5f) * 464.0f / N);
            int r1 = (int)((loc.getJ()+0.5f) * 464.0f / N);
            if(!first) {
                StdDraw.line(c0 + 24, 464 - r0 + 36, c1 + 24, 464 - r1 + 36);
            }
            first = false;
            c0 = c1; r0 = r1;
        }
    }

    // draw N-by-N pathfinding map
    public static void draw(Terrain terrain, Pathfinder pf, Walker walker, int N) {
        StdDraw.clear();
        StdDraw.setXscale(0, 512);
        StdDraw.setYscale(0, 512);
        StdDraw.setPenColor(StdDraw.BLACK);
        StdDraw.filledSquare(256, 256 + 12, 464 / 2);

        // draw terrain
        for(int row = 0; row < 464; row++) {
            int j = (int)((float)row/464.0f * N);
            for(int col = 0; col < 464; col++) {
                int i = (int)((float)col/464.0f * N);
                Coord loc = new Coord(i,j);
                Color c = height2Color(terrain.getHeight(loc));
                if(pf.wasSearched(loc)) {
                    c = colorLERP(0.50f, c, cSearched);
                }
                StdDraw.setPenColor(c);
                StdDraw.filledSquare(col + 24, 464 - row + 36, 1);
            }
        }

        // draw path start
        if(pf.getPathStart() != null) {
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            drawCircle(pf.getPathStart(), N, 4.0);

            StdDraw.setPenColor(cStart);
            StdDraw.setPenRadius(0.002);
            drawCircle(pf.getPathStart(), N, 4.0);
        }

        // draw path end
        if(pf.getPathEnd() != null) {
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            drawCircle(pf.getPathEnd(), N, 4.0);

            StdDraw.setPenColor(cEnd);
            StdDraw.setPenRadius(0.002);
            drawCircle(pf.getPathEnd(), N, 4.0);
        }

        // draw found path
        if(pf.foundPath()) {
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            drawPath(pf.getPathSolution(), N);

            StdDraw.setPenColor(cSolution);
            StdDraw.setPenRadius(0.002);
            drawPath(pf.getPathSolution(), N);
        }

        // draw walker
        if(walker != null) {
            Coord loc = walker.getLocation();
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            PathfinderVisualizer.drawCircle(loc, N, 2.0);

            StdDraw.setPenColor(StdDraw.WHITE);
            StdDraw.setPenRadius(0.002);
            PathfinderVisualizer.drawCircle(loc, N, 2.0);
        }

        // write status text
        StdDraw.setFont(new Font("SansSerif", Font.PLAIN, 12));
        StdDraw.setPenColor(StdDraw.BLACK);
        StdDraw.text(96, 12, "heuristic: " + pf.getHeuristic());
        if(pf.foundPath()) StdDraw.text(256, 12, "path: " + pf.getPathCost());
        else               StdDraw.text(256, 12, "no path found");
        StdDraw.text(512-96, 12, "searched: " + pf.getSearchSize() + " (" + (int)(100.0f * pf.getSearchSize() / (N*N)) + "%)");
    }
}

--[ 2019.11.11.17.55.03.406.0 ]--
InitFile: /P04_Pathfinding.iml
<?xml version="1.0" encoding="UTF-8"?>
<module type="JAVA_MODULE" version="4">
  <component name="NewModuleRootManager" inherit-compiler-output="true">
    <exclude-output />
    <content url="file://$MODULE_DIR$">
      <sourceFolder url="file://$MODULE_DIR$/src" isTestSource="false" />
      <sourceFolder url="file://$MODULE_DIR$/heightmaps" type="java-resource" />
      <excludeFolder url="file://$MODULE_DIR$/.log" />
    </content>
    <orderEntry type="inheritedJdk" />
    <orderEntry type="sourceFolder" forTests="false" />
    <orderEntry type="library" name="algs4" level="project" />
    <orderEntry type="library" name="stdlib" level="project" />
  </component>
</module>

--[ 2019.11.11.17.55.03.407.0 ]--
InitFile: /src/Coord.java
/**
 * Coordinates is an immutable type that store the tuple (i, j)
 */
public final class Coord {
    private final int i;
    private final int j;

    public Coord(int i, int j) {
        this.i = i;
        this.j = j;
    }

    public int getI() { return i; }
    public int getJ() { return j; }

    public boolean isInBounds(int minI, int minJ, int maxI, int maxJ) {
        return i >= minI && j >= minJ && i <= maxI && j <= maxJ;
    }
    public boolean isInBounds(Coord min, Coord max) {
        return i >= min.i && i <= max.i && j >= min.j && j <= max.j;
    }

    public Coord add(int addI, int addJ) {
        return new Coord(i + addI, j + addJ);
    }
    public Coord add(Coord that) { return new Coord(i + that.i, j + that.j); }

    public String toString() { return "(" + i + "," + j + ")"; }

    public boolean equals(Object o) {
        if(this == o) return true;
        if(o == null) return false;
        if(o.getClass() != this.getClass()) return false;
        Coord that = (Coord) o;
        if(this.i != that.i) return false;
        if(this.j != that.j) return false;
        return true;
    }
}

--[ 2019.11.11.17.55.03.408.0 ]--
InitFile: /src/Walker.java
import java.util.Iterator;

/**
 * Walker takes an Iterable of Coords and simulates an individual
 * walking along the path over the given Terrain
 */
public class Walker {
    private Terrain terrain;
    private Iterable<Coord> path;
    private boolean finishedWalking = false;

    // terrain: the Terrain the Walker traverses
    // path: the sequence of Coords the Walker follows
    public Walker(Terrain terrain, Iterable<Coord> path) {
        this.terrain = terrain;
        this.path = path;
    }

    // returns the Walker's current location
    public Coord getLocation() {
        //return path.next;
        return null;
    }

    // returns true if Walker has reached the end Coord (last in path)
    public boolean doneWalking() {
        return finishedWalking;
    }

    // advances the Walker along path
    // byTime: how long the Walker should traverse (may be any non-negative value)
    public void advance(float byTime) {
    }

}
//compute travel cost to know how long it takes to go to each spot
//start walker at first coord
//getlocation always calls beginning until advance is called
//when advance is called, move walker to next thing in iterable


//byTime take into account travel cost
//keep track of how many times advance is called and then compare that to the travel cost.

--[ 2019.11.11.17.55.03.409.0 ]--
InitFile: /src/TerrainEditor.java
/**
 * The following class provides some simple terrain editing functions.
 */
public class TerrainEditor {
    private static float rndRadius(float d) {
        return (float)StdRandom.uniform(-d,d);
    }

    private static float getFractalHeight(int i, int j, float dh, Terrain terrain, boolean[] isset) {
        int N = terrain.getN();
        dh = Math.max(-64, Math.min(255+64, dh));   // allow the height to go just a bit out of range
        if(!isset[i + j * N]) {
            isset[i + j * N] = true;
            terrain.setHeight(i, j, dh);
        }
        return terrain.getHeight(i,j);
    }

    private static void setFractalHeights(int i0, int j0, int i1, int j1, Terrain terrain, boolean[] isset) {
        int id = i1-i0;
        int jd = j1-j0;
        int i01 = (i0+i1)/2;
        int j01 = (j0+j1)/2;

        if(id <= 1 && jd <= 1) return;

        float h00 = getFractalHeight(i0,j0,32,terrain,isset);
        float h01 = getFractalHeight(i0,j1,32,terrain,isset);
        float h10 = getFractalHeight(i1,j0,32,terrain,isset);
        float h11 = getFractalHeight(i1,j1,32,terrain,isset);

        float d = (float)(Math.sqrt((i1-i0)*(i1-i0) + (j1-j0)*(j1-j0)) * 0.5);

        float d0001 = (h00 + h01) / 2 + rndRadius(d);
        float d0010 = (h00 + h10) / 2 + rndRadius(d);
        float d1101 = (h11 + h01) / 2 + rndRadius(d);
        float d1110 = (h11 + h10) / 2 + rndRadius(d);

        float h0001 = getFractalHeight(i0, j01, d0001, terrain,isset);
        float h0010 = getFractalHeight(i01, j0, d0010, terrain,isset);
        float h1101 = getFractalHeight(i01, j1, d1101, terrain,isset);
        float h1110 = getFractalHeight(i1, j01, d1110, terrain,isset);

        float dm = (float)((h0001 + h0010 + h1101 + h1110) / 4.0);
        float hm = getFractalHeight(i01, j01, dm, terrain,isset);

        if(id > 1 && jd > 1) {
            setFractalHeights(i0, j0, i01, j01, terrain, isset);
            setFractalHeights(i01, j0, i1, j01, terrain, isset);
            setFractalHeights(i0, j01, i01, j1, terrain, isset);
            setFractalHeights(i01, j01, i1, j1, terrain, isset);
        } else if(jd > 1) {
            setFractalHeights(i0, j0, i1, j01, terrain, isset);
            setFractalHeights(i0, j01, i1, j1, terrain, isset);
        } else {
            setFractalHeights(i0, j0, i01, j1, terrain, isset);
            setFractalHeights(i01, j0, i1, j1, terrain, isset);
        }
    }

    public static void setFractalHeights(Terrain terrain) {
        int N = terrain.getN();
        boolean[] isset = new boolean[N*N];
        setFractalHeights(0, 0, N - 1, N - 1, terrain, isset);
    }

    public static void smoothHeights(Terrain terrain) {
        int N = terrain.getN();
        int radius = (int)Math.ceil(Math.sqrt(N*N/2.0f));
        smoothHeights(N/2, N/2, radius, false, terrain);
    }

    public static void smoothHeights(int ic, int jc, int radius, boolean fallOff, Terrain terrain) {
        final int N = terrain.getN();
        final int w = 2*radius+1;
        float[] s = new float[w*w];
        for(int ia = -radius; ia <= radius; ia++) {
            int i = ic + ia;
            if(i < 0 || i >= N) continue;
            for(int ja = -radius; ja <= radius; ja++) {
                int j = jc + ja;
                if(j < 0 || j >= N) continue;
                int sidx = (ia+radius) + (ja+radius)*w;

                float m = computeEffect(i, j, ic, jc, radius, fallOff, N);
                if(m <= 0.0000001) {
                    s[sidx] = terrain.getHeight(i,j);
                    continue;
                }
                float h = 0;
                int c = 0;
                if(i > 0 && j > 0) {
                    h += terrain.getHeight(i-1,j-1);
                    c += 1;
                }
                if(i < N-1 && j > 0) {
                    h += terrain.getHeight(i+1,j-1);
                    c += 1;
                }
                if(i > 0 && j < N-1) {
                    h += terrain.getHeight(i-1,j+1);
                    c += 1;
                }
                if(i < N-1 && j < N-1) {
                    h += terrain.getHeight(i+1,j+1);
                    c += 1;
                }
                if(i > 0) {
                    h += terrain.getHeight(i-1,j);
                    c += 1;
                }
                if(j > 0) {
                    h += terrain.getHeight(i,j-1);
                    c += 1;
                }
                if(i < N-1) {
                    h += terrain.getHeight(i+1,j);
                    c += 1;
                }
                if(j < N-1) {
                    h += terrain.getHeight(i,j+1);
                    c += 1;
                }
                s[sidx] = (1-m) * terrain.getHeight(i,j) + m * h / c;
            }
        }
        for(int ia = -radius; ia <= radius; ia++) {
            int i = ic + ia;
            if(i < 0 || i >= N) continue;
            for(int ja = -radius; ja <= radius; ja++) {
                int j = jc + ja;
                if(j < 0 || j >= N) continue;
                int sidx = (ia+radius) + (ja+radius)*w;
                terrain.setHeight(i, j, s[sidx]);
            }
        }
    }

    public static void clampHeights(Terrain terrain) {
        int N = terrain.getN();
        for(int i = 0; i < N; i++) {
            for(int j = 0; j < N; j++) {
                terrain.setHeight(i, j, Math.max(0, Math.min(255, terrain.getHeight(i, j))));
            }
        }
    }

    private static float computeEffect(int i, int j, int ic, int jc, int radius, boolean fallOff, int N) {
        if(i < 0 || j < 0 || i >= N || j >= N) return 0;
        if(!fallOff) return 1;
        int d2 = (ic-i)*(ic-i)+(jc-j)*(jc-j);
        if(d2 > radius*radius) return 0;
        return ((float)radius - (float)Math.sqrt(d2)) / (float)radius;
    }

    public static void addHeight(int i, int j, int radius, float add, Terrain terrain) {
        final int N = terrain.getN();
        for(int ja = -radius; ja <= radius; ja++) {
            int r = j + ja;
            if(r < 0 || r >= N) continue;
            for(int ia = -radius; ia <= radius; ia++) {
                int c = i + ia;
                if(c < 0 || c >= N) continue;
                float v = add * computeEffect(c, r, i, j, radius, true, N);
                float h = terrain.getHeight(c, r) + v;
                h = Math.max(0, Math.min(255, h));
                terrain.setHeight(c, r, h);
            }
        }
    }
}

--[ 2019.11.11.17.55.03.409.1 ]--
InitFile: /src/Terrain.java
import java.lang.IndexOutOfBoundsException;

/**
 * Terrain stores elevations for map and computes distance and
 * cost in traversing the terrain.
 */

public class Terrain {
    private int N;
    private int[][] heights;

    public Terrain(int N) {
        this.N = N;
        this.heights = new int[N][N];
    }

    public Terrain(int[][] heights) {
        this.N = heights.length;
        this.heights = heights;
    }

    public Terrain(String emapfile) {
        In in = new In(emapfile);
        this.N = in.readInt();
        this.heights = new int[N][N];
        for (int j = 0; j < N; j++) {
            for (int i = 0; i < N; i++) {
                this.heights[i][j] = in.readInt();
            }
        }
    }

    public int getN() {
        return N;
    }

    public void setHeight(int i, int j, int h) {
        if(i < 0 || j < 0 || i >= N || j >= N)
            throw new IndexOutOfBoundsException("i and j must be in [0,N)");
        heights[i][j] = h;
    }
    public void setHeight(int i, int j, float h) {
        setHeight(i, j, (int) h);
    }
    public void setHeight(Coord loc, int h) {
        setHeight(loc.getI(), loc.getJ(), h);
    }
    public void setHeight(Coord loc, float h) {
        setHeight(loc.getI(), loc.getJ(), h);
    }

    public int getHeight(int i, int j) {
        if(i < 0 || j < 0 || i >= N || j >= N)
            throw new IndexOutOfBoundsException("i and j must be in [0,N)");
        return heights[i][j];
    }
    public int getHeight(Coord loc) {
        return getHeight(loc.getI(), loc.getJ());
    }

    // computes distance between (i0,j0) and (i1,j1) as the crow flies
    public float computeDistance(int i0, int j0, int i1, int j1) {
        return (float)Math.sqrt((i0 - i1) * (i0 - i1) + (j0 - j1) * (j0 - j1));
    }
    public float computeDistance(Coord c0, Coord c1) {
        return computeDistance(c0.getI(), c0.getJ(), c1.getI(), c1.getJ());
    }

    public float computeTravelCost(int i0, int j0, int i1, int j1) {
        float h0 = getHeight(i0, j0), h1 = getHeight(i1, j1);
        float climb = (float)Math.pow(Math.abs(h0 - h1) * 1000.0, 1.5);
        float dist = computeDistance(i0,j0, i1,j1);
        return (1.0f + climb) * dist;
    }
    public float computeTravelCost(Coord c0, Coord c1) {
        return computeTravelCost(c0.getI(), c0.getJ(), c1.getI(), c1.getJ());
    }
    public float computeTravelCost(Iterable<Coord> cs) {
        Coord c0 = null;
        float cost = 0.0f;
        for(Coord c1 : cs) {
            if(c0 != null) cost += computeTravelCost(c0, c1);
            c0 = c1;
        }
        return cost;
    }
}

--[ 2019.11.11.17.55.03.410.0 ]--
InitFile: /src/InteractivePathfinderVisualizer.java
import java.awt.event.KeyEvent;

/**
 * InteractivePathfinderVisualizer visualizes the terrain and the computed
 * path and allows the user to change parameters of the Pathfinder.  Below
 * is a list of commands and what they do.  Note: some of the commands
 * modify the properties of the path finder and some modify the terrain.
 *
 * Command        Action                                      Terrain
 * C              clear path
 * space          recompute path
 * S/E            set start/end location to mouse
 * left/right     halve/double path search heuristic value
 * 0/1            set path search heuristic to 0 or 1
 * W              start a walker to show the path
 * R              randomly generate a new terrain                *
 * M              smooths terrain under mouse                    *
 * shift+M        smooths all terrain                            *
 * up/down        increase/decrease terrain under mouse          *
 */

public class InteractivePathfinderVisualizer {
    private final static int DELAY = 10;

    // sets how many redraws it should take for the walker to reach its destination
    private final static float STEPS_TO_WALK = 100.0f;

    // for convenience, here are the emap files that are located under heightmaps/ folder
    // the python script in that folder converts png files to emap. \
    // you can use it to create your own maps to test your code
    private final static String[] emaps = {
            "maze32_0.png.emap",    // 0   (32x32 maze)
            "maze32_1.png.emap",    // 1   (another 32x32 maze)
            "maze232_0.png.emap",   // 2   (232x232 maze)
            "maze320_0.png.emap",   // 3   (same as maze32_0, only scaled up by 10x)
            "mazeAB.png.emap",      // 4   (a maze from a site no longer online :( )
            "mazeBrain.png.emap",   // 5   (...)
            "ramp.png.emap",        // 6   (some tests)
            "ramp2.png.emap",       // 7   (...)
            "ramp3.png.emap",       // 8   (...)
            "usa128.png.emap",      // 9   (elevation map of USA from https://bananas.openttd.org/en/heightmap/)
            "usa256.png.emap",      // 10  (same as usa128, only higher resolution)
            "usa1024.png.emap",     // 11  (same as usa128, only higher resolution
    };

    private final static String emapFilename = emaps[1];        // change index to load a different elevation map



    public static void main(String[] args) {
        Terrain terrain = new Terrain(emapFilename);
        Pathfinder pf = new Pathfinder(terrain);
        int N = terrain.getN();

        StdDraw.show(0);

        // set default starting and ending locations
        pf.setPathStart(new Coord(1, 1));
        pf.setPathEnd(new Coord(N-3, N-3));

        // find a path
        pf.computePath();

        PathfinderVisualizer.draw(terrain, pf, null, N);
        StdDraw.show(DELAY);

        // prevent repeated applications
        boolean keyboardR = false;
        boolean keyboardM = false;

        Walker walker = null;

        while(true) {
            boolean recompute = false;
            boolean redraw = false;

            // mouse location on map
            int mouseI = (int) ((StdDraw.mouseX()-24) / 464 * N);
            int mouseJ = (int) ((464 - (StdDraw.mouseY()-36)) / 464 * N);
            boolean isMouseOnMap = (mouseI >=0 && mouseI < N && mouseJ >= 0 && mouseJ < N);

            if(StdDraw.isKeyPressed(KeyEvent.VK_LEFT) || StdDraw.isKeyPressed(KeyEvent.VK_RIGHT)) {
                boolean keyboardLeft = StdDraw.isKeyPressed(KeyEvent.VK_LEFT);
                float m = keyboardLeft ? 0.5f : 2.0f;
                float h = pf.getHeuristic() * m;
                h = Math.max(1.0f/1024.0f, Math.min(1048576.0f, h));
                pf.setHeuristic(h);
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_0) || StdDraw.isKeyPressed(KeyEvent.VK_1)) {
                boolean keyboard0 = StdDraw.isKeyPressed(KeyEvent.VK_0);
                float h = keyboard0 ? 0 : 1;
                pf.setHeuristic(h);
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_C)) {
                pf.resetPath();
                walker = null;
                redraw = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_R) && !keyboardR) {
                TerrainEditor.setFractalHeights(terrain);
                TerrainEditor.clampHeights(terrain);
                recompute = true;
            }
            keyboardR = StdDraw.isKeyPressed(KeyEvent.VK_R);

            if(StdDraw.isKeyPressed(KeyEvent.VK_M)) {
                if(StdDraw.isKeyPressed(KeyEvent.VK_SHIFT)) {
                    if(!keyboardM) {
                        TerrainEditor.smoothHeights(terrain);
                        recompute = true;
                    }
                } else {
                    TerrainEditor.smoothHeights(mouseI, mouseJ, N / 20, true, terrain);
                    recompute = true;
                }
            }
            keyboardM = StdDraw.isKeyPressed(KeyEvent.VK_M);

            if(StdDraw.isKeyPressed(KeyEvent.VK_SPACE)) {
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_UP) || StdDraw.isKeyPressed(KeyEvent.VK_DOWN)) {
                boolean keyboardUp = StdDraw.isKeyPressed(KeyEvent.VK_UP);
                float add = keyboardUp ? 8.0f : -8.0f;
                TerrainEditor.addHeight(mouseI, mouseJ, N / 20, add, terrain);
                recompute = true;
            }

            if(isMouseOnMap && StdDraw.isKeyPressed(KeyEvent.VK_S)) {
                pf.setPathStart(new Coord(mouseI, mouseJ));
                recompute = true;
            }

            if(isMouseOnMap && StdDraw.isKeyPressed(KeyEvent.VK_E)) {
                pf.setPathEnd(new Coord(mouseI, mouseJ));
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_W)) {
                Iterable<Coord> path = pf.getPathSolution();
                if(path != null) {
                    walker = new Walker(terrain, pf.getPathSolution());
                }
            }

            if(walker != null) {
                if(walker.doneWalking()) {
                    walker = null;
                } else {
                    walker.advance(pf.getPathCost() / STEPS_TO_WALK);
                }
                redraw = true;
            }

            if(recompute) {
                walker = null;
                pf.resetPath();
                if(pf.getPathStart() != null && pf.getPathEnd() != null) {
                    pf.computePath();
                }
                redraw = true;
            }

            if(redraw) {
                PathfinderVisualizer.draw(terrain, pf, walker, N);
                StdDraw.show(DELAY);
            } else {
                try {
                    Thread.sleep(10);
                } catch (InterruptedException e) {
                    /* do nothing */
                }
            }
        }
    }
}

--[ 2019.11.11.17.55.03.411.0 ]--
InitFile: /src/Pathfinder.java
import java.lang.IndexOutOfBoundsException;
import java.lang.IllegalArgumentException;

/**
 * Pathfinder uses A* search to find a near optimal path
 * between to locations with given terrain.
 */

public class Pathfinder {
    private Coord end;
    private Coord start;
    private Terrain terrain;
    private float heur;
    private boolean pathFound = false;  //implement in compute path, set to true when found
    private int searchSize;
    private PFNode[][] board;
    private PFNode endNode;
    private Stack<Coord> stack = new Stack<>();
    //set up Minimum Priority Queue
    private MinPQ<PFNode> pq = new MinPQ<>();
    private float pathCost;

    /**
     * PFNode will be the key for MinPQ (used in computePath())
     */
    private class PFNode implements Comparable<PFNode> {
        private boolean isUsed;
        private boolean invalid;
        private Coord loc;
        private PFNode fromNode;
        private float cost;
        // loc: the location of the PFNode
        // fromNode: how did we get here? (linked list back to start)

        public PFNode(Coord loc, PFNode fromNode) {
            this.loc = loc;
            this.fromNode = fromNode;
            if(fromNode != null)
                cost = fromNode.cost + terrain.computeTravelCost(loc, fromNode.loc);
        }

        // compares this with that, used to find minimum cost PFNode
        public int compareTo(PFNode that) {
            if(this.getCost(heur) < that.getCost(heur)) return -1;  //this < that
            if(that.getCost(heur) < this.getCost(heur)) return 1;   //that < this
            return 0;  //this == that
        }

        // returns the cost to travel from starting point to this
        // via the fromNode chain
        public float getCost(float heuristic) {  //call getCost with heuristic of 0, get travel cost, do A* search
            //return fromNode.getCost(0) + terrain.computeTravelCost(fromNode.loc, loc) + heuristic*terrain.computeDistance(loc.getI(), loc.getJ(), endNode.loc.getI(), endNode.loc.getJ());
            StdOut.println(heuristic);
            StdOut.println(terrain.computeDistance(loc.getI(), loc.getJ(), end.getI(), end.getJ()));
            StdOut.println("Cost:" + cost);
            return cost + heuristic*terrain.computeDistance(loc.getI(), loc.getJ(), end.getI(), end.getJ());
        }

        // returns if this PFNode is not marked invalid
        public boolean isValid() {
            return invalid;
        }

        // marks the PFNode as invalid
        public void invalidate() {
            invalid = true;
        }

        // returns if the PFNode is marked as used
        public boolean isUsed() {  //help
            return isUsed;
        }

        // marks the PFNode as used
        public void use(PFNode node) {
            node.isUsed = true;
        }

        // returns an Iterable of PFNodes that surround this
        public Iterable<PFNode> neighbors() {
            Stack<PFNode> s = new Stack<>();
            s.push(new PFNode(null, null));
            return s;
        }
    }

    public Pathfinder(Terrain terrain) {
        this.terrain = terrain;
    }

    public void setPathStart(Coord loc) { // I need a check to see how it can stay on the white area.
        if(loc == null) throw new IllegalArgumentException("The location is null.");
        if(!loc.isInBounds(0,0,terrain.getN()-1, terrain.getN()-1)) throw new IndexOutOfBoundsException("The location is out of bounds.");
        start = loc;
    }

    public Coord getPathStart() {
        return start;
    }

    public void setPathEnd(Coord loc) {
        if(loc == null) throw new IllegalArgumentException("The location is null.");
        if(!loc.isInBounds(0,0,terrain.getN()-1, terrain.getN()-1)) throw new IndexOutOfBoundsException("The location is out of bounds.");
        end = loc;
    }

    public Coord getPathEnd() {
        return end;
    }

    public void setHeuristic(float v) { // is this correct?
        heur = v;
    }

    public float getHeuristic() { return heur; }

    public void resetPath() {
        start = getPathStart(); //how do I tell it to find where the mouse is at? setPathStart?
        end = getPathEnd();
        endNode = null;
        pathFound = false;
        searchSize = 0;

        pq = new MinPQ<>();

        stack = new Stack<>();

        //computePath();
    }

    public void computePath() {
        if(getPathEnd() == null || getPathStart() == null) throw new IllegalArgumentException("Either or both of start path or end path have NOT been set.");

        //set up logic board with 2D array
        int N = terrain.getN();
        board = new PFNode[N][N];

        //I added this... is it needed?
        //setHeuristic(3);

        PFNode beginNode = new PFNode(getPathStart(), null);
        board[getPathStart().getI()][getPathStart().getJ()] = beginNode;
        pq.insert(beginNode);
        beginNode.use(beginNode);
        beginNode.cost = 0;
        while(!pathFound){
            //remove from pq
            PFNode removed = pq.delMin();
            //StdOut.println("The minimum has been removed.");  //bug check
            //check if node is at end
            if(removed.loc.equals(getPathEnd())){  //correct?
                pq.insert(removed);
                endNode = removed;
                pathFound = true;
                endNode.use(endNode);
                endNode.cost = removed.cost + terrain.computeTravelCost(removed.loc, endNode.loc);
                pathCost = endNode.cost;
                break;
            }
            //"process" node just removed
            //see if the locations around the removed position are in bounds
            //now have them point to removed, "from = removed";  ?
            if(removed.loc.getJ() -1 > 0 ){
               if(board[removed.loc.getI()][removed.loc.getJ()-1] == null){
                    PFNode node = new PFNode(removed.loc.add(0, -1), removed); //good
                    board[removed.loc.getI()][removed.loc.getJ() - 1] = node;
                    pq.insert(node);
                    node.use(node);
                    //node.cost = removed.cost + terrain.computeTravelCost(removed.loc, node.loc);
                }
            }
            if(removed.loc.getI() - 1 > 0){
                if(board[removed.loc.getI()-1][removed.loc.getJ()] == null) {
                    PFNode node = new PFNode(removed.loc.add(-1, 0), removed); //good
                    board[removed.loc.getI() - 1][removed.loc.getJ()] = node;
                    pq.insert(node);
                    node.use(node);
                    node.cost = removed.cost + terrain.computeTravelCost(removed.loc, node.loc);
                }
            }
            if(removed.loc.getJ() + 1 < N-2){
                if(board[removed.loc.getI()][removed.loc.getJ()+1] == null) {
                    PFNode node = new PFNode(removed.loc.add(0, 1), removed); //good
                    board[removed.loc.getI()][removed.loc.getJ() + 1] = node;
                    pq.insert(node);
                    node.use(node);
                    node.cost = removed.cost + terrain.computeTravelCost(removed.loc, node.loc);
                }
            }
            if(removed.loc.getI() + 1 < N-2){
                if(board[removed.loc.getI()+1][removed.loc.getJ()] == null) {
                    PFNode node = new PFNode(removed.loc.add(1, 0), removed); //good
                    board[removed.loc.getI() + 1][removed.loc.getJ()] = node;
                    pq.insert(node);
                    node.use(node);
                    node.cost = removed.cost + terrain.computeTravelCost(removed.loc, node.loc);
                }
            }
        }
        //StdOut.println("A connection has been found!");

        stack.push(endNode.loc);
        searchSize = 1;
        PFNode nextNode = endNode.fromNode;
        while(nextNode.fromNode != beginNode){
            stack.push(nextNode.loc);
            nextNode = nextNode.fromNode;
            searchSize ++;
        }
        //this should be the start node
        stack.push(nextNode.fromNode.loc);
        searchSize ++;
    }

    public boolean foundPath() { //good
        return pathFound;
    }

    public float getPathCost() { //good
        return pathCost;
    }

    public int getSearchSize() { //good
        return searchSize;
    }

    public Iterable<Coord> getPathSolution() {
        return stack;
    } //good

    public boolean wasSearched(Coord loc) { //good
        return board[loc.getI()][loc.getJ()] != null;
    }

}

--[ 2019.11.11.17.55.03.412.0 ]--
InitFile: /.cos265


--[ 2019.11.11.19.39.09.676.0 ]--
UpdateTree (AD): 1 0
+ /P04_Pathfinding.zip

--[ 2019.11.11.19.39.09.680.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.11.19.47.44.546.0 ]--
:/src/Walker.java
+ 11     
--[ 2019.11.11.19.47.45.660.0 ]--
r 11     pr
--[ 2019.11.11.19.47.45.789.0 ]--
r 11     pri
--[ 2019.11.11.19.47.46.212.0 ]--
r 11     priv
--[ 2019.11.11.19.47.46.336.0 ]--
r 11     priva
--[ 2019.11.11.19.47.46.576.0 ]--
r 11     privat
--[ 2019.11.11.19.47.46.740.0 ]--
r 11     private
--[ 2019.11.11.19.47.47.427.0 ]--
r 11     private 
--[ 2019.11.11.19.47.47.860.0 ]--
r 11     private n
--[ 2019.11.11.19.47.48.012.0 ]--
r 11     private nu
--[ 2019.11.11.19.47.48.187.0 ]--
r 11     private num
--[ 2019.11.11.19.47.48.367.0 ]--
r 11     private nums
--[ 2019.11.11.19.47.48.961.0 ]--
r 11     private numsC
--[ 2019.11.11.19.47.49.156.0 ]--
r 11     private numsCa
--[ 2019.11.11.19.47.49.315.0 ]--
r 11     private numsCal
--[ 2019.11.11.19.47.49.503.0 ]--
r 11     private numsCals
--[ 2019.11.11.19.47.50.258.0 ]--
r 11     private numsCal
--[ 2019.11.11.19.47.50.550.0 ]--
r 11     private numsCall
--[ 2019.11.11.19.47.50.684.0 ]--
r 11     private numsCalls
--[ 2019.11.11.19.47.50.769.0 ]--
r 11     private numsCallse
--[ 2019.11.11.19.47.51.552.0 ]--
r 11     private numsCalls
--[ 2019.11.11.19.47.51.826.0 ]--
r 11     private numsCall
--[ 2019.11.11.19.47.51.973.0 ]--
r 11     private numsCalle
--[ 2019.11.11.19.47.52.146.0 ]--
r 11     private numsCalled
--[ 2019.11.11.19.47.53.165.0 ]--
r 11     private numsCalled;
--[ 2019.11.11.19.47.58.310.0 ]--
r 11     private inumsCalled;
--[ 2019.11.11.19.47.58.393.0 ]--
r 11     private innumsCalled;
--[ 2019.11.11.19.47.58.647.0 ]--
r 11     private intnumsCalled;
--[ 2019.11.11.19.47.58.933.0 ]--
r 11     private int numsCalled;
--[ 2019.11.11.19.48.06.676.0 ]--
+ 34         
--[ 2019.11.11.19.48.08.671.0 ]--
r 34         n
--[ 2019.11.11.19.48.09.363.0 ]--
r 34         nu
--[ 2019.11.11.19.48.09.652.0 ]--
r 34         num
--[ 2019.11.11.19.48.09.854.0 ]--
r 34         nums
--[ 2019.11.11.19.48.10.275.0 ]--
r 34         numsC
--[ 2019.11.11.19.48.10.477.0 ]--
r 34         numsCa
--[ 2019.11.11.19.48.10.670.0 ]--
r 34         numsCal
--[ 2019.11.11.19.48.10.786.0 ]--
r 34         numsCall
--[ 2019.11.11.19.48.10.865.0 ]--
r 34         numsCalle
--[ 2019.11.11.19.48.11.061.0 ]--
r 34         numsCalled
--[ 2019.11.11.19.48.12.572.0 ]--
r 34         numsCalled 
--[ 2019.11.11.19.48.13.045.0 ]--
r 34         numsCalled +
--[ 2019.11.11.19.48.13.215.0 ]--
r 34         numsCalled ++
--[ 2019.11.11.19.48.13.993.0 ]--
r 34         numsCalled ++;
--[ 2019.11.11.19.48.32.202.0 ]--
+ 22         
--[ 2019.11.11.19.48.32.695.0 ]--
r 22         f
--[ 2019.11.11.19.48.32.814.0 ]--
r 22         fo
--[ 2019.11.11.19.48.32.884.0 ]--
r 22         for
--[ 2019.11.11.19.48.33.007.0 ]--
r 22         for 
--[ 2019.11.11.19.48.48.211.0 ]--
r 22         for ()
--[ 2019.11.11.19.48.50.428.0 ]--
r 22         for (c)
--[ 2019.11.11.19.48.50.496.0 ]--
r 22         for (co)
--[ 2019.11.11.19.48.50.622.0 ]--
r 22         for (coo)
--[ 2019.11.11.19.48.51.244.0 ]--
r 22         for (coo\)
--[ 2019.11.11.19.48.51.697.0 ]--
r 22         for (coo)
--[ 2019.11.11.19.48.52.404.0 ]--
r 22         for (coor)
--[ 2019.11.11.19.48.52.672.0 ]--
r 22         for (coord)
--[ 2019.11.11.19.48.53.690.0 ]--
r 22         for (coord:)
--[ 2019.11.11.19.48.53.956.0 ]--
r 22         for (coord: )
--[ 2019.11.11.19.48.54.697.0 ]--
r 22         for (coord: p)
--[ 2019.11.11.19.48.54.772.0 ]--
r 22         for (coord: pa)
--[ 2019.11.11.19.48.55.065.0 ]--
r 22         for (coord: pat)
--[ 2019.11.11.19.48.55.159.0 ]--
r 22         for (coord: path)
--[ 2019.11.11.19.48.56.810.0 ]--
r 22         for (coord: path){
--[ 2019.11.11.19.48.57.114.0 ]--
+ 23 
+ 24 }
--[ 2019.11.11.19.48.57.147.0 ]--
r 24         }
--[ 2019.11.11.19.48.57.168.0 ]--
r 23             
--[ 2019.11.11.19.49.16.219.0 ]--
r 22         for (oord: path){
--[ 2019.11.11.19.49.16.713.0 ]--
r 22         for (Coord: path){
--[ 2019.11.11.19.49.18.324.0 ]--
r 22         for (Coord : path){
--[ 2019.11.11.19.49.19.023.0 ]--
r 22         for (Coord a: path){
--[ 2019.11.11.19.49.24.106.0 ]--
r 23             a
--[ 2019.11.11.19.49.24.251.0 ]--
r 23             ad
--[ 2019.11.11.19.49.24.460.0 ]--
r 23             adv
--[ 2019.11.11.19.49.24.560.0 ]--
r 23             adva
--[ 2019.11.11.19.49.24.721.0 ]--
r 23             advan
--[ 2019.11.11.19.49.24.835.0 ]--
r 23             advanc
--[ 2019.11.11.19.49.24.977.0 ]--
r 23             advance
--[ 2019.11.11.19.49.26.307.0 ]--
r 23             advance()
--[ 2019.11.11.19.49.26.318.0 ]--
r 23             advance();
--[ 2019.11.11.19.51.01.010.0 ]--
r 23             advance(c);
--[ 2019.11.11.19.51.01.100.0 ]--
r 23             advance(co);
--[ 2019.11.11.19.51.01.170.0 ]--
r 23             advance(com);
--[ 2019.11.11.19.51.01.350.0 ]--
r 23             advance(comp);
--[ 2019.11.11.19.51.01.955.0 ]--
r 23             advance(com);
--[ 2019.11.11.19.51.02.103.0 ]--
r 23             advance(co);
--[ 2019.11.11.19.51.02.252.0 ]--
r 23             advance(c);
--[ 2019.11.11.19.51.02.589.0 ]--
r 23             advance();
--[ 2019.11.11.19.51.03.068.0 ]--
r 23             advance(t);
--[ 2019.11.11.19.51.03.256.0 ]--
r 23             advance(te);
--[ 2019.11.11.19.51.03.353.0 ]--
r 23             advance(ter);
--[ 2019.11.11.19.51.03.505.0 ]--
r 23             advance(terr);
--[ 2019.11.11.19.51.03.672.0 ]--
r 23             advance(terra);
--[ 2019.11.11.19.51.03.799.0 ]--
r 23             advance(terrai);
--[ 2019.11.11.19.51.03.906.0 ]--
r 23             advance(terrain);
--[ 2019.11.11.19.51.04.313.0 ]--
r 23             advance(terrain.);
--[ 2019.11.11.19.51.05.113.0 ]--
r 23             advance(terrain.c);
--[ 2019.11.11.19.51.05.212.0 ]--
r 23             advance(terrain.co);
--[ 2019.11.11.19.51.05.312.0 ]--
r 23             advance(terrain.com);
--[ 2019.11.11.19.51.05.517.0 ]--
r 23             advance(terrain.comp);
--[ 2019.11.11.19.51.06.096.0 ]--
r 23             advance(terrain.computeTravelCost);
--[ 2019.11.11.19.51.06.109.0 ]--
r 23             advance(terrain.computeTravelCost());
--[ 2019.11.11.19.51.08.494.0 ]--
r 23             advance(terrain.computeTravelCost);
--[ 2019.11.11.19.51.10.188.0 ]--
r 23             advance(terrain.computeTravelCos);
--[ 2019.11.11.19.51.10.324.0 ]--
r 23             advance(terrain.computeTravelCo);
--[ 2019.11.11.19.51.10.489.0 ]--
r 23             advance(terrain.computeTravelC);
--[ 2019.11.11.19.51.10.664.0 ]--
r 23             advance(terrain.computeTravel);
--[ 2019.11.11.19.51.11.379.0 ]--
r 23             advance(terrain.computeTravelC);
--[ 2019.11.11.19.51.13.973.0 ]--
r 23             advance(terrain.computeTravelCost);
--[ 2019.11.11.19.51.14.001.0 ]--
r 23             advance(terrain.computeTravelCost());
--[ 2019.11.11.19.51.15.905.0 ]--
r 23             advance(terrain.computeTravelCost(a));
--[ 2019.11.11.19.54.50.031.0 ]--
+ 24             
--[ 2019.11.11.19.54.53.192.0 ]--
r 24             l
--[ 2019.11.11.19.54.53.271.0 ]--
r 24             la
--[ 2019.11.11.19.54.53.427.0 ]--
r 24             las
--[ 2019.11.11.19.54.53.886.0 ]--
r 24             last
--[ 2019.11.11.19.54.54.821.0 ]--
r 24             lastC
--[ 2019.11.11.19.54.55.225.0 ]--
r 24             lastCo
--[ 2019.11.11.19.54.55.370.0 ]--
r 24             lastCoo
--[ 2019.11.11.19.54.55.478.0 ]--
r 24             lastCoor
--[ 2019.11.11.19.54.55.735.0 ]--
r 24             lastCoord
--[ 2019.11.11.19.54.57.207.0 ]--
r 24             lastCoord 
--[ 2019.11.11.19.54.57.266.0 ]--
r 24             lastCoord =
--[ 2019.11.11.19.54.57.336.0 ]--
r 24             lastCoord = 
--[ 2019.11.11.19.54.58.415.0 ]--
r 24             lastCoord = n
--[ 2019.11.11.19.54.58.665.0 ]--
r 24             lastCoord = nu
--[ 2019.11.11.19.54.58.996.0 ]--
r 24             lastCoord = nul
--[ 2019.11.11.19.54.59.611.0 ]--
r 24             lastCoord = nu
--[ 2019.11.11.19.54.59.802.0 ]--
r 24             lastCoord = n
--[ 2019.11.11.19.55.00.184.0 ]--
r 24             lastCoord = 
--[ 2019.11.11.19.55.04.663.0 ]--
r 24             lastCoord = a
--[ 2019.11.11.19.55.06.072.0 ]--
r 24             lastCoord = a;
--[ 2019.11.11.19.55.09.587.0 ]--
+ 22         
--[ 2019.11.11.19.55.10.536.0 ]--
r 22         C
--[ 2019.11.11.19.55.10.886.0 ]--
r 22         Co
--[ 2019.11.11.19.55.10.995.0 ]--
r 22         Coo
--[ 2019.11.11.19.55.11.501.0 ]--
r 22         Coor
--[ 2019.11.11.19.55.11.674.0 ]--
r 22         Coord
--[ 2019.11.11.19.55.11.883.0 ]--
r 22         Coord 
--[ 2019.11.11.19.55.12.472.0 ]--
r 22         Coord l
--[ 2019.11.11.19.55.12.548.0 ]--
r 22         Coord la
--[ 2019.11.11.19.55.12.680.0 ]--
r 22         Coord las
--[ 2019.11.11.19.55.12.995.0 ]--
r 22         Coord last
--[ 2019.11.11.19.55.13.294.0 ]--
r 22         Coord lastC
--[ 2019.11.11.19.55.13.495.0 ]--
r 22         Coord lastCo
--[ 2019.11.11.19.55.13.665.0 ]--
r 22         Coord lastCoo
--[ 2019.11.11.19.55.13.771.0 ]--
r 22         Coord lastCoor
--[ 2019.11.11.19.55.13.999.0 ]--
r 22         Coord lastCoord
--[ 2019.11.11.19.55.15.764.0 ]--
r 22         Coord lastCoord;
--[ 2019.11.11.19.55.21.366.0 ]--
+ 24             
--[ 2019.11.11.19.55.21.940.0 ]--
r 24             i
--[ 2019.11.11.19.55.22.074.0 ]--
r 24             if
--[ 2019.11.11.19.55.24.614.0 ]--
r 24             if 
--[ 2019.11.11.19.55.25.278.0 ]--
r 24             if
--[ 2019.11.11.19.55.26.224.0 ]--
r 24             if()
--[ 2019.11.11.19.55.26.502.0 ]--
r 24             if(l)
--[ 2019.11.11.19.55.26.733.0 ]--
r 24             if(la)
--[ 2019.11.11.19.55.26.937.0 ]--
r 24             if(las)
--[ 2019.11.11.19.55.27.873.0 ]--
r 24             if(lastCoord)
--[ 2019.11.11.19.55.28.783.0 ]--
r 24             if(lastCoord )
--[ 2019.11.11.19.55.28.889.0 ]--
r 24             if(lastCoord =)
--[ 2019.11.11.19.55.28.933.0 ]--
r 24             if(lastCoord = )
--[ 2019.11.11.19.55.29.427.0 ]--
r 24             if(lastCoord = n)
--[ 2019.11.11.19.55.29.574.0 ]--
r 24             if(lastCoord = nu)
--[ 2019.11.11.19.55.29.790.0 ]--
r 24             if(lastCoord = nul)
--[ 2019.11.11.19.55.29.922.0 ]--
r 24             if(lastCoord = null)
--[ 2019.11.11.19.55.32.718.0 ]--
r 24             if(lastCoord = null){
--[ 2019.11.11.19.55.33.056.0 ]--
+ 25 
+ 26 }
--[ 2019.11.11.19.55.33.085.0 ]--
r 26             }
--[ 2019.11.11.19.55.33.110.0 ]--
r 25                 
--[ 2019.11.11.19.55.34.460.0 ]--
r 25                 r
--[ 2019.11.11.19.55.34.621.0 ]--
r 25                 re
--[ 2019.11.11.19.55.38.545.0 ]--
r 25                 ret
--[ 2019.11.11.19.55.38.860.0 ]--
r 25                 retu
--[ 2019.11.11.19.55.38.973.0 ]--
r 25                 retur
--[ 2019.11.11.19.55.39.060.0 ]--
r 25                 return
--[ 2019.11.11.19.55.39.593.0 ]--
r 25                 return 
--[ 2019.11.11.19.55.41.569.0 ]--
r 25                 return n
--[ 2019.11.11.19.55.41.700.0 ]--
r 25                 return nu
--[ 2019.11.11.19.55.41.902.0 ]--
r 25                 return nul
--[ 2019.11.11.19.55.42.045.0 ]--
r 25                 return null
--[ 2019.11.11.19.55.42.945.0 ]--
r 25                 return null;
--[ 2019.11.11.19.55.46.142.0 ]--
r 24             if(lastCoord == null){
--[ 2019.11.11.19.55.57.794.0 ]--
r 22         Coord lastCoord=;
--[ 2019.11.11.19.55.57.819.0 ]--
r 22         Coord lastCoord=null;
--[ 2019.11.11.19.55.57.897.0 ]--
r 22         Coord lastCoord = null;
--[ 2019.11.11.19.55.57.991.0 ]--
r 22         Coord lastCoord = ;
--[ 2019.11.11.19.55.58.012.0 ]--
r 22         Coord lastCoord = null;
--[ 2019.11.11.19.56.57.834.0 ]--
- 24
- 24
r 24 
--[ 2019.11.11.19.56.58.341.0 ]--
- 24
--[ 2019.11.11.19.57.58.989.0 ]--
r 24             advance(terrain.computeTravelCost());
--[ 2019.11.11.19.57.59.760.0 ]--
r 24             advance(terrain.computeTravelCost);
--[ 2019.11.11.19.58.00.945.0 ]--
r 24             advance(terrain.computeTravelCos);
--[ 2019.11.11.19.58.01.213.0 ]--
r 24             advance(terrain.computeTravelCo);
--[ 2019.11.11.19.58.02.617.0 ]--
r 24             advance(terrain.computeTravelCo;
--[ 2019.11.11.19.58.04.422.0 ]--
r 24             advance(terrain.computeTravelCos;
--[ 2019.11.11.19.58.06.251.0 ]--
r 24             advance(terrain.computeTravelCost;
--[ 2019.11.11.19.58.06.277.0 ]--
r 24             advance(terrain.computeTravelCost();
--[ 2019.11.11.19.58.08.177.0 ]--
r 24             advance(terrain.computeTravelCost(l);
--[ 2019.11.11.19.58.08.243.0 ]--
r 24             advance(terrain.computeTravelCost(la);
--[ 2019.11.11.19.58.08.350.0 ]--
r 24             advance(terrain.computeTravelCost(las);
--[ 2019.11.11.19.58.09.253.0 ]--
r 24             advance(terrain.computeTravelCost(lastCoord);
--[ 2019.11.11.19.58.10.703.0 ]--
r 24             advance(terrain.computeTravelCost(lastCoord,);
--[ 2019.11.11.19.58.10.885.0 ]--
r 24             advance(terrain.computeTravelCost(lastCoord, );
--[ 2019.11.11.19.58.11.877.0 ]--
r 24             advance(terrain.computeTravelCost(lastCoord, a);
--[ 2019.11.11.19.58.49.708.0 ]--
r 24             advance(terrain.computeTravelCost(lastCoord, a));
--[ 2019.11.11.20.00.55.356.0 ]--
r 22         /Coord lastCoord = null;
--[ 2019.11.11.20.00.56.197.0 ]--
r 22         /*Coord lastCoord = null;
--[ 2019.11.11.20.01.01.307.0 ]--
r 26         }*
--[ 2019.11.11.20.01.01.599.0 ]--
r 26         }*/
--[ 2019.11.11.20.01.03.689.0 ]--
+ 27         
--[ 2019.11.11.20.01.04.786.0 ]--
r 27         r
--[ 2019.11.11.20.01.04.872.0 ]--
r 27         re
--[ 2019.11.11.20.01.05.896.0 ]--
r 27         r
--[ 2019.11.11.20.01.06.081.0 ]--
r 27         
--[ 2019.11.11.20.01.06.614.0 ]--
r 27         t
--[ 2019.11.11.20.01.06.690.0 ]--
r 27         th
--[ 2019.11.11.20.01.06.762.0 ]--
r 27         thi
--[ 2019.11.11.20.01.06.929.0 ]--
r 27         this
--[ 2019.11.11.20.01.08.191.0 ]--
r 27         this.
--[ 2019.11.11.20.01.10.055.0 ]--
r 27         this
--[ 2019.11.11.20.01.10.167.0 ]--
r 27         thi
--[ 2019.11.11.20.01.10.330.0 ]--
r 27         th
--[ 2019.11.11.20.01.10.505.0 ]--
r 27         t
--[ 2019.11.11.20.01.10.655.0 ]--
r 27         
--[ 2019.11.11.20.01.11.232.0 ]--
r 27         t
--[ 2019.11.11.20.01.11.433.0 ]--
r 27         te
--[ 2019.11.11.20.01.11.569.0 ]--
r 27         ter
--[ 2019.11.11.20.01.11.726.0 ]--
r 27         terr
--[ 2019.11.11.20.01.12.245.0 ]--
r 27         terrain
--[ 2019.11.11.20.01.13.040.0 ]--
r 27         terrain.
--[ 2019.11.11.20.01.35.583.0 ]--
r 27         terrain
--[ 2019.11.11.20.01.35.725.0 ]--
r 27         terrai
--[ 2019.11.11.20.01.35.913.0 ]--
r 27         terra
--[ 2019.11.11.20.01.36.068.0 ]--
r 27         terr
--[ 2019.11.11.20.01.36.232.0 ]--
r 27         ter
--[ 2019.11.11.20.01.36.379.0 ]--
r 27         te
--[ 2019.11.11.20.01.36.524.0 ]--
r 27         t
--[ 2019.11.11.20.01.36.788.0 ]--
r 27         
--[ 2019.11.11.20.01.37.356.0 ]--
r 27         p
--[ 2019.11.11.20.01.37.691.0 ]--
r 27         pt
--[ 2019.11.11.20.01.38.590.0 ]--
r 27         p
--[ 2019.11.11.20.01.38.729.0 ]--
r 27         pa
--[ 2019.11.11.20.01.38.889.0 ]--
r 27         pat
--[ 2019.11.11.20.01.39.053.0 ]--
r 27         path
--[ 2019.11.11.20.01.39.956.0 ]--
r 27         path,
--[ 2019.11.11.20.01.40.700.0 ]--
r 27         path
--[ 2019.11.11.20.01.41.574.0 ]--
r 27         path.
--[ 2019.11.11.20.01.43.116.0 ]--
r 27         path.g
--[ 2019.11.11.20.01.43.226.0 ]--
r 27         path.ge
--[ 2019.11.11.20.01.43.438.0 ]--
r 27         path.get
--[ 2019.11.11.20.01.44.243.0 ]--
r 27         path.ge
--[ 2019.11.11.20.01.44.425.0 ]--
r 27         path.g
--[ 2019.11.11.20.01.44.743.0 ]--
r 27         path.
--[ 2019.11.11.20.01.46.080.0 ]--
r 27         path
--[ 2019.11.11.20.01.46.293.0 ]--
r 27         pat
--[ 2019.11.11.20.01.46.463.0 ]--
r 27         pa
--[ 2019.11.11.20.01.46.650.0 ]--
r 27         p
--[ 2019.11.11.20.01.46.852.0 ]--
r 27         
--[ 2019.11.11.20.01.47.207.0 ]--
- 27
--[ 2019.11.11.20.03.30.504.0 ]--
r 26         }*
--[ 2019.11.11.20.03.30.615.0 ]--
r 26         }
--[ 2019.11.11.20.03.33.756.0 ]--
r 22         /Coord lastCoord = null;
--[ 2019.11.11.20.03.33.880.0 ]--
r 22         Coord lastCoord = null;
--[ 2019.11.11.20.05.33.371.0 ]--
r 27 
--[ 2019.11.11.20.05.33.713.0 ]--
- 27
--[ 2019.11.11.20.09.49.767.0 ]--
r 27 
--[ 2019.11.11.20.09.50.187.0 ]--
- 27
--[ 2019.11.11.20.10.10.358.0 ]--
- 22
- 22
- 22
- 22
r 22 
--[ 2019.11.11.20.10.13.402.0 ]--
+ 18         
--[ 2019.11.11.20.10.13.714.0 ]--
+ 18                 Coord lastCoord = null;
+ 19         for (Coord a: path){
+ 20             advance(terrain.computeTravelCost(lastCoord, a));
+ 21             lastCoord = a;
r 22         }
--[ 2019.11.11.20.10.13.799.0 ]--
r 18         Coord lastCoord = null;
--[ 2019.11.11.20.10.18.783.0 ]--
- 27
--[ 2019.11.11.20.10.19.931.0 ]--
+ 27         
--[ 2019.11.11.20.10.20.423.0 ]--
r 27         r
--[ 2019.11.11.20.10.20.615.0 ]--
r 27         re
--[ 2019.11.11.20.10.22.150.0 ]--
r 27         ret
--[ 2019.11.11.20.10.22.300.0 ]--
r 27         retu
--[ 2019.11.11.20.10.22.427.0 ]--
r 27         retur
--[ 2019.11.11.20.10.22.525.0 ]--
r 27         return
--[ 2019.11.11.20.10.24.331.0 ]--
r 27         return 
--[ 2019.11.11.20.10.27.204.0 ]--
r 27         return t
--[ 2019.11.11.20.10.27.304.0 ]--
r 27         return th
--[ 2019.11.11.20.10.27.372.0 ]--
r 27         return thi
--[ 2019.11.11.20.10.27.446.0 ]--
r 27         return this
--[ 2019.11.11.20.10.27.635.0 ]--
r 27         return this,
--[ 2019.11.11.20.10.29.017.0 ]--
r 27         return this
--[ 2019.11.11.20.10.29.669.0 ]--
r 27         return this.
--[ 2019.11.11.20.10.30.199.0 ]--
r 27         return this.p
--[ 2019.11.11.20.10.31.196.0 ]--
r 27         return this.po
--[ 2019.11.11.20.10.31.249.0 ]--
r 27         return this.pos
--[ 2019.11.11.20.10.31.805.0 ]--
r 27         return this.posi
--[ 2019.11.11.20.10.32.072.0 ]--
r 27         return this.posit
--[ 2019.11.11.20.10.32.137.0 ]--
r 27         return this.positi
--[ 2019.11.11.20.10.32.218.0 ]--
r 27         return this.positio
--[ 2019.11.11.20.10.32.279.0 ]--
r 27         return this.position
--[ 2019.11.11.20.10.33.161.0 ]--
r 27         return this.positionl
--[ 2019.11.11.20.10.33.524.0 ]--
r 27         return this.position
--[ 2019.11.11.20.10.34.193.0 ]--
r 27         return this.position;
--[ 2019.11.11.20.10.38.505.0 ]--
+ 18         
--[ 2019.11.11.20.10.39.881.0 ]--
r 18         t
--[ 2019.11.11.20.10.39.964.0 ]--
r 18         th
--[ 2019.11.11.20.10.40.028.0 ]--
r 18         thi
--[ 2019.11.11.20.10.40.132.0 ]--
r 18         this
--[ 2019.11.11.20.10.40.298.0 ]--
r 18         this.
--[ 2019.11.11.20.10.41.180.0 ]--
r 18         this.p
--[ 2019.11.11.20.10.41.308.0 ]--
r 18         this.po
--[ 2019.11.11.20.10.41.576.0 ]--
r 18         this.pos
--[ 2019.11.11.20.10.42.281.0 ]--
r 18         this.posi
--[ 2019.11.11.20.10.42.385.0 ]--
r 18         this.posit
--[ 2019.11.11.20.10.42.487.0 ]--
r 18         this.positi
--[ 2019.11.11.20.10.42.614.0 ]--
r 18         this.positio
--[ 2019.11.11.20.10.42.681.0 ]--
r 18         this.position
--[ 2019.11.11.20.10.46.470.0 ]--
+ 12     
--[ 2019.11.11.20.10.46.915.0 ]--
r 12     p
--[ 2019.11.11.20.10.47.069.0 ]--
r 12     pr
--[ 2019.11.11.20.10.47.247.0 ]--
r 12     pri
--[ 2019.11.11.20.10.47.473.0 ]--
r 12     priv
--[ 2019.11.11.20.10.47.580.0 ]--
r 12     priva
--[ 2019.11.11.20.10.47.784.0 ]--
r 12     privat
--[ 2019.11.11.20.10.47.975.0 ]--
r 12     private
--[ 2019.11.11.20.10.48.328.0 ]--
r 12     private 
--[ 2019.11.11.20.10.48.465.0 ]--
r 12     private i
--[ 2019.11.11.20.10.48.546.0 ]--
r 12     private in
--[ 2019.11.11.20.10.49.635.0 ]--
r 12     private i
--[ 2019.11.11.20.10.49.893.0 ]--
r 12     private 
--[ 2019.11.11.20.10.50.423.0 ]--
r 12     private C
--[ 2019.11.11.20.10.50.705.0 ]--
r 12     private Co
--[ 2019.11.11.20.10.50.806.0 ]--
r 12     private Coo
--[ 2019.11.11.20.10.50.940.0 ]--
r 12     private Coor
--[ 2019.11.11.20.10.51.176.0 ]--
r 12     private Coord
--[ 2019.11.11.20.10.51.499.0 ]--
r 12     private Coord 
--[ 2019.11.11.20.10.52.018.0 ]--
r 12     private Coord p
--[ 2019.11.11.20.10.52.107.0 ]--
r 12     private Coord po
--[ 2019.11.11.20.10.52.294.0 ]--
r 12     private Coord pos
--[ 2019.11.11.20.10.52.709.0 ]--
r 12     private Coord posi
--[ 2019.11.11.20.10.52.874.0 ]--
r 12     private Coord posit
--[ 2019.11.11.20.10.52.961.0 ]--
r 12     private Coord positi
--[ 2019.11.11.20.10.53.032.0 ]--
r 12     private Coord positio
--[ 2019.11.11.20.10.53.113.0 ]--
r 12     private Coord position
--[ 2019.11.11.20.10.53.232.0 ]--
r 12     private Coord positions
--[ 2019.11.11.20.10.53.889.0 ]--
r 12     private Coord position
--[ 2019.11.11.20.10.54.559.0 ]--
r 12     private Coord position;
--[ 2019.11.11.20.10.58.496.0 ]--
r 19         this.position 
--[ 2019.11.11.20.10.58.763.0 ]--
r 19         this.position =
--[ 2019.11.11.20.10.58.890.0 ]--
r 19         this.position = 
--[ 2019.11.11.20.10.59.173.0 ]--
r 19         this.position = p
--[ 2019.11.11.20.10.59.284.0 ]--
r 19         this.position = po
--[ 2019.11.11.20.10.59.516.0 ]--
r 19         this.position = pos
--[ 2019.11.11.20.10.59.686.0 ]--
r 19         this.position = posi
--[ 2019.11.11.20.10.59.899.0 ]--
r 19         this.position = posit
--[ 2019.11.11.20.10.59.952.0 ]--
r 19         this.position = positi
--[ 2019.11.11.20.11.00.032.0 ]--
r 19         this.position = positio
--[ 2019.11.11.20.11.00.095.0 ]--
r 19         this.position = position
--[ 2019.11.11.20.11.01.037.0 ]--
r 19         this.position = position;
--[ 2019.11.11.20.11.34.238.0 ]--
r 12     /private Coord position;
--[ 2019.11.11.20.11.34.353.0 ]--
r 12     //private Coord position;
--[ 2019.11.11.20.11.36.079.0 ]--
r 12     /private Coord position;
--[ 2019.11.11.20.11.36.495.0 ]--
r 12     private Coord position;
--[ 2019.11.11.20.11.41.258.0 ]--
r 19         /this.position = position;
--[ 2019.11.11.20.11.41.379.0 ]--
r 19         //this.position = position;
--[ 2019.11.11.20.11.52.572.0 ]--
r 19 
--[ 2019.11.11.20.11.52.898.0 ]--
- 19
--[ 2019.11.11.20.12.04.443.0 ]--
- 21
r 21             p
--[ 2019.11.11.20.12.04.681.0 ]--
r 21             po
--[ 2019.11.11.20.12.04.824.0 ]--
r 21             pos
--[ 2019.11.11.20.12.05.733.0 ]--
r 21             position
--[ 2019.11.11.20.12.06.529.0 ]--
r 21             position 
--[ 2019.11.11.20.12.06.619.0 ]--
r 21             position =
--[ 2019.11.11.20.12.06.683.0 ]--
r 21             position = 
--[ 2019.11.11.20.12.07.226.0 ]--
r 21             position = a
--[ 2019.11.11.20.12.07.711.0 ]--
r 21             position = a;
--[ 2019.11.11.20.12.24.302.0 ]--
r 19         
--[ 2019.11.11.20.12.24.681.0 ]--
- 19
--[ 2019.11.11.20.12.24.859.0 ]--
r 18         this.path = path
--[ 2019.11.11.20.12.26.006.0 ]--
r 18         this.path = path;
--[ 2019.11.11.20.13.38.404.0 ]--
- 19
- 19
r 19 
--[ 2019.11.11.20.13.39.561.0 ]--
- 19
--[ 2019.11.11.20.13.51.420.0 ]--
+ 19         
--[ 2019.11.11.20.13.51.625.0 ]--
+ 19                 for (Coord a: path){
+ 20             position = a;
r 21         }
--[ 2019.11.11.20.13.51.686.0 ]--
r 19         for (Coord a: path){
--[ 2019.11.11.23.28.52.244.0 ]--
NewLogger: P04_Pathfinding
Version: 1.3
--[ 2019.11.11.23.28.52.287.0 ]--
InitTree:
/out/production/P04_Pathfinding/.donotlog
/out/production/P04_Pathfinding/algs4.jar
/out/production/P04_Pathfinding/stdlib.jar
/out/production/P04_Pathfinding/Coord.class
/out/production/P04_Pathfinding/png2emap.py
/out/production/P04_Pathfinding/Walker.class
/out/production/P04_Pathfinding/ramp.png.emap
/out/production/P04_Pathfinding/Terrain.class
/out/production/P04_Pathfinding/ramp2.png.emap
/out/production/P04_Pathfinding/ramp3.png.emap
/out/production/P04_Pathfinding/mazeAB.png.emap
/out/production/P04_Pathfinding/usa128.png.emap
/out/production/P04_Pathfinding/usa256.png.emap
/out/production/P04_Pathfinding/Pathfinder.class
/out/production/P04_Pathfinding/usa1024.png.emap
/out/production/P04_Pathfinding/maze32_0.png.emap
/out/production/P04_Pathfinding/maze32_1.png.emap
/out/production/P04_Pathfinding/maze232_0.png.emap
/out/production/P04_Pathfinding/maze320_0.png.emap
/out/production/P04_Pathfinding/mazeBrain.png.emap
/out/production/P04_Pathfinding/TerrainEditor.class
/out/production/P04_Pathfinding/Pathfinder$PFNode.class
/out/production/P04_Pathfinding/PathfinderVisualizer.class
/out/production/P04_Pathfinding/InteractivePathfinderVisualizer.class
/src/algs4.jar
/src/Coord.java
/src/stdlib.jar
/src/Walker.java
/src/Terrain.java
/src/Pathfinder.java
/src/TerrainEditor.java
/src/PathfinderVisualizer.java
/src/InteractivePathfinderVisualizer.java
/.log/history.log
/.idea/copyright/profiles_settings.xml
/.idea/libraries/algs4.xml
/.idea/libraries/stdlib.xml
/.idea/.name
/.idea/misc.xml
/.idea/modules.xml
/.idea/compiler.xml
/.idea/workspace.xml
/.idea/uiDesigner.xml
/heightmaps/.donotlog
/heightmaps/png2emap.py
/heightmaps/ramp.png.emap
/heightmaps/ramp2.png.emap
/heightmaps/ramp3.png.emap
/heightmaps/mazeAB.png.emap
/heightmaps/usa128.png.emap
/heightmaps/usa256.png.emap
/heightmaps/usa1024.png.emap
/heightmaps/maze32_0.png.emap
/heightmaps/maze32_1.png.emap
/heightmaps/maze232_0.png.emap
/heightmaps/maze320_0.png.emap
/heightmaps/mazeBrain.png.emap
/.cos265
/readme.html
/P04_Pathfinding.iml
/P04_Pathfinding.zip

--[ 2019.11.11.23.28.52.288.0 ]--
InitFile: /src/PathfinderVisualizer.java
/**
 * PathfinderVisualizer visualizes the terrain and found path.
 */

import java.awt.Color;
import java.awt.Font;

public class PathfinderVisualizer {

    // delay in milliseconds (controls animation speed)
    private final static int DELAY = 100;

    // color for different elevations.  must be in ascending order!
    private final static int[][] elevationColors = {
            // h    r   g   b   where h=height, r=red, g=green, b=blue
            {  0,   0,  0,  0},
            {  2,   0,  0,160},
            {  4,   0,224,224},
            { 16, 192,192,  0},
            { 64,  16,255, 16},
            {128,  32,224, 32},
            {192, 128,128,  8},
            {224, 164,164,164},
            {255, 255,255,255}
    };

    private final static Color cStart    = new Color(128, 128, 255);
    private final static Color cEnd      = new Color(255, 128, 128);
    private final static Color cSolution = new Color(255, 128, 255);
    private final static Color cSearched = new Color(128,   0, 128);

    // linearly interpolating between the corresponding rgb values
    private static Color colorLERP(float v1, int r0, int g0, int b0, int r1, int g1, int b1) {
        v1 = Math.max(0.0f, Math.min(1.0f, v1));
        float v0 = 1.0f - v1;
        int r = (int)(v0 * r0 + v1 * r1);
        int g = (int)(v0 * g0 + v1 * g1);
        int b = (int)(v0 * b0 + v1 * b1);
        return new Color(r, g, b);
    }
    private static Color colorLERP(float v1, Color c0, Color c1) {
        v1 = Math.max(0.0f, Math.min(1.0f, v1));
        float v0 = 1.0f - v1;
        int r = (int)(v0 * c0.getRed()   + v1 * c1.getRed());
        int g = (int)(v0 * c0.getGreen() + v1 * c1.getGreen());
        int b = (int)(v0 * c0.getBlue()  + v1 * c1.getBlue());
        int a = (int)(v0 * c0.getAlpha() + v1 * c1.getAlpha());
        return new Color(r, g, b, a);
    }

    // returns color for given height
    private static Color height2Color(int h) {
        h = Math.max(0, Math.min(255, h));

        int[] ec0 = elevationColors[0];  // default lower bound
        int[] ec1 = elevationColors[1];  // default upper bound

        // find upper bound while updating lower bound
        for(int i = 1; i < elevationColors.length; i++) {
            ec1 = elevationColors[i];
            if(h >= ec0[0] && h <= ec1[0]) break;
            ec0 = ec1;
        }

        int h0=ec0[0], r0=ec0[1], g0=ec0[2], b0=ec0[3];
        int h1=ec1[0], r1=ec1[1], g1=ec1[2], b1=ec1[3];
        float v1 = ((float)(h - h0)) / ((float)(h1 - h0));

        return colorLERP(v1, r0, g0, b0, r1, g1, b1);
    }

    private static void drawCircle(int i, int j, int N, double rad) {
        int c = (int)((i+0.5f) * 464.0f / N);
        int r = (int)((j+0.5f) * 464.0f / N);
        StdDraw.circle(c + 24, 464 - r + 36, rad);
    }
    public static void drawCircle(Coord loc, int N, double rad) {
        drawCircle(loc.getI(), loc.getJ(), N, rad);
    }

    private static void drawPath(Iterable<Coord> path, int N) {
        boolean first = true;
        int c0 = 0, r0 = 0;
        for (Coord loc : path) {
            int c1 = (int)((loc.getI()+0.5f) * 464.0f / N);
            int r1 = (int)((loc.getJ()+0.5f) * 464.0f / N);
            if(!first) {
                StdDraw.line(c0 + 24, 464 - r0 + 36, c1 + 24, 464 - r1 + 36);
            }
            first = false;
            c0 = c1; r0 = r1;
        }
    }

    // draw N-by-N pathfinding map
    public static void draw(Terrain terrain, Pathfinder pf, Walker walker, int N) {
        StdDraw.clear();
        StdDraw.setXscale(0, 512);
        StdDraw.setYscale(0, 512);
        StdDraw.setPenColor(StdDraw.BLACK);
        StdDraw.filledSquare(256, 256 + 12, 464 / 2);

        // draw terrain
        for(int row = 0; row < 464; row++) {
            int j = (int)((float)row/464.0f * N);
            for(int col = 0; col < 464; col++) {
                int i = (int)((float)col/464.0f * N);
                Coord loc = new Coord(i,j);
                Color c = height2Color(terrain.getHeight(loc));
                if(pf.wasSearched(loc)) {
                    c = colorLERP(0.50f, c, cSearched);
                }
                StdDraw.setPenColor(c);
                StdDraw.filledSquare(col + 24, 464 - row + 36, 1);
            }
        }

        // draw path start
        if(pf.getPathStart() != null) {
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            drawCircle(pf.getPathStart(), N, 4.0);

            StdDraw.setPenColor(cStart);
            StdDraw.setPenRadius(0.002);
            drawCircle(pf.getPathStart(), N, 4.0);
        }

        // draw path end
        if(pf.getPathEnd() != null) {
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            drawCircle(pf.getPathEnd(), N, 4.0);

            StdDraw.setPenColor(cEnd);
            StdDraw.setPenRadius(0.002);
            drawCircle(pf.getPathEnd(), N, 4.0);
        }

        // draw found path
        if(pf.foundPath()) {
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            drawPath(pf.getPathSolution(), N);

            StdDraw.setPenColor(cSolution);
            StdDraw.setPenRadius(0.002);
            drawPath(pf.getPathSolution(), N);
        }

        // draw walker
        if(walker != null) {
            Coord loc = walker.getLocation();
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            PathfinderVisualizer.drawCircle(loc, N, 2.0);

            StdDraw.setPenColor(StdDraw.WHITE);
            StdDraw.setPenRadius(0.002);
            PathfinderVisualizer.drawCircle(loc, N, 2.0);
        }

        // write status text
        StdDraw.setFont(new Font("SansSerif", Font.PLAIN, 12));
        StdDraw.setPenColor(StdDraw.BLACK);
        StdDraw.text(96, 12, "heuristic: " + pf.getHeuristic());
        if(pf.foundPath()) StdDraw.text(256, 12, "path: " + pf.getPathCost());
        else               StdDraw.text(256, 12, "no path found");
        StdDraw.text(512-96, 12, "searched: " + pf.getSearchSize() + " (" + (int)(100.0f * pf.getSearchSize() / (N*N)) + "%)");
    }
}

--[ 2019.11.11.23.28.52.291.0 ]--
InitFile: /P04_Pathfinding.iml
<?xml version="1.0" encoding="UTF-8"?>
<module type="JAVA_MODULE" version="4">
  <component name="NewModuleRootManager" inherit-compiler-output="true">
    <exclude-output />
    <content url="file://$MODULE_DIR$">
      <sourceFolder url="file://$MODULE_DIR$/src" isTestSource="false" />
      <sourceFolder url="file://$MODULE_DIR$/heightmaps" type="java-resource" />
      <excludeFolder url="file://$MODULE_DIR$/.log" />
    </content>
    <orderEntry type="inheritedJdk" />
    <orderEntry type="sourceFolder" forTests="false" />
    <orderEntry type="library" name="algs4" level="project" />
    <orderEntry type="library" name="stdlib" level="project" />
  </component>
</module>

--[ 2019.11.11.23.28.52.293.0 ]--
InitFile: /src/Coord.java
/**
 * Coordinates is an immutable type that store the tuple (i, j)
 */
public final class Coord {
    private final int i;
    private final int j;

    public Coord(int i, int j) {
        this.i = i;
        this.j = j;
    }

    public int getI() { return i; }
    public int getJ() { return j; }

    public boolean isInBounds(int minI, int minJ, int maxI, int maxJ) {
        return i >= minI && j >= minJ && i <= maxI && j <= maxJ;
    }
    public boolean isInBounds(Coord min, Coord max) {
        return i >= min.i && i <= max.i && j >= min.j && j <= max.j;
    }

    public Coord add(int addI, int addJ) {
        return new Coord(i + addI, j + addJ);
    }
    public Coord add(Coord that) { return new Coord(i + that.i, j + that.j); }

    public String toString() { return "(" + i + "," + j + ")"; }

    public boolean equals(Object o) {
        if(this == o) return true;
        if(o == null) return false;
        if(o.getClass() != this.getClass()) return false;
        Coord that = (Coord) o;
        if(this.i != that.i) return false;
        if(this.j != that.j) return false;
        return true;
    }
}

--[ 2019.11.11.23.28.52.295.0 ]--
InitFile: /src/Walker.java
import java.util.Iterator;

/**
 * Walker takes an Iterable of Coords and simulates an individual
 * walking along the path over the given Terrain
 */
public class Walker {
    private Terrain terrain;
    private Iterable<Coord> path;
    private Iterator<Coord> iterator;
    private Coord position;
    private float currentCost;
    private Coord previous = null;
    float runningCost = 0;

    // terrain: the Terrain the Walker traverses
    // path: the sequence of Coords the Walker follows
    public Walker(Terrain terrain, Iterable<Coord> path) {
        this.terrain = terrain;
        this.path = path;
        iterator = path.iterator();
    }

    // returns the Walker's current location
    public Coord getLocation() {
        /*if(previous == null){
            currentCost = 0;
        } else {
            currentCost = terrain.computeTravelCost(previous, position);
        }

        previous = this.position;
        */
        return this.position;
    }

    // returns true if Walker has reached the end Coord (last in path)
    public boolean doneWalking() {
        if(iterator.hasNext()){
            return false;
        }
        return true;
    }

    // advances the Walker along path
    // byTime: how long the Walker should traverse (may be any non-negative value)
    public void advance(float byTime) {
        /*
        if(runningCost >= currentCost){
            this.position = iterator.next();
            runningCost = 0;
        } else {
            runningCost+= byTime;
        }
        */
        this.position = iterator.next();
    }
}
//compute travel cost to know how long it takes to go to each spot
//start walker at first coord
//getlocation always calls beginning until advance is called
//when advance is called, move walker to next thing in iterable


//byTime take into account travel cost
//keep track of how many times advance is called and then compare that to the travel cost.

--[ 2019.11.11.23.28.52.296.0 ]--
InitFile: /src/TerrainEditor.java
/**
 * The following class provides some simple terrain editing functions.
 */
public class TerrainEditor {
    private static float rndRadius(float d) {
        return (float)StdRandom.uniform(-d,d);
    }

    private static float getFractalHeight(int i, int j, float dh, Terrain terrain, boolean[] isset) {
        int N = terrain.getN();
        dh = Math.max(-64, Math.min(255+64, dh));   // allow the height to go just a bit out of range
        if(!isset[i + j * N]) {
            isset[i + j * N] = true;
            terrain.setHeight(i, j, dh);
        }
        return terrain.getHeight(i,j);
    }

    private static void setFractalHeights(int i0, int j0, int i1, int j1, Terrain terrain, boolean[] isset) {
        int id = i1-i0;
        int jd = j1-j0;
        int i01 = (i0+i1)/2;
        int j01 = (j0+j1)/2;

        if(id <= 1 && jd <= 1) return;

        float h00 = getFractalHeight(i0,j0,32,terrain,isset);
        float h01 = getFractalHeight(i0,j1,32,terrain,isset);
        float h10 = getFractalHeight(i1,j0,32,terrain,isset);
        float h11 = getFractalHeight(i1,j1,32,terrain,isset);

        float d = (float)(Math.sqrt((i1-i0)*(i1-i0) + (j1-j0)*(j1-j0)) * 0.5);

        float d0001 = (h00 + h01) / 2 + rndRadius(d);
        float d0010 = (h00 + h10) / 2 + rndRadius(d);
        float d1101 = (h11 + h01) / 2 + rndRadius(d);
        float d1110 = (h11 + h10) / 2 + rndRadius(d);

        float h0001 = getFractalHeight(i0, j01, d0001, terrain,isset);
        float h0010 = getFractalHeight(i01, j0, d0010, terrain,isset);
        float h1101 = getFractalHeight(i01, j1, d1101, terrain,isset);
        float h1110 = getFractalHeight(i1, j01, d1110, terrain,isset);

        float dm = (float)((h0001 + h0010 + h1101 + h1110) / 4.0);
        float hm = getFractalHeight(i01, j01, dm, terrain,isset);

        if(id > 1 && jd > 1) {
            setFractalHeights(i0, j0, i01, j01, terrain, isset);
            setFractalHeights(i01, j0, i1, j01, terrain, isset);
            setFractalHeights(i0, j01, i01, j1, terrain, isset);
            setFractalHeights(i01, j01, i1, j1, terrain, isset);
        } else if(jd > 1) {
            setFractalHeights(i0, j0, i1, j01, terrain, isset);
            setFractalHeights(i0, j01, i1, j1, terrain, isset);
        } else {
            setFractalHeights(i0, j0, i01, j1, terrain, isset);
            setFractalHeights(i01, j0, i1, j1, terrain, isset);
        }
    }

    public static void setFractalHeights(Terrain terrain) {
        int N = terrain.getN();
        boolean[] isset = new boolean[N*N];
        setFractalHeights(0, 0, N - 1, N - 1, terrain, isset);
    }

    public static void smoothHeights(Terrain terrain) {
        int N = terrain.getN();
        int radius = (int)Math.ceil(Math.sqrt(N*N/2.0f));
        smoothHeights(N/2, N/2, radius, false, terrain);
    }

    public static void smoothHeights(int ic, int jc, int radius, boolean fallOff, Terrain terrain) {
        final int N = terrain.getN();
        final int w = 2*radius+1;
        float[] s = new float[w*w];
        for(int ia = -radius; ia <= radius; ia++) {
            int i = ic + ia;
            if(i < 0 || i >= N) continue;
            for(int ja = -radius; ja <= radius; ja++) {
                int j = jc + ja;
                if(j < 0 || j >= N) continue;
                int sidx = (ia+radius) + (ja+radius)*w;

                float m = computeEffect(i, j, ic, jc, radius, fallOff, N);
                if(m <= 0.0000001) {
                    s[sidx] = terrain.getHeight(i,j);
                    continue;
                }
                float h = 0;
                int c = 0;
                if(i > 0 && j > 0) {
                    h += terrain.getHeight(i-1,j-1);
                    c += 1;
                }
                if(i < N-1 && j > 0) {
                    h += terrain.getHeight(i+1,j-1);
                    c += 1;
                }
                if(i > 0 && j < N-1) {
                    h += terrain.getHeight(i-1,j+1);
                    c += 1;
                }
                if(i < N-1 && j < N-1) {
                    h += terrain.getHeight(i+1,j+1);
                    c += 1;
                }
                if(i > 0) {
                    h += terrain.getHeight(i-1,j);
                    c += 1;
                }
                if(j > 0) {
                    h += terrain.getHeight(i,j-1);
                    c += 1;
                }
                if(i < N-1) {
                    h += terrain.getHeight(i+1,j);
                    c += 1;
                }
                if(j < N-1) {
                    h += terrain.getHeight(i,j+1);
                    c += 1;
                }
                s[sidx] = (1-m) * terrain.getHeight(i,j) + m * h / c;
            }
        }
        for(int ia = -radius; ia <= radius; ia++) {
            int i = ic + ia;
            if(i < 0 || i >= N) continue;
            for(int ja = -radius; ja <= radius; ja++) {
                int j = jc + ja;
                if(j < 0 || j >= N) continue;
                int sidx = (ia+radius) + (ja+radius)*w;
                terrain.setHeight(i, j, s[sidx]);
            }
        }
    }

    public static void clampHeights(Terrain terrain) {
        int N = terrain.getN();
        for(int i = 0; i < N; i++) {
            for(int j = 0; j < N; j++) {
                terrain.setHeight(i, j, Math.max(0, Math.min(255, terrain.getHeight(i, j))));
            }
        }
    }

    private static float computeEffect(int i, int j, int ic, int jc, int radius, boolean fallOff, int N) {
        if(i < 0 || j < 0 || i >= N || j >= N) return 0;
        if(!fallOff) return 1;
        int d2 = (ic-i)*(ic-i)+(jc-j)*(jc-j);
        if(d2 > radius*radius) return 0;
        return ((float)radius - (float)Math.sqrt(d2)) / (float)radius;
    }

    public static void addHeight(int i, int j, int radius, float add, Terrain terrain) {
        final int N = terrain.getN();
        for(int ja = -radius; ja <= radius; ja++) {
            int r = j + ja;
            if(r < 0 || r >= N) continue;
            for(int ia = -radius; ia <= radius; ia++) {
                int c = i + ia;
                if(c < 0 || c >= N) continue;
                float v = add * computeEffect(c, r, i, j, radius, true, N);
                float h = terrain.getHeight(c, r) + v;
                h = Math.max(0, Math.min(255, h));
                terrain.setHeight(c, r, h);
            }
        }
    }
}

--[ 2019.11.11.23.28.52.297.0 ]--
InitFile: /src/Terrain.java
import java.lang.IndexOutOfBoundsException;

/**
 * Terrain stores elevations for map and computes distance and
 * cost in traversing the terrain.
 */

public class Terrain {
    private int N;
    private int[][] heights;

    public Terrain(int N) {
        this.N = N;
        this.heights = new int[N][N];
    }

    public Terrain(int[][] heights) {
        this.N = heights.length;
        this.heights = heights;
    }

    public Terrain(String emapfile) {
        In in = new In(emapfile);
        this.N = in.readInt();
        this.heights = new int[N][N];
        for (int j = 0; j < N; j++) {
            for (int i = 0; i < N; i++) {
                this.heights[i][j] = in.readInt();
            }
        }
    }

    public int getN() {
        return N;
    }

    public void setHeight(int i, int j, int h) {
        if(i < 0 || j < 0 || i >= N || j >= N)
            throw new IndexOutOfBoundsException("i and j must be in [0,N)");
        heights[i][j] = h;
    }
    public void setHeight(int i, int j, float h) {
        setHeight(i, j, (int) h);
    }
    public void setHeight(Coord loc, int h) {
        setHeight(loc.getI(), loc.getJ(), h);
    }
    public void setHeight(Coord loc, float h) {
        setHeight(loc.getI(), loc.getJ(), h);
    }

    public int getHeight(int i, int j) {
        if(i < 0 || j < 0 || i >= N || j >= N)
            throw new IndexOutOfBoundsException("i and j must be in [0,N)");
        return heights[i][j];
    }
    public int getHeight(Coord loc) {
        return getHeight(loc.getI(), loc.getJ());
    }

    // computes distance between (i0,j0) and (i1,j1) as the crow flies
    public float computeDistance(int i0, int j0, int i1, int j1) {
        return (float)Math.sqrt((i0 - i1) * (i0 - i1) + (j0 - j1) * (j0 - j1));
    }
    public float computeDistance(Coord c0, Coord c1) {
        return computeDistance(c0.getI(), c0.getJ(), c1.getI(), c1.getJ());
    }

    public float computeTravelCost(int i0, int j0, int i1, int j1) {
        float h0 = getHeight(i0, j0), h1 = getHeight(i1, j1);
        float climb = (float)Math.pow(Math.abs(h0 - h1) * 1000.0, 1.5);
        float dist = computeDistance(i0,j0, i1,j1);
        return (1.0f + climb) * dist;
    }
    public float computeTravelCost(Coord c0, Coord c1) {
        return computeTravelCost(c0.getI(), c0.getJ(), c1.getI(), c1.getJ());
    }
    public float computeTravelCost(Iterable<Coord> cs) {
        Coord c0 = null;
        float cost = 0.0f;
        for(Coord c1 : cs) {
            if(c0 != null) cost += computeTravelCost(c0, c1);
            c0 = c1;
        }
        return cost;
    }
}

--[ 2019.11.11.23.28.52.299.0 ]--
InitFile: /src/InteractivePathfinderVisualizer.java
import java.awt.event.KeyEvent;

/**
 * InteractivePathfinderVisualizer visualizes the terrain and the computed
 * path and allows the user to change parameters of the Pathfinder.  Below
 * is a list of commands and what they do.  Note: some of the commands
 * modify the properties of the path finder and some modify the terrain.
 *
 * Command        Action                                      Terrain
 * C              clear path
 * space          recompute path
 * S/E            set start/end location to mouse
 * left/right     halve/double path search heuristic value
 * 0/1            set path search heuristic to 0 or 1
 * W              start a walker to show the path
 * R              randomly generate a new terrain                *
 * M              smooths terrain under mouse                    *
 * shift+M        smooths all terrain                            *
 * up/down        increase/decrease terrain under mouse          *
 */

public class InteractivePathfinderVisualizer {
    private final static int DELAY = 10;

    // sets how many redraws it should take for the walker to reach its destination
    private final static float STEPS_TO_WALK = 100.0f;

    // for convenience, here are the emap files that are located under heightmaps/ folder
    // the python script in that folder converts png files to emap. \
    // you can use it to create your own maps to test your code
    private final static String[] emaps = {
            "maze32_0.png.emap",    // 0   (32x32 maze)
            "maze32_1.png.emap",    // 1   (another 32x32 maze)
            "maze232_0.png.emap",   // 2   (232x232 maze)
            "maze320_0.png.emap",   // 3   (same as maze32_0, only scaled up by 10x)
            "mazeAB.png.emap",      // 4   (a maze from a site no longer online :( )
            "mazeBrain.png.emap",   // 5   (...)
            "ramp.png.emap",        // 6   (some tests)
            "ramp2.png.emap",       // 7   (...)
            "ramp3.png.emap",       // 8   (...)
            "usa128.png.emap",      // 9   (elevation map of USA from https://bananas.openttd.org/en/heightmap/)
            "usa256.png.emap",      // 10  (same as usa128, only higher resolution)
            "usa1024.png.emap",     // 11  (same as usa128, only higher resolution
    };

    private final static String emapFilename = emaps[11];        // change index to load a different elevation map



    public static void main(String[] args) {
        Terrain terrain = new Terrain(emapFilename);
        Pathfinder pf = new Pathfinder(terrain);
        int N = terrain.getN();

        StdDraw.show(0);

        // set default starting and ending locations
        pf.setPathStart(new Coord(1, 1));
        pf.setPathEnd(new Coord(N-3, N-3));

        // find a path
        pf.computePath();

        PathfinderVisualizer.draw(terrain, pf, null, N);
        StdDraw.show(DELAY);

        // prevent repeated applications
        boolean keyboardR = false;
        boolean keyboardM = false;

        Walker walker = null;

        while(true) {
            boolean recompute = false;
            boolean redraw = false;

            // mouse location on map
            int mouseI = (int) ((StdDraw.mouseX()-24) / 464 * N);
            int mouseJ = (int) ((464 - (StdDraw.mouseY()-36)) / 464 * N);
            boolean isMouseOnMap = (mouseI >=0 && mouseI < N && mouseJ >= 0 && mouseJ < N);

            if(StdDraw.isKeyPressed(KeyEvent.VK_LEFT) || StdDraw.isKeyPressed(KeyEvent.VK_RIGHT)) {
                boolean keyboardLeft = StdDraw.isKeyPressed(KeyEvent.VK_LEFT);
                float m = keyboardLeft ? 0.5f : 2.0f;
                float h = pf.getHeuristic() * m;
                h = Math.max(1.0f/1024.0f, Math.min(1048576.0f, h));
                pf.setHeuristic(h);
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_0) || StdDraw.isKeyPressed(KeyEvent.VK_1)) {
                boolean keyboard0 = StdDraw.isKeyPressed(KeyEvent.VK_0);
                float h = keyboard0 ? 0 : 1;
                pf.setHeuristic(h);
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_C)) {
                pf.resetPath();
                walker = null;
                redraw = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_R) && !keyboardR) {
                TerrainEditor.setFractalHeights(terrain);
                TerrainEditor.clampHeights(terrain);
                recompute = true;
            }
            keyboardR = StdDraw.isKeyPressed(KeyEvent.VK_R);

            if(StdDraw.isKeyPressed(KeyEvent.VK_M)) {
                if(StdDraw.isKeyPressed(KeyEvent.VK_SHIFT)) {
                    if(!keyboardM) {
                        TerrainEditor.smoothHeights(terrain);
                        recompute = true;
                    }
                } else {
                    TerrainEditor.smoothHeights(mouseI, mouseJ, N / 20, true, terrain);
                    recompute = true;
                }
            }
            keyboardM = StdDraw.isKeyPressed(KeyEvent.VK_M);

            if(StdDraw.isKeyPressed(KeyEvent.VK_SPACE)) {
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_UP) || StdDraw.isKeyPressed(KeyEvent.VK_DOWN)) {
                boolean keyboardUp = StdDraw.isKeyPressed(KeyEvent.VK_UP);
                float add = keyboardUp ? 8.0f : -8.0f;
                TerrainEditor.addHeight(mouseI, mouseJ, N / 20, add, terrain);
                recompute = true;
            }

            if(isMouseOnMap && StdDraw.isKeyPressed(KeyEvent.VK_S)) {
                pf.setPathStart(new Coord(mouseI, mouseJ));
                recompute = true;
            }

            if(isMouseOnMap && StdDraw.isKeyPressed(KeyEvent.VK_E)) {
                pf.setPathEnd(new Coord(mouseI, mouseJ));
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_W)) {
                Iterable<Coord> path = pf.getPathSolution();
                if(path != null) {
                    walker = new Walker(terrain, pf.getPathSolution());
                }
            }

            if(walker != null) {
                if(walker.doneWalking()) {
                    walker = null;
                } else {
                    walker.advance(pf.getPathCost() / STEPS_TO_WALK);
                }
                redraw = true;
            }

            if(recompute) {
                walker = null;
                pf.resetPath();
                if(pf.getPathStart() != null && pf.getPathEnd() != null) {
                    pf.computePath();
                }
                redraw = true;
            }

            if(redraw) {
                PathfinderVisualizer.draw(terrain, pf, walker, N);
                StdDraw.show(DELAY);
            } else {
                try {
                    Thread.sleep(10);
                } catch (InterruptedException e) {
                    /* do nothing */
                }
            }
        }
    }
}

--[ 2019.11.11.23.28.52.301.0 ]--
InitFile: /src/Pathfinder.java
import java.lang.IndexOutOfBoundsException;
import java.lang.IllegalArgumentException;

/**
 * Pathfinder uses A* search to find a near optimal path
 * between to locations with given terrain.
 */

public class Pathfinder {
    private Coord end;
    private Coord start;
    private Terrain terrain;
    private float heur;
    private boolean pathFound = false;  //implement in compute path, set to true when found
    private int searchSize;
    private PFNode[][] board;
    private PFNode endNode;
    private Stack<Coord> stack = new Stack<>();
    //set up Minimum Priority Queue
    private MinPQ<PFNode> pq = new MinPQ<>();
    private float pathCost;

    /**
     * PFNode will be the key for MinPQ (used in computePath())
     */
    private class PFNode implements Comparable<PFNode> {
        private boolean isUsed;
        private boolean invalid;
        private Coord loc;
        private PFNode fromNode;
        private float cost;
        // loc: the location of the PFNode
        // fromNode: how did we get here? (linked list back to start)

        public PFNode(Coord loc, PFNode fromNode) {
            this.loc = loc;
            this.fromNode = fromNode;
            if(fromNode != null)
                cost = fromNode.cost + terrain.computeTravelCost(loc, fromNode.loc);
        }

        // compares this with that, used to find minimum cost PFNode
        public int compareTo(PFNode that) {
            if(this.getCost(heur) < that.getCost(heur)) return -1;  //this < that
            if(that.getCost(heur) < this.getCost(heur)) return 1;   //that < this
            return 0;  //this == that
        }

        // returns the cost to travel from starting point to this
        // via the fromNode chain
        public float getCost(float heuristic) {  //call getCost with heuristic of 0, get travel cost, do A* search
            //return fromNode.getCost(0) + terrain.computeTravelCost(fromNode.loc, loc) + heuristic*terrain.computeDistance(loc.getI(), loc.getJ(), endNode.loc.getI(), endNode.loc.getJ());
            //StdOut.println(heuristic);
            //StdOut.println(terrain.computeDistance(loc.getI(), loc.getJ(), end.getI(), end.getJ()));
            //StdOut.println("Cost:" + cost);
            return cost + heuristic*terrain.computeDistance(loc.getI(), loc.getJ(), end.getI(), end.getJ());
        }

        // returns if this PFNode is not marked invalid
        public boolean isValid() {
            return invalid;
        }

        // marks the PFNode as invalid
        public void invalidate() {
            invalid = true;
        }

        // returns if the PFNode is marked as used
        public boolean isUsed() {  //help
            return isUsed;
        }

        // marks the PFNode as used
        public void use(PFNode node) {
            node.isUsed = true;
        }

        // returns an Iterable of PFNodes that surround this
        public Iterable<PFNode> neighbors() {
            Stack<PFNode> s = new Stack<>();
            s.push(new PFNode(null, null));
            return s;
        }
    }

    public Pathfinder(Terrain terrain) {
        this.terrain = terrain;
    }

    public void setPathStart(Coord loc) { // I need a check to see how it can stay on the white area.
        if(loc == null) throw new IllegalArgumentException("The location is null.");
        if(!loc.isInBounds(0,0,terrain.getN()-1, terrain.getN()-1)) throw new IndexOutOfBoundsException("The location is out of bounds.");
        start = loc;
    }

    public Coord getPathStart() {
        return start;
    }

    public void setPathEnd(Coord loc) {
        if(loc == null) throw new IllegalArgumentException("The location is null.");
        if(!loc.isInBounds(0,0,terrain.getN()-1, terrain.getN()-1)) throw new IndexOutOfBoundsException("The location is out of bounds.");
        end = loc;
    }

    public Coord getPathEnd() {
        return end;
    }

    public void setHeuristic(float v) { // is this correct?
        heur = v;
    }

    public float getHeuristic() { return heur; }

    public void resetPath() {
        start = getPathStart(); //how do I tell it to find where the mouse is at? setPathStart?
        end = getPathEnd();
        endNode = null;
        pathFound = false;
        searchSize = 0;

        pq = new MinPQ<>();

        stack = new Stack<>();

        //computePath();
    }

    public void computePath() {
        if(getPathEnd() == null || getPathStart() == null) throw new IllegalArgumentException("Either or both of start path or end path have NOT been set.");

        //set up logic board with 2D array
        int N = terrain.getN();
        board = new PFNode[N][N];

        //I added this... is it needed?
        //setHeuristic(3);

        PFNode beginNode = new PFNode(getPathStart(), null);
        board[getPathStart().getI()][getPathStart().getJ()] = beginNode;
        pq.insert(beginNode);
        beginNode.use(beginNode);
        beginNode.cost = 0;
        searchSize = 0;
        while(!pathFound){
            StdOut.println("path not found");
            //remove from pq
            PFNode removed = pq.delMin();
            //StdOut.println("The minimum has been removed.");  //bug check
            //check if node is at end
            if(removed.loc.equals(getPathEnd())){  //correct?
                pq.insert(removed);
                endNode = removed;
                pathFound = true;
                endNode.use(endNode);
                endNode.cost = removed.cost + terrain.computeTravelCost(removed.loc, endNode.loc);
                pathCost = endNode.cost;
                searchSize ++;
                break;
            }
            //"process" node just removed
            //see if the locations around the removed position are in bounds
            //now have them point to removed, "from = removed";  ?
            if(removed.loc.getJ() -1 >= 0 ){
               if(board[removed.loc.getI()][removed.loc.getJ()-1] == null){
                    PFNode node = new PFNode(removed.loc.add(0, -1), removed); //good
                    board[removed.loc.getI()][removed.loc.getJ() - 1] = node;
                    pq.insert(node);
                    node.use(node);
                    searchSize ++;
                    //node.cost = removed.cost + terrain.computeTravelCost(removed.loc, node.loc);
                }
            }
            if(removed.loc.getI() - 1 >= 0){
                if(board[removed.loc.getI()-1][removed.loc.getJ()] == null) {
                    PFNode node = new PFNode(removed.loc.add(-1, 0), removed); //good
                    board[removed.loc.getI() - 1][removed.loc.getJ()] = node;
                    pq.insert(node);
                    node.use(node);
                    searchSize ++;
                    //node.cost = removed.cost + terrain.computeTravelCost(removed.loc, node.loc);
                }
            }
            if(removed.loc.getJ() + 1 < N-1){
                if(board[removed.loc.getI()][removed.loc.getJ()+1] == null) {
                    PFNode node = new PFNode(removed.loc.add(0, 1), removed); //good
                    board[removed.loc.getI()][removed.loc.getJ() + 1] = node;
                    pq.insert(node);
                    node.use(node);
                    searchSize ++;
                    //node.cost = removed.cost + terrain.computeTravelCost(removed.loc, node.loc);
                }
            }
            if(removed.loc.getI() + 1 < N-1){
                if(board[removed.loc.getI()+1][removed.loc.getJ()] == null) {
                    PFNode node = new PFNode(removed.loc.add(1, 0), removed); //good
                    board[removed.loc.getI() + 1][removed.loc.getJ()] = node;
                    pq.insert(node);
                    node.use(node);
                    searchSize ++;
                    //node.cost = removed.cost + terrain.computeTravelCost(removed.loc, node.loc);
                }
            }
        }
        StdOut.println("A connection has been found!");

        stack.push(endNode.loc);
        PFNode nextNode = endNode.fromNode;
        while(nextNode.fromNode != beginNode){
            stack.push(nextNode.loc);
            nextNode = nextNode.fromNode;
        }
        //this should be the start node
        stack.push(nextNode.fromNode.loc);
    }

    public boolean foundPath() { //good
        return pathFound;
    }

    public float getPathCost() { //good
        return pathCost;
    }

    public int getSearchSize() { //good
        return searchSize;
    }

    public Iterable<Coord> getPathSolution() {
        return stack;
    } //good

    public boolean wasSearched(Coord loc) { //good
        return board[loc.getI()][loc.getJ()] != null;
    }

}

--[ 2019.11.11.23.28.52.303.0 ]--
InitFile: /.cos265


--[ 2019.11.11.23.57.23.036.0 ]--
DisposeComponent
--[ 2019.11.23.23.25.47.592.0 ]--
NewLogger: P04_Pathfinding
Version: 1.3
--[ 2019.11.23.23.25.47.739.0 ]--
InitTree:
/out/production/P04_Pathfinding/.donotlog
/out/production/P04_Pathfinding/algs4.jar
/out/production/P04_Pathfinding/stdlib.jar
/out/production/P04_Pathfinding/Coord.class
/out/production/P04_Pathfinding/png2emap.py
/out/production/P04_Pathfinding/Walker.class
/out/production/P04_Pathfinding/ramp.png.emap
/out/production/P04_Pathfinding/Terrain.class
/out/production/P04_Pathfinding/ramp2.png.emap
/out/production/P04_Pathfinding/ramp3.png.emap
/out/production/P04_Pathfinding/mazeAB.png.emap
/out/production/P04_Pathfinding/usa128.png.emap
/out/production/P04_Pathfinding/usa256.png.emap
/out/production/P04_Pathfinding/Pathfinder.class
/out/production/P04_Pathfinding/usa1024.png.emap
/out/production/P04_Pathfinding/maze32_0.png.emap
/out/production/P04_Pathfinding/maze32_1.png.emap
/out/production/P04_Pathfinding/maze232_0.png.emap
/out/production/P04_Pathfinding/maze320_0.png.emap
/out/production/P04_Pathfinding/mazeBrain.png.emap
/out/production/P04_Pathfinding/TerrainEditor.class
/out/production/P04_Pathfinding/Pathfinder$PFNode.class
/out/production/P04_Pathfinding/PathfinderVisualizer.class
/out/production/P04_Pathfinding/InteractivePathfinderVisualizer.class
/src/algs4.jar
/src/Coord.java
/src/stdlib.jar
/src/Walker.java
/src/Terrain.java
/src/Pathfinder.java
/src/TerrainEditor.java
/src/PathfinderVisualizer.java
/src/InteractivePathfinderVisualizer.java
/.log/history.log
/.idea/copyright/profiles_settings.xml
/.idea/libraries/algs4.xml
/.idea/libraries/stdlib.xml
/.idea/.name
/.idea/misc.xml
/.idea/modules.xml
/.idea/compiler.xml
/.idea/workspace.xml
/.idea/uiDesigner.xml
/heightmaps/.donotlog
/heightmaps/png2emap.py
/heightmaps/ramp.png.emap
/heightmaps/ramp2.png.emap
/heightmaps/ramp3.png.emap
/heightmaps/mazeAB.png.emap
/heightmaps/usa128.png.emap
/heightmaps/usa256.png.emap
/heightmaps/usa1024.png.emap
/heightmaps/maze32_0.png.emap
/heightmaps/maze32_1.png.emap
/heightmaps/maze232_0.png.emap
/heightmaps/maze320_0.png.emap
/heightmaps/mazeBrain.png.emap
/.cos265
/readme.html
/P04_Pathfinding.iml
/P04_Pathfinding.zip

--[ 2019.11.23.23.25.47.745.0 ]--
InitFile: /src/PathfinderVisualizer.java
/**
 * PathfinderVisualizer visualizes the terrain and found path.
 */

import java.awt.Color;
import java.awt.Font;

public class PathfinderVisualizer {

    // delay in milliseconds (controls animation speed)
    private final static int DELAY = 100;

    // color for different elevations.  must be in ascending order!
    private final static int[][] elevationColors = {
            // h    r   g   b   where h=height, r=red, g=green, b=blue
            {  0,   0,  0,  0},
            {  2,   0,  0,160},
            {  4,   0,224,224},
            { 16, 192,192,  0},
            { 64,  16,255, 16},
            {128,  32,224, 32},
            {192, 128,128,  8},
            {224, 164,164,164},
            {255, 255,255,255}
    };

    private final static Color cStart    = new Color(128, 128, 255);
    private final static Color cEnd      = new Color(255, 128, 128);
    private final static Color cSolution = new Color(255, 128, 255);
    private final static Color cSearched = new Color(128,   0, 128);

    // linearly interpolating between the corresponding rgb values
    private static Color colorLERP(float v1, int r0, int g0, int b0, int r1, int g1, int b1) {
        v1 = Math.max(0.0f, Math.min(1.0f, v1));
        float v0 = 1.0f - v1;
        int r = (int)(v0 * r0 + v1 * r1);
        int g = (int)(v0 * g0 + v1 * g1);
        int b = (int)(v0 * b0 + v1 * b1);
        return new Color(r, g, b);
    }
    private static Color colorLERP(float v1, Color c0, Color c1) {
        v1 = Math.max(0.0f, Math.min(1.0f, v1));
        float v0 = 1.0f - v1;
        int r = (int)(v0 * c0.getRed()   + v1 * c1.getRed());
        int g = (int)(v0 * c0.getGreen() + v1 * c1.getGreen());
        int b = (int)(v0 * c0.getBlue()  + v1 * c1.getBlue());
        int a = (int)(v0 * c0.getAlpha() + v1 * c1.getAlpha());
        return new Color(r, g, b, a);
    }

    // returns color for given height
    private static Color height2Color(int h) {
        h = Math.max(0, Math.min(255, h));

        int[] ec0 = elevationColors[0];  // default lower bound
        int[] ec1 = elevationColors[1];  // default upper bound

        // find upper bound while updating lower bound
        for(int i = 1; i < elevationColors.length; i++) {
            ec1 = elevationColors[i];
            if(h >= ec0[0] && h <= ec1[0]) break;
            ec0 = ec1;
        }

        int h0=ec0[0], r0=ec0[1], g0=ec0[2], b0=ec0[3];
        int h1=ec1[0], r1=ec1[1], g1=ec1[2], b1=ec1[3];
        float v1 = ((float)(h - h0)) / ((float)(h1 - h0));

        return colorLERP(v1, r0, g0, b0, r1, g1, b1);
    }

    private static void drawCircle(int i, int j, int N, double rad) {
        int c = (int)((i+0.5f) * 464.0f / N);
        int r = (int)((j+0.5f) * 464.0f / N);
        StdDraw.circle(c + 24, 464 - r + 36, rad);
    }
    public static void drawCircle(Coord loc, int N, double rad) {
        drawCircle(loc.getI(), loc.getJ(), N, rad);
    }

    private static void drawPath(Iterable<Coord> path, int N) {
        boolean first = true;
        int c0 = 0, r0 = 0;
        for (Coord loc : path) {
            int c1 = (int)((loc.getI()+0.5f) * 464.0f / N);
            int r1 = (int)((loc.getJ()+0.5f) * 464.0f / N);
            if(!first) {
                StdDraw.line(c0 + 24, 464 - r0 + 36, c1 + 24, 464 - r1 + 36);
            }
            first = false;
            c0 = c1; r0 = r1;
        }
    }

    // draw N-by-N pathfinding map
    public static void draw(Terrain terrain, Pathfinder pf, Walker walker, int N) {
        StdDraw.clear();
        StdDraw.setXscale(0, 512);
        StdDraw.setYscale(0, 512);
        StdDraw.setPenColor(StdDraw.BLACK);
        StdDraw.filledSquare(256, 256 + 12, 464 / 2);

        // draw terrain
        for(int row = 0; row < 464; row++) {
            int j = (int)((float)row/464.0f * N);
            for(int col = 0; col < 464; col++) {
                int i = (int)((float)col/464.0f * N);
                Coord loc = new Coord(i,j);
                Color c = height2Color(terrain.getHeight(loc));
                if(pf.wasSearched(loc)) {
                    c = colorLERP(0.50f, c, cSearched);
                }
                StdDraw.setPenColor(c);
                StdDraw.filledSquare(col + 24, 464 - row + 36, 1);
            }
        }

        // draw path start
        if(pf.getPathStart() != null) {
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            drawCircle(pf.getPathStart(), N, 4.0);

            StdDraw.setPenColor(cStart);
            StdDraw.setPenRadius(0.002);
            drawCircle(pf.getPathStart(), N, 4.0);
        }

        // draw path end
        if(pf.getPathEnd() != null) {
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            drawCircle(pf.getPathEnd(), N, 4.0);

            StdDraw.setPenColor(cEnd);
            StdDraw.setPenRadius(0.002);
            drawCircle(pf.getPathEnd(), N, 4.0);
        }

        // draw found path
        if(pf.foundPath()) {
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            drawPath(pf.getPathSolution(), N);

            StdDraw.setPenColor(cSolution);
            StdDraw.setPenRadius(0.002);
            drawPath(pf.getPathSolution(), N);
        }

        // draw walker
        if(walker != null) {
            Coord loc = walker.getLocation();
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            PathfinderVisualizer.drawCircle(loc, N, 2.0);

            StdDraw.setPenColor(StdDraw.WHITE);
            StdDraw.setPenRadius(0.002);
            PathfinderVisualizer.drawCircle(loc, N, 2.0);
        }

        // write status text
        StdDraw.setFont(new Font("SansSerif", Font.PLAIN, 12));
        StdDraw.setPenColor(StdDraw.BLACK);
        StdDraw.text(96, 12, "heuristic: " + pf.getHeuristic());
        if(pf.foundPath()) StdDraw.text(256, 12, "path: " + pf.getPathCost());
        else               StdDraw.text(256, 12, "no path found");
        StdDraw.text(512-96, 12, "searched: " + pf.getSearchSize() + " (" + (int)(100.0f * pf.getSearchSize() / (N*N)) + "%)");
    }
}

--[ 2019.11.23.23.25.47.747.0 ]--
InitFile: /P04_Pathfinding.iml
<?xml version="1.0" encoding="UTF-8"?>
<module type="JAVA_MODULE" version="4">
  <component name="NewModuleRootManager" inherit-compiler-output="true">
    <exclude-output />
    <content url="file://$MODULE_DIR$">
      <sourceFolder url="file://$MODULE_DIR$/src" isTestSource="false" />
      <sourceFolder url="file://$MODULE_DIR$/heightmaps" type="java-resource" />
      <excludeFolder url="file://$MODULE_DIR$/.log" />
    </content>
    <orderEntry type="inheritedJdk" />
    <orderEntry type="sourceFolder" forTests="false" />
    <orderEntry type="library" name="algs4" level="project" />
    <orderEntry type="library" name="stdlib" level="project" />
  </component>
</module>

--[ 2019.11.23.23.25.47.750.0 ]--
InitFile: /src/Coord.java
/**
 * Coordinates is an immutable type that store the tuple (i, j)
 */
public final class Coord {
    private final int i;
    private final int j;

    public Coord(int i, int j) {
        this.i = i;
        this.j = j;
    }

    public int getI() { return i; }
    public int getJ() { return j; }

    public boolean isInBounds(int minI, int minJ, int maxI, int maxJ) {
        return i >= minI && j >= minJ && i <= maxI && j <= maxJ;
    }
    public boolean isInBounds(Coord min, Coord max) {
        return i >= min.i && i <= max.i && j >= min.j && j <= max.j;
    }

    public Coord add(int addI, int addJ) {
        return new Coord(i + addI, j + addJ);
    }
    public Coord add(Coord that) { return new Coord(i + that.i, j + that.j); }

    public String toString() { return "(" + i + "," + j + ")"; }

    public boolean equals(Object o) {
        if(this == o) return true;
        if(o == null) return false;
        if(o.getClass() != this.getClass()) return false;
        Coord that = (Coord) o;
        if(this.i != that.i) return false;
        if(this.j != that.j) return false;
        return true;
    }
}

--[ 2019.11.23.23.25.47.751.0 ]--
InitFile: /src/Walker.java
import java.util.Iterator;

/**
 * Walker takes an Iterable of Coords and simulates an individual
 * walking along the path over the given Terrain
 */
public class Walker {
    private Terrain terrain;
    private Iterable<Coord> path;
    private Iterator<Coord> iterator;
    private Coord position;
    private float currentCost;
    private Coord previous = null;
    float runningCost = 0;

    // terrain: the Terrain the Walker traverses
    // path: the sequence of Coords the Walker follows
    public Walker(Terrain terrain, Iterable<Coord> path) {
        this.terrain = terrain;
        this.path = path;
        iterator = path.iterator();
    }

    // returns the Walker's current location
    public Coord getLocation() {
        /*if(previous == null){
            currentCost = 0;
        } else {
            currentCost = terrain.computeTravelCost(previous, position);
        }

        previous = this.position;
        */
        return this.position;
    }

    // returns true if Walker has reached the end Coord (last in path)
    public boolean doneWalking() {
        if(iterator.hasNext()){
            return false;
        }
        return true;
    }

    // advances the Walker along path
    // byTime: how long the Walker should traverse (may be any non-negative value)
    public void advance(float byTime) {
        /*
        if(runningCost >= currentCost){
            this.position = iterator.next();
            runningCost = 0;
        } else {
            runningCost+= byTime;
        }
        */
        this.position = iterator.next();
    }
}
//compute travel cost to know how long it takes to go to each spot
//start walker at first coord
//getlocation always calls beginning until advance is called
//when advance is called, move walker to next thing in iterable


//byTime take into account travel cost
//keep track of how many times advance is called and then compare that to the travel cost.

--[ 2019.11.23.23.25.47.753.0 ]--
InitFile: /src/TerrainEditor.java
/**
 * The following class provides some simple terrain editing functions.
 */
public class TerrainEditor {
    private static float rndRadius(float d) {
        return (float)StdRandom.uniform(-d,d);
    }

    private static float getFractalHeight(int i, int j, float dh, Terrain terrain, boolean[] isset) {
        int N = terrain.getN();
        dh = Math.max(-64, Math.min(255+64, dh));   // allow the height to go just a bit out of range
        if(!isset[i + j * N]) {
            isset[i + j * N] = true;
            terrain.setHeight(i, j, dh);
        }
        return terrain.getHeight(i,j);
    }

    private static void setFractalHeights(int i0, int j0, int i1, int j1, Terrain terrain, boolean[] isset) {
        int id = i1-i0;
        int jd = j1-j0;
        int i01 = (i0+i1)/2;
        int j01 = (j0+j1)/2;

        if(id <= 1 && jd <= 1) return;

        float h00 = getFractalHeight(i0,j0,32,terrain,isset);
        float h01 = getFractalHeight(i0,j1,32,terrain,isset);
        float h10 = getFractalHeight(i1,j0,32,terrain,isset);
        float h11 = getFractalHeight(i1,j1,32,terrain,isset);

        float d = (float)(Math.sqrt((i1-i0)*(i1-i0) + (j1-j0)*(j1-j0)) * 0.5);

        float d0001 = (h00 + h01) / 2 + rndRadius(d);
        float d0010 = (h00 + h10) / 2 + rndRadius(d);
        float d1101 = (h11 + h01) / 2 + rndRadius(d);
        float d1110 = (h11 + h10) / 2 + rndRadius(d);

        float h0001 = getFractalHeight(i0, j01, d0001, terrain,isset);
        float h0010 = getFractalHeight(i01, j0, d0010, terrain,isset);
        float h1101 = getFractalHeight(i01, j1, d1101, terrain,isset);
        float h1110 = getFractalHeight(i1, j01, d1110, terrain,isset);

        float dm = (float)((h0001 + h0010 + h1101 + h1110) / 4.0);
        float hm = getFractalHeight(i01, j01, dm, terrain,isset);

        if(id > 1 && jd > 1) {
            setFractalHeights(i0, j0, i01, j01, terrain, isset);
            setFractalHeights(i01, j0, i1, j01, terrain, isset);
            setFractalHeights(i0, j01, i01, j1, terrain, isset);
            setFractalHeights(i01, j01, i1, j1, terrain, isset);
        } else if(jd > 1) {
            setFractalHeights(i0, j0, i1, j01, terrain, isset);
            setFractalHeights(i0, j01, i1, j1, terrain, isset);
        } else {
            setFractalHeights(i0, j0, i01, j1, terrain, isset);
            setFractalHeights(i01, j0, i1, j1, terrain, isset);
        }
    }

    public static void setFractalHeights(Terrain terrain) {
        int N = terrain.getN();
        boolean[] isset = new boolean[N*N];
        setFractalHeights(0, 0, N - 1, N - 1, terrain, isset);
    }

    public static void smoothHeights(Terrain terrain) {
        int N = terrain.getN();
        int radius = (int)Math.ceil(Math.sqrt(N*N/2.0f));
        smoothHeights(N/2, N/2, radius, false, terrain);
    }

    public static void smoothHeights(int ic, int jc, int radius, boolean fallOff, Terrain terrain) {
        final int N = terrain.getN();
        final int w = 2*radius+1;
        float[] s = new float[w*w];
        for(int ia = -radius; ia <= radius; ia++) {
            int i = ic + ia;
            if(i < 0 || i >= N) continue;
            for(int ja = -radius; ja <= radius; ja++) {
                int j = jc + ja;
                if(j < 0 || j >= N) continue;
                int sidx = (ia+radius) + (ja+radius)*w;

                float m = computeEffect(i, j, ic, jc, radius, fallOff, N);
                if(m <= 0.0000001) {
                    s[sidx] = terrain.getHeight(i,j);
                    continue;
                }
                float h = 0;
                int c = 0;
                if(i > 0 && j > 0) {
                    h += terrain.getHeight(i-1,j-1);
                    c += 1;
                }
                if(i < N-1 && j > 0) {
                    h += terrain.getHeight(i+1,j-1);
                    c += 1;
                }
                if(i > 0 && j < N-1) {
                    h += terrain.getHeight(i-1,j+1);
                    c += 1;
                }
                if(i < N-1 && j < N-1) {
                    h += terrain.getHeight(i+1,j+1);
                    c += 1;
                }
                if(i > 0) {
                    h += terrain.getHeight(i-1,j);
                    c += 1;
                }
                if(j > 0) {
                    h += terrain.getHeight(i,j-1);
                    c += 1;
                }
                if(i < N-1) {
                    h += terrain.getHeight(i+1,j);
                    c += 1;
                }
                if(j < N-1) {
                    h += terrain.getHeight(i,j+1);
                    c += 1;
                }
                s[sidx] = (1-m) * terrain.getHeight(i,j) + m * h / c;
            }
        }
        for(int ia = -radius; ia <= radius; ia++) {
            int i = ic + ia;
            if(i < 0 || i >= N) continue;
            for(int ja = -radius; ja <= radius; ja++) {
                int j = jc + ja;
                if(j < 0 || j >= N) continue;
                int sidx = (ia+radius) + (ja+radius)*w;
                terrain.setHeight(i, j, s[sidx]);
            }
        }
    }

    public static void clampHeights(Terrain terrain) {
        int N = terrain.getN();
        for(int i = 0; i < N; i++) {
            for(int j = 0; j < N; j++) {
                terrain.setHeight(i, j, Math.max(0, Math.min(255, terrain.getHeight(i, j))));
            }
        }
    }

    private static float computeEffect(int i, int j, int ic, int jc, int radius, boolean fallOff, int N) {
        if(i < 0 || j < 0 || i >= N || j >= N) return 0;
        if(!fallOff) return 1;
        int d2 = (ic-i)*(ic-i)+(jc-j)*(jc-j);
        if(d2 > radius*radius) return 0;
        return ((float)radius - (float)Math.sqrt(d2)) / (float)radius;
    }

    public static void addHeight(int i, int j, int radius, float add, Terrain terrain) {
        final int N = terrain.getN();
        for(int ja = -radius; ja <= radius; ja++) {
            int r = j + ja;
            if(r < 0 || r >= N) continue;
            for(int ia = -radius; ia <= radius; ia++) {
                int c = i + ia;
                if(c < 0 || c >= N) continue;
                float v = add * computeEffect(c, r, i, j, radius, true, N);
                float h = terrain.getHeight(c, r) + v;
                h = Math.max(0, Math.min(255, h));
                terrain.setHeight(c, r, h);
            }
        }
    }
}

--[ 2019.11.23.23.25.47.754.0 ]--
InitFile: /src/Terrain.java
import java.lang.IndexOutOfBoundsException;

/**
 * Terrain stores elevations for map and computes distance and
 * cost in traversing the terrain.
 */

public class Terrain {
    private int N;
    private int[][] heights;

    public Terrain(int N) {
        this.N = N;
        this.heights = new int[N][N];
    }

    public Terrain(int[][] heights) {
        this.N = heights.length;
        this.heights = heights;
    }

    public Terrain(String emapfile) {
        In in = new In(emapfile);
        this.N = in.readInt();
        this.heights = new int[N][N];
        for (int j = 0; j < N; j++) {
            for (int i = 0; i < N; i++) {
                this.heights[i][j] = in.readInt();
            }
        }
    }

    public int getN() {
        return N;
    }

    public void setHeight(int i, int j, int h) {
        if(i < 0 || j < 0 || i >= N || j >= N)
            throw new IndexOutOfBoundsException("i and j must be in [0,N)");
        heights[i][j] = h;
    }
    public void setHeight(int i, int j, float h) {
        setHeight(i, j, (int) h);
    }
    public void setHeight(Coord loc, int h) {
        setHeight(loc.getI(), loc.getJ(), h);
    }
    public void setHeight(Coord loc, float h) {
        setHeight(loc.getI(), loc.getJ(), h);
    }

    public int getHeight(int i, int j) {
        if(i < 0 || j < 0 || i >= N || j >= N)
            throw new IndexOutOfBoundsException("i and j must be in [0,N)");
        return heights[i][j];
    }
    public int getHeight(Coord loc) {
        return getHeight(loc.getI(), loc.getJ());
    }

    // computes distance between (i0,j0) and (i1,j1) as the crow flies
    public float computeDistance(int i0, int j0, int i1, int j1) {
        return (float)Math.sqrt((i0 - i1) * (i0 - i1) + (j0 - j1) * (j0 - j1));
    }
    public float computeDistance(Coord c0, Coord c1) {
        return computeDistance(c0.getI(), c0.getJ(), c1.getI(), c1.getJ());
    }

    public float computeTravelCost(int i0, int j0, int i1, int j1) {
        float h0 = getHeight(i0, j0), h1 = getHeight(i1, j1);
        float climb = (float)Math.pow(Math.abs(h0 - h1) * 1000.0, 1.5);
        float dist = computeDistance(i0,j0, i1,j1);
        return (1.0f + climb) * dist;
    }
    public float computeTravelCost(Coord c0, Coord c1) {
        return computeTravelCost(c0.getI(), c0.getJ(), c1.getI(), c1.getJ());
    }
    public float computeTravelCost(Iterable<Coord> cs) {
        Coord c0 = null;
        float cost = 0.0f;
        for(Coord c1 : cs) {
            if(c0 != null) cost += computeTravelCost(c0, c1);
            c0 = c1;
        }
        return cost;
    }
}

--[ 2019.11.23.23.25.47.756.0 ]--
InitFile: /src/InteractivePathfinderVisualizer.java
import java.awt.event.KeyEvent;

/**
 * InteractivePathfinderVisualizer visualizes the terrain and the computed
 * path and allows the user to change parameters of the Pathfinder.  Below
 * is a list of commands and what they do.  Note: some of the commands
 * modify the properties of the path finder and some modify the terrain.
 *
 * Command        Action                                      Terrain
 * C              clear path
 * space          recompute path
 * S/E            set start/end location to mouse
 * left/right     halve/double path search heuristic value
 * 0/1            set path search heuristic to 0 or 1
 * W              start a walker to show the path
 * R              randomly generate a new terrain                *
 * M              smooths terrain under mouse                    *
 * shift+M        smooths all terrain                            *
 * up/down        increase/decrease terrain under mouse          *
 */

public class InteractivePathfinderVisualizer {
    private final static int DELAY = 10;

    // sets how many redraws it should take for the walker to reach its destination
    private final static float STEPS_TO_WALK = 100.0f;

    // for convenience, here are the emap files that are located under heightmaps/ folder
    // the python script in that folder converts png files to emap. \
    // you can use it to create your own maps to test your code
    private final static String[] emaps = {
            "maze32_0.png.emap",    // 0   (32x32 maze)
            "maze32_1.png.emap",    // 1   (another 32x32 maze)
            "maze232_0.png.emap",   // 2   (232x232 maze)
            "maze320_0.png.emap",   // 3   (same as maze32_0, only scaled up by 10x)
            "mazeAB.png.emap",      // 4   (a maze from a site no longer online :( )
            "mazeBrain.png.emap",   // 5   (...)
            "ramp.png.emap",        // 6   (some tests)
            "ramp2.png.emap",       // 7   (...)
            "ramp3.png.emap",       // 8   (...)
            "usa128.png.emap",      // 9   (elevation map of USA from https://bananas.openttd.org/en/heightmap/)
            "usa256.png.emap",      // 10  (same as usa128, only higher resolution)
            "usa1024.png.emap",     // 11  (same as usa128, only higher resolution
    };

    private final static String emapFilename = emaps[11];        // change index to load a different elevation map



    public static void main(String[] args) {
        Terrain terrain = new Terrain(emapFilename);
        Pathfinder pf = new Pathfinder(terrain);
        int N = terrain.getN();

        StdDraw.show(0);

        // set default starting and ending locations
        pf.setPathStart(new Coord(1, 1));
        pf.setPathEnd(new Coord(N-3, N-3));

        // find a path
        pf.computePath();

        PathfinderVisualizer.draw(terrain, pf, null, N);
        StdDraw.show(DELAY);

        // prevent repeated applications
        boolean keyboardR = false;
        boolean keyboardM = false;

        Walker walker = null;

        while(true) {
            boolean recompute = false;
            boolean redraw = false;

            // mouse location on map
            int mouseI = (int) ((StdDraw.mouseX()-24) / 464 * N);
            int mouseJ = (int) ((464 - (StdDraw.mouseY()-36)) / 464 * N);
            boolean isMouseOnMap = (mouseI >=0 && mouseI < N && mouseJ >= 0 && mouseJ < N);

            if(StdDraw.isKeyPressed(KeyEvent.VK_LEFT) || StdDraw.isKeyPressed(KeyEvent.VK_RIGHT)) {
                boolean keyboardLeft = StdDraw.isKeyPressed(KeyEvent.VK_LEFT);
                float m = keyboardLeft ? 0.5f : 2.0f;
                float h = pf.getHeuristic() * m;
                h = Math.max(1.0f/1024.0f, Math.min(1048576.0f, h));
                pf.setHeuristic(h);
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_0) || StdDraw.isKeyPressed(KeyEvent.VK_1)) {
                boolean keyboard0 = StdDraw.isKeyPressed(KeyEvent.VK_0);
                float h = keyboard0 ? 0 : 1;
                pf.setHeuristic(h);
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_C)) {
                pf.resetPath();
                walker = null;
                redraw = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_R) && !keyboardR) {
                TerrainEditor.setFractalHeights(terrain);
                TerrainEditor.clampHeights(terrain);
                recompute = true;
            }
            keyboardR = StdDraw.isKeyPressed(KeyEvent.VK_R);

            if(StdDraw.isKeyPressed(KeyEvent.VK_M)) {
                if(StdDraw.isKeyPressed(KeyEvent.VK_SHIFT)) {
                    if(!keyboardM) {
                        TerrainEditor.smoothHeights(terrain);
                        recompute = true;
                    }
                } else {
                    TerrainEditor.smoothHeights(mouseI, mouseJ, N / 20, true, terrain);
                    recompute = true;
                }
            }
            keyboardM = StdDraw.isKeyPressed(KeyEvent.VK_M);

            if(StdDraw.isKeyPressed(KeyEvent.VK_SPACE)) {
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_UP) || StdDraw.isKeyPressed(KeyEvent.VK_DOWN)) {
                boolean keyboardUp = StdDraw.isKeyPressed(KeyEvent.VK_UP);
                float add = keyboardUp ? 8.0f : -8.0f;
                TerrainEditor.addHeight(mouseI, mouseJ, N / 20, add, terrain);
                recompute = true;
            }

            if(isMouseOnMap && StdDraw.isKeyPressed(KeyEvent.VK_S)) {
                pf.setPathStart(new Coord(mouseI, mouseJ));
                recompute = true;
            }

            if(isMouseOnMap && StdDraw.isKeyPressed(KeyEvent.VK_E)) {
                pf.setPathEnd(new Coord(mouseI, mouseJ));
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_W)) {
                Iterable<Coord> path = pf.getPathSolution();
                if(path != null) {
                    walker = new Walker(terrain, pf.getPathSolution());
                }
            }

            if(walker != null) {
                if(walker.doneWalking()) {
                    walker = null;
                } else {
                    walker.advance(pf.getPathCost() / STEPS_TO_WALK);
                }
                redraw = true;
            }

            if(recompute) {
                walker = null;
                pf.resetPath();
                if(pf.getPathStart() != null && pf.getPathEnd() != null) {
                    pf.computePath();
                }
                redraw = true;
            }

            if(redraw) {
                PathfinderVisualizer.draw(terrain, pf, walker, N);
                StdDraw.show(DELAY);
            } else {
                try {
                    Thread.sleep(10);
                } catch (InterruptedException e) {
                    /* do nothing */
                }
            }
        }
    }
}

--[ 2019.11.23.23.25.47.758.0 ]--
InitFile: /src/Pathfinder.java
import java.lang.IndexOutOfBoundsException;
import java.lang.IllegalArgumentException;

/**
 * Pathfinder uses A* search to find a near optimal path
 * between to locations with given terrain.
 */

public class Pathfinder {
    private Coord end;
    private Coord start;
    private Terrain terrain;
    private float heur;
    private boolean pathFound = false;  //implement in compute path, set to true when found
    private int searchSize;
    private PFNode[][] board;
    private PFNode endNode;
    private Stack<Coord> stack = new Stack<>();
    //set up Minimum Priority Queue
    private MinPQ<PFNode> pq = new MinPQ<>();
    private float pathCost;

    /**
     * PFNode will be the key for MinPQ (used in computePath())
     */
    private class PFNode implements Comparable<PFNode> {
        private boolean isUsed;
        private boolean invalid;
        private Coord loc;
        private PFNode fromNode;
        private float cost;
        // loc: the location of the PFNode
        // fromNode: how did we get here? (linked list back to start)

        public PFNode(Coord loc, PFNode fromNode) {
            this.loc = loc;
            this.fromNode = fromNode;
            if(fromNode != null)
                cost = fromNode.cost + terrain.computeTravelCost(loc, fromNode.loc);
        }

        // compares this with that, used to find minimum cost PFNode
        public int compareTo(PFNode that) {
            if(this.getCost(heur) < that.getCost(heur)) return -1;  //this < that
            if(that.getCost(heur) < this.getCost(heur)) return 1;   //that < this
            return 0;  //this == that
        }

        // returns the cost to travel from starting point to this
        // via the fromNode chain
        public float getCost(float heuristic) {  //call getCost with heuristic of 0, get travel cost, do A* search
            //return fromNode.getCost(0) + terrain.computeTravelCost(fromNode.loc, loc) + heuristic*terrain.computeDistance(loc.getI(), loc.getJ(), endNode.loc.getI(), endNode.loc.getJ());
            //StdOut.println(heuristic);
            //StdOut.println(terrain.computeDistance(loc.getI(), loc.getJ(), end.getI(), end.getJ()));
            //StdOut.println("Cost:" + cost);
            return cost + heuristic*terrain.computeDistance(loc.getI(), loc.getJ(), end.getI(), end.getJ());
        }

        // returns if this PFNode is not marked invalid
        public boolean isValid() {
            return invalid;
        }

        // marks the PFNode as invalid
        public void invalidate() {
            invalid = true;
        }

        // returns if the PFNode is marked as used
        public boolean isUsed() {  //help
            return isUsed;
        }

        // marks the PFNode as used
        public void use(PFNode node) {
            node.isUsed = true;
        }

        // returns an Iterable of PFNodes that surround this
        public Iterable<PFNode> neighbors() {
            Stack<PFNode> s = new Stack<>();
            s.push(new PFNode(null, null));
            return s;
        }
    }

    public Pathfinder(Terrain terrain) {
        this.terrain = terrain;
    }

    public void setPathStart(Coord loc) { // I need a check to see how it can stay on the white area.
        if(loc == null) throw new IllegalArgumentException("The location is null.");
        if(!loc.isInBounds(0,0,terrain.getN()-1, terrain.getN()-1)) throw new IndexOutOfBoundsException("The location is out of bounds.");
        start = loc;
    }

    public Coord getPathStart() {
        return start;
    }

    public void setPathEnd(Coord loc) {
        if(loc == null) throw new IllegalArgumentException("The location is null.");
        if(!loc.isInBounds(0,0,terrain.getN()-1, terrain.getN()-1)) throw new IndexOutOfBoundsException("The location is out of bounds.");
        end = loc;
    }

    public Coord getPathEnd() {
        return end;
    }

    public void setHeuristic(float v) { // is this correct?
        heur = v;
    }

    public float getHeuristic() { return heur; }

    public void resetPath() {
        start = getPathStart(); //how do I tell it to find where the mouse is at? setPathStart?
        end = getPathEnd();
        endNode = null;
        pathFound = false;
        searchSize = 0;

        pq = new MinPQ<>();

        stack = new Stack<>();

        //computePath();
    }

    public void computePath() {
        if(getPathEnd() == null || getPathStart() == null) throw new IllegalArgumentException("Either or both of start path or end path have NOT been set.");

        //set up logic board with 2D array
        int N = terrain.getN();
        board = new PFNode[N][N];

        //I added this... is it needed?
        //setHeuristic(3);

        PFNode beginNode = new PFNode(getPathStart(), null);
        board[getPathStart().getI()][getPathStart().getJ()] = beginNode;
        pq.insert(beginNode);
        beginNode.use(beginNode);
        beginNode.cost = 0;
        searchSize = 0;
        while(!pathFound){
            StdOut.println("path not found");
            //remove from pq
            PFNode removed = pq.delMin();
            //StdOut.println("The minimum has been removed.");  //bug check
            //check if node is at end
            if(removed.loc.equals(getPathEnd())){  //correct?
                pq.insert(removed);
                endNode = removed;
                pathFound = true;
                endNode.use(endNode);
                endNode.cost = removed.cost + terrain.computeTravelCost(removed.loc, endNode.loc);
                pathCost = endNode.cost;
                searchSize ++;
                break;
            }
            //"process" node just removed
            //see if the locations around the removed position are in bounds
            //now have them point to removed, "from = removed";  ?
            if(removed.loc.getJ() -1 >= 0 ){
               if(board[removed.loc.getI()][removed.loc.getJ()-1] == null){
                    PFNode node = new PFNode(removed.loc.add(0, -1), removed); //good
                    board[removed.loc.getI()][removed.loc.getJ() - 1] = node;
                    pq.insert(node);
                    node.use(node);
                    searchSize ++;
                    //node.cost = removed.cost + terrain.computeTravelCost(removed.loc, node.loc);
                }
            }
            if(removed.loc.getI() - 1 >= 0){
                if(board[removed.loc.getI()-1][removed.loc.getJ()] == null) {
                    PFNode node = new PFNode(removed.loc.add(-1, 0), removed); //good
                    board[removed.loc.getI() - 1][removed.loc.getJ()] = node;
                    pq.insert(node);
                    node.use(node);
                    searchSize ++;
                    //node.cost = removed.cost + terrain.computeTravelCost(removed.loc, node.loc);
                }
            }
            if(removed.loc.getJ() + 1 < N-1){
                if(board[removed.loc.getI()][removed.loc.getJ()+1] == null) {
                    PFNode node = new PFNode(removed.loc.add(0, 1), removed); //good
                    board[removed.loc.getI()][removed.loc.getJ() + 1] = node;
                    pq.insert(node);
                    node.use(node);
                    searchSize ++;
                    //node.cost = removed.cost + terrain.computeTravelCost(removed.loc, node.loc);
                }
            }
            if(removed.loc.getI() + 1 < N-1){
                if(board[removed.loc.getI()+1][removed.loc.getJ()] == null) {
                    PFNode node = new PFNode(removed.loc.add(1, 0), removed); //good
                    board[removed.loc.getI() + 1][removed.loc.getJ()] = node;
                    pq.insert(node);
                    node.use(node);
                    searchSize ++;
                    //node.cost = removed.cost + terrain.computeTravelCost(removed.loc, node.loc);
                }
            }
        }
        StdOut.println("A connection has been found!");

        stack.push(endNode.loc);
        PFNode nextNode = endNode.fromNode;
        while(nextNode.fromNode != beginNode){
            stack.push(nextNode.loc);
            nextNode = nextNode.fromNode;
        }
        //this should be the start node
        stack.push(nextNode.fromNode.loc);
    }

    public boolean foundPath() { //good
        return pathFound;
    }

    public float getPathCost() { //good
        return pathCost;
    }

    public int getSearchSize() { //good
        return searchSize;
    }

    public Iterable<Coord> getPathSolution() {
        return stack;
    } //good

    public boolean wasSearched(Coord loc) { //good
        return board[loc.getI()][loc.getJ()] != null;
    }

}

--[ 2019.11.23.23.25.47.760.0 ]--
InitFile: /.cos265


--[ 2019.11.23.23.26.05.912.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.23.23.26.48.135.0 ]--
:/src/Pathfinder.java
r 216         stack.push(nextNode.fromNode.loc);""
--[ 2019.11.23.23.26.48.613.0 ]--
r 216         stack.push(nextNode.fromNode.loc);"n"
--[ 2019.11.23.23.26.48.701.0 ]--
r 216         stack.push(nextNode.fromNode.loc);"no"
--[ 2019.11.23.23.26.48.897.0 ]--
r 216         stack.push(nextNode.fromNode.loc);"not"
--[ 2019.11.23.23.26.52.486.0 ]--
r 216         stack.push(nextNode.fromNode.loc);"not
--[ 2019.11.23.23.26.52.660.0 ]--
r 216         stack.push(nextNode.fromNode.loc);"no
--[ 2019.11.23.23.26.52.828.0 ]--
r 216         stack.push(nextNode.fromNode.loc);"n
--[ 2019.11.23.23.26.52.946.0 ]--
r 216         stack.push(nextNode.fromNode.loc);"
--[ 2019.11.23.23.26.53.317.0 ]--
r 216         stack.push(nextNode.fromNode.loc);
--[ 2019.11.23.23.27.03.730.0 ]--
r 148             /StdOut.println("path not found");
--[ 2019.11.23.23.27.03.847.0 ]--
r 148             //StdOut.println("path not found");
--[ 2019.11.23.23.27.17.298.0 ]--
UpdateTree (AD): 61 0
+ /out/production/P04_Pathfinding/.donotlog
+ /out/production/P04_Pathfinding/algs4.jar
+ /out/production/P04_Pathfinding/stdlib.jar
+ /out/production/P04_Pathfinding/Coord.class
+ /out/production/P04_Pathfinding/png2emap.py
+ /out/production/P04_Pathfinding/Walker.class
+ /out/production/P04_Pathfinding/ramp.png.emap
+ /out/production/P04_Pathfinding/Terrain.class
+ /out/production/P04_Pathfinding/ramp2.png.emap
+ /out/production/P04_Pathfinding/ramp3.png.emap
+ /out/production/P04_Pathfinding/mazeAB.png.emap
+ /out/production/P04_Pathfinding/usa128.png.emap
+ /out/production/P04_Pathfinding/usa256.png.emap
+ /out/production/P04_Pathfinding/Pathfinder.class
+ /out/production/P04_Pathfinding/usa1024.png.emap
+ /out/production/P04_Pathfinding/maze32_0.png.emap
+ /out/production/P04_Pathfinding/maze32_1.png.emap
+ /out/production/P04_Pathfinding/maze232_0.png.emap
+ /out/production/P04_Pathfinding/maze320_0.png.emap
+ /out/production/P04_Pathfinding/mazeBrain.png.emap
+ /out/production/P04_Pathfinding/TerrainEditor.class
+ /out/production/P04_Pathfinding/Pathfinder$PFNode.class
+ /out/production/P04_Pathfinding/PathfinderVisualizer.class
+ /out/production/P04_Pathfinding/InteractivePathfinderVisualizer.class
+ /src/algs4.jar
+ /src/Coord.java
+ /src/stdlib.jar
+ /src/Walker.java
+ /src/Terrain.java
+ /src/Pathfinder.java
+ /src/TerrainEditor.java
+ /src/PathfinderVisualizer.java
+ /src/InteractivePathfinderVisualizer.java
+ /.log/history.log
+ /.idea/copyright/profiles_settings.xml
+ /.idea/libraries/algs4.xml
+ /.idea/libraries/stdlib.xml
+ /.idea/.name
+ /.idea/misc.xml
+ /.idea/modules.xml
+ /.idea/compiler.xml
+ /.idea/workspace.xml
+ /.idea/uiDesigner.xml
+ /heightmaps/.donotlog
+ /heightmaps/png2emap.py
+ /heightmaps/ramp.png.emap
+ /heightmaps/ramp2.png.emap
+ /heightmaps/ramp3.png.emap
+ /heightmaps/mazeAB.png.emap
+ /heightmaps/usa128.png.emap
+ /heightmaps/usa256.png.emap
+ /heightmaps/usa1024.png.emap
+ /heightmaps/maze32_0.png.emap
+ /heightmaps/maze32_1.png.emap
+ /heightmaps/maze232_0.png.emap
+ /heightmaps/maze320_0.png.emap
+ /heightmaps/mazeBrain.png.emap
+ /.cos265
+ /readme.html
+ /P04_Pathfinding.iml
+ /P04_Pathfinding.zip

--[ 2019.11.23.23.27.17.301.0 ]--
InitFile: /src/Coord.java
/**
 * Coordinates is an immutable type that store the tuple (i, j)
 */
public final class Coord {
    private final int i;
    private final int j;

    public Coord(int i, int j) {
        this.i = i;
        this.j = j;
    }

    public int getI() { return i; }
    public int getJ() { return j; }

    public boolean isInBounds(int minI, int minJ, int maxI, int maxJ) {
        return i >= minI && j >= minJ && i <= maxI && j <= maxJ;
    }
    public boolean isInBounds(Coord min, Coord max) {
        return i >= min.i && i <= max.i && j >= min.j && j <= max.j;
    }

    public Coord add(int addI, int addJ) {
        return new Coord(i + addI, j + addJ);
    }
    public Coord add(Coord that) { return new Coord(i + that.i, j + that.j); }

    public String toString() { return "(" + i + "," + j + ")"; }

    public boolean equals(Object o) {
        if(this == o) return true;
        if(o == null) return false;
        if(o.getClass() != this.getClass()) return false;
        Coord that = (Coord) o;
        if(this.i != that.i) return false;
        if(this.j != that.j) return false;
        return true;
    }
}

--[ 2019.11.23.23.27.17.303.0 ]--
InitFile: /src/Walker.java
import java.util.Iterator;

/**
 * Walker takes an Iterable of Coords and simulates an individual
 * walking along the path over the given Terrain
 */
public class Walker {
    private Terrain terrain;
    private Iterable<Coord> path;
    private Iterator<Coord> iterator;
    private Coord position;
    private float currentCost;
    private Coord previous = null;
    float runningCost = 0;

    // terrain: the Terrain the Walker traverses
    // path: the sequence of Coords the Walker follows
    public Walker(Terrain terrain, Iterable<Coord> path) {
        this.terrain = terrain;
        this.path = path;
        iterator = path.iterator();
    }

    // returns the Walker's current location
    public Coord getLocation() {
        /*if(previous == null){
            currentCost = 0;
        } else {
            currentCost = terrain.computeTravelCost(previous, position);
        }

        previous = this.position;
        */
        return this.position;
    }

    // returns true if Walker has reached the end Coord (last in path)
    public boolean doneWalking() {
        if(iterator.hasNext()){
            return false;
        }
        return true;
    }

    // advances the Walker along path
    // byTime: how long the Walker should traverse (may be any non-negative value)
    public void advance(float byTime) {
        /*
        if(runningCost >= currentCost){
            this.position = iterator.next();
            runningCost = 0;
        } else {
            runningCost+= byTime;
        }
        */
        this.position = iterator.next();
    }
}
//compute travel cost to know how long it takes to go to each spot
//start walker at first coord
//getlocation always calls beginning until advance is called
//when advance is called, move walker to next thing in iterable


//byTime take into account travel cost
//keep track of how many times advance is called and then compare that to the travel cost.

--[ 2019.11.23.23.27.17.305.0 ]--
InitFile: /src/Terrain.java
import java.lang.IndexOutOfBoundsException;

/**
 * Terrain stores elevations for map and computes distance and
 * cost in traversing the terrain.
 */

public class Terrain {
    private int N;
    private int[][] heights;

    public Terrain(int N) {
        this.N = N;
        this.heights = new int[N][N];
    }

    public Terrain(int[][] heights) {
        this.N = heights.length;
        this.heights = heights;
    }

    public Terrain(String emapfile) {
        In in = new In(emapfile);
        this.N = in.readInt();
        this.heights = new int[N][N];
        for (int j = 0; j < N; j++) {
            for (int i = 0; i < N; i++) {
                this.heights[i][j] = in.readInt();
            }
        }
    }

    public int getN() {
        return N;
    }

    public void setHeight(int i, int j, int h) {
        if(i < 0 || j < 0 || i >= N || j >= N)
            throw new IndexOutOfBoundsException("i and j must be in [0,N)");
        heights[i][j] = h;
    }
    public void setHeight(int i, int j, float h) {
        setHeight(i, j, (int) h);
    }
    public void setHeight(Coord loc, int h) {
        setHeight(loc.getI(), loc.getJ(), h);
    }
    public void setHeight(Coord loc, float h) {
        setHeight(loc.getI(), loc.getJ(), h);
    }

    public int getHeight(int i, int j) {
        if(i < 0 || j < 0 || i >= N || j >= N)
            throw new IndexOutOfBoundsException("i and j must be in [0,N)");
        return heights[i][j];
    }
    public int getHeight(Coord loc) {
        return getHeight(loc.getI(), loc.getJ());
    }

    // computes distance between (i0,j0) and (i1,j1) as the crow flies
    public float computeDistance(int i0, int j0, int i1, int j1) {
        return (float)Math.sqrt((i0 - i1) * (i0 - i1) + (j0 - j1) * (j0 - j1));
    }
    public float computeDistance(Coord c0, Coord c1) {
        return computeDistance(c0.getI(), c0.getJ(), c1.getI(), c1.getJ());
    }

    public float computeTravelCost(int i0, int j0, int i1, int j1) {
        float h0 = getHeight(i0, j0), h1 = getHeight(i1, j1);
        float climb = (float)Math.pow(Math.abs(h0 - h1) * 1000.0, 1.5);
        float dist = computeDistance(i0,j0, i1,j1);
        return (1.0f + climb) * dist;
    }
    public float computeTravelCost(Coord c0, Coord c1) {
        return computeTravelCost(c0.getI(), c0.getJ(), c1.getI(), c1.getJ());
    }
    public float computeTravelCost(Iterable<Coord> cs) {
        Coord c0 = null;
        float cost = 0.0f;
        for(Coord c1 : cs) {
            if(c0 != null) cost += computeTravelCost(c0, c1);
            c0 = c1;
        }
        return cost;
    }
}

--[ 2019.11.23.23.27.17.307.0 ]--
InitFile: /src/Pathfinder.java
import java.lang.IndexOutOfBoundsException;
import java.lang.IllegalArgumentException;

/**
 * Pathfinder uses A* search to find a near optimal path
 * between to locations with given terrain.
 */

public class Pathfinder {
    private Coord end;
    private Coord start;
    private Terrain terrain;
    private float heur;
    private boolean pathFound = false;  //implement in compute path, set to true when found
    private int searchSize;
    private PFNode[][] board;
    private PFNode endNode;
    private Stack<Coord> stack = new Stack<>();
    //set up Minimum Priority Queue
    private MinPQ<PFNode> pq = new MinPQ<>();
    private float pathCost;

    /**
     * PFNode will be the key for MinPQ (used in computePath())
     */
    private class PFNode implements Comparable<PFNode> {
        private boolean isUsed;
        private boolean invalid;
        private Coord loc;
        private PFNode fromNode;
        private float cost;
        // loc: the location of the PFNode
        // fromNode: how did we get here? (linked list back to start)

        public PFNode(Coord loc, PFNode fromNode) {
            this.loc = loc;
            this.fromNode = fromNode;
            if(fromNode != null)
                cost = fromNode.cost + terrain.computeTravelCost(loc, fromNode.loc);
        }

        // compares this with that, used to find minimum cost PFNode
        public int compareTo(PFNode that) {
            if(this.getCost(heur) < that.getCost(heur)) return -1;  //this < that
            if(that.getCost(heur) < this.getCost(heur)) return 1;   //that < this
            return 0;  //this == that
        }

        // returns the cost to travel from starting point to this
        // via the fromNode chain
        public float getCost(float heuristic) {  //call getCost with heuristic of 0, get travel cost, do A* search
            //return fromNode.getCost(0) + terrain.computeTravelCost(fromNode.loc, loc) + heuristic*terrain.computeDistance(loc.getI(), loc.getJ(), endNode.loc.getI(), endNode.loc.getJ());
            //StdOut.println(heuristic);
            //StdOut.println(terrain.computeDistance(loc.getI(), loc.getJ(), end.getI(), end.getJ()));
            //StdOut.println("Cost:" + cost);
            return cost + heuristic*terrain.computeDistance(loc.getI(), loc.getJ(), end.getI(), end.getJ());
        }

        // returns if this PFNode is not marked invalid
        public boolean isValid() {
            return invalid;
        }

        // marks the PFNode as invalid
        public void invalidate() {
            invalid = true;
        }

        // returns if the PFNode is marked as used
        public boolean isUsed() {  //help
            return isUsed;
        }

        // marks the PFNode as used
        public void use(PFNode node) {
            node.isUsed = true;
        }

        // returns an Iterable of PFNodes that surround this
        public Iterable<PFNode> neighbors() {
            Stack<PFNode> s = new Stack<>();
            s.push(new PFNode(null, null));
            return s;
        }
    }

    public Pathfinder(Terrain terrain) {
        this.terrain = terrain;
    }

    public void setPathStart(Coord loc) { // I need a check to see how it can stay on the white area.
        if(loc == null) throw new IllegalArgumentException("The location is null.");
        if(!loc.isInBounds(0,0,terrain.getN()-1, terrain.getN()-1)) throw new IndexOutOfBoundsException("The location is out of bounds.");
        start = loc;
    }

    public Coord getPathStart() {
        return start;
    }

    public void setPathEnd(Coord loc) {
        if(loc == null) throw new IllegalArgumentException("The location is null.");
        if(!loc.isInBounds(0,0,terrain.getN()-1, terrain.getN()-1)) throw new IndexOutOfBoundsException("The location is out of bounds.");
        end = loc;
    }

    public Coord getPathEnd() {
        return end;
    }

    public void setHeuristic(float v) { // is this correct?
        heur = v;
    }

    public float getHeuristic() { return heur; }

    public void resetPath() {
        start = getPathStart(); //how do I tell it to find where the mouse is at? setPathStart?
        end = getPathEnd();
        endNode = null;
        pathFound = false;
        searchSize = 0;

        pq = new MinPQ<>();

        stack = new Stack<>();

        //computePath();
    }

    public void computePath() {
        if(getPathEnd() == null || getPathStart() == null) throw new IllegalArgumentException("Either or both of start path or end path have NOT been set.");

        //set up logic board with 2D array
        int N = terrain.getN();
        board = new PFNode[N][N];

        //I added this... is it needed?
        //setHeuristic(3);

        PFNode beginNode = new PFNode(getPathStart(), null);
        board[getPathStart().getI()][getPathStart().getJ()] = beginNode;
        pq.insert(beginNode);
        beginNode.use(beginNode);
        beginNode.cost = 0;
        searchSize = 0;
        while(!pathFound){
            //StdOut.println("path not found");
            //remove from pq
            PFNode removed = pq.delMin();
            //StdOut.println("The minimum has been removed.");  //bug check
            //check if node is at end
            if(removed.loc.equals(getPathEnd())){  //correct?
                pq.insert(removed);
                endNode = removed;
                pathFound = true;
                endNode.use(endNode);
                endNode.cost = removed.cost + terrain.computeTravelCost(removed.loc, endNode.loc);
                pathCost = endNode.cost;
                searchSize ++;
                break;
            }
            //"process" node just removed
            //see if the locations around the removed position are in bounds
            //now have them point to removed, "from = removed";  ?
            if(removed.loc.getJ() -1 >= 0 ){
               if(board[removed.loc.getI()][removed.loc.getJ()-1] == null){
                    PFNode node = new PFNode(removed.loc.add(0, -1), removed); //good
                    board[removed.loc.getI()][removed.loc.getJ() - 1] = node;
                    pq.insert(node);
                    node.use(node);
                    searchSize ++;
                    //node.cost = removed.cost + terrain.computeTravelCost(removed.loc, node.loc);
                }
            }
            if(removed.loc.getI() - 1 >= 0){
                if(board[removed.loc.getI()-1][removed.loc.getJ()] == null) {
                    PFNode node = new PFNode(removed.loc.add(-1, 0), removed); //good
                    board[removed.loc.getI() - 1][removed.loc.getJ()] = node;
                    pq.insert(node);
                    node.use(node);
                    searchSize ++;
                    //node.cost = removed.cost + terrain.computeTravelCost(removed.loc, node.loc);
                }
            }
            if(removed.loc.getJ() + 1 < N-1){
                if(board[removed.loc.getI()][removed.loc.getJ()+1] == null) {
                    PFNode node = new PFNode(removed.loc.add(0, 1), removed); //good
                    board[removed.loc.getI()][removed.loc.getJ() + 1] = node;
                    pq.insert(node);
                    node.use(node);
                    searchSize ++;
                    //node.cost = removed.cost + terrain.computeTravelCost(removed.loc, node.loc);
                }
            }
            if(removed.loc.getI() + 1 < N-1){
                if(board[removed.loc.getI()+1][removed.loc.getJ()] == null) {
                    PFNode node = new PFNode(removed.loc.add(1, 0), removed); //good
                    board[removed.loc.getI() + 1][removed.loc.getJ()] = node;
                    pq.insert(node);
                    node.use(node);
                    searchSize ++;
                    //node.cost = removed.cost + terrain.computeTravelCost(removed.loc, node.loc);
                }
            }
        }
        StdOut.println("A connection has been found!");

        stack.push(endNode.loc);
        PFNode nextNode = endNode.fromNode;
        while(nextNode.fromNode != beginNode){
            stack.push(nextNode.loc);
            nextNode = nextNode.fromNode;
        }
        //this should be the start node
        stack.push(nextNode.fromNode.loc);
    }

    public boolean foundPath() { //good
        return pathFound;
    }

    public float getPathCost() { //good
        return pathCost;
    }

    public int getSearchSize() { //good
        return searchSize;
    }

    public Iterable<Coord> getPathSolution() {
        return stack;
    } //good

    public boolean wasSearched(Coord loc) { //good
        return board[loc.getI()][loc.getJ()] != null;
    }

}

--[ 2019.11.23.23.27.17.310.0 ]--
InitFile: /src/TerrainEditor.java
/**
 * The following class provides some simple terrain editing functions.
 */
public class TerrainEditor {
    private static float rndRadius(float d) {
        return (float)StdRandom.uniform(-d,d);
    }

    private static float getFractalHeight(int i, int j, float dh, Terrain terrain, boolean[] isset) {
        int N = terrain.getN();
        dh = Math.max(-64, Math.min(255+64, dh));   // allow the height to go just a bit out of range
        if(!isset[i + j * N]) {
            isset[i + j * N] = true;
            terrain.setHeight(i, j, dh);
        }
        return terrain.getHeight(i,j);
    }

    private static void setFractalHeights(int i0, int j0, int i1, int j1, Terrain terrain, boolean[] isset) {
        int id = i1-i0;
        int jd = j1-j0;
        int i01 = (i0+i1)/2;
        int j01 = (j0+j1)/2;

        if(id <= 1 && jd <= 1) return;

        float h00 = getFractalHeight(i0,j0,32,terrain,isset);
        float h01 = getFractalHeight(i0,j1,32,terrain,isset);
        float h10 = getFractalHeight(i1,j0,32,terrain,isset);
        float h11 = getFractalHeight(i1,j1,32,terrain,isset);

        float d = (float)(Math.sqrt((i1-i0)*(i1-i0) + (j1-j0)*(j1-j0)) * 0.5);

        float d0001 = (h00 + h01) / 2 + rndRadius(d);
        float d0010 = (h00 + h10) / 2 + rndRadius(d);
        float d1101 = (h11 + h01) / 2 + rndRadius(d);
        float d1110 = (h11 + h10) / 2 + rndRadius(d);

        float h0001 = getFractalHeight(i0, j01, d0001, terrain,isset);
        float h0010 = getFractalHeight(i01, j0, d0010, terrain,isset);
        float h1101 = getFractalHeight(i01, j1, d1101, terrain,isset);
        float h1110 = getFractalHeight(i1, j01, d1110, terrain,isset);

        float dm = (float)((h0001 + h0010 + h1101 + h1110) / 4.0);
        float hm = getFractalHeight(i01, j01, dm, terrain,isset);

        if(id > 1 && jd > 1) {
            setFractalHeights(i0, j0, i01, j01, terrain, isset);
            setFractalHeights(i01, j0, i1, j01, terrain, isset);
            setFractalHeights(i0, j01, i01, j1, terrain, isset);
            setFractalHeights(i01, j01, i1, j1, terrain, isset);
        } else if(jd > 1) {
            setFractalHeights(i0, j0, i1, j01, terrain, isset);
            setFractalHeights(i0, j01, i1, j1, terrain, isset);
        } else {
            setFractalHeights(i0, j0, i01, j1, terrain, isset);
            setFractalHeights(i01, j0, i1, j1, terrain, isset);
        }
    }

    public static void setFractalHeights(Terrain terrain) {
        int N = terrain.getN();
        boolean[] isset = new boolean[N*N];
        setFractalHeights(0, 0, N - 1, N - 1, terrain, isset);
    }

    public static void smoothHeights(Terrain terrain) {
        int N = terrain.getN();
        int radius = (int)Math.ceil(Math.sqrt(N*N/2.0f));
        smoothHeights(N/2, N/2, radius, false, terrain);
    }

    public static void smoothHeights(int ic, int jc, int radius, boolean fallOff, Terrain terrain) {
        final int N = terrain.getN();
        final int w = 2*radius+1;
        float[] s = new float[w*w];
        for(int ia = -radius; ia <= radius; ia++) {
            int i = ic + ia;
            if(i < 0 || i >= N) continue;
            for(int ja = -radius; ja <= radius; ja++) {
                int j = jc + ja;
                if(j < 0 || j >= N) continue;
                int sidx = (ia+radius) + (ja+radius)*w;

                float m = computeEffect(i, j, ic, jc, radius, fallOff, N);
                if(m <= 0.0000001) {
                    s[sidx] = terrain.getHeight(i,j);
                    continue;
                }
                float h = 0;
                int c = 0;
                if(i > 0 && j > 0) {
                    h += terrain.getHeight(i-1,j-1);
                    c += 1;
                }
                if(i < N-1 && j > 0) {
                    h += terrain.getHeight(i+1,j-1);
                    c += 1;
                }
                if(i > 0 && j < N-1) {
                    h += terrain.getHeight(i-1,j+1);
                    c += 1;
                }
                if(i < N-1 && j < N-1) {
                    h += terrain.getHeight(i+1,j+1);
                    c += 1;
                }
                if(i > 0) {
                    h += terrain.getHeight(i-1,j);
                    c += 1;
                }
                if(j > 0) {
                    h += terrain.getHeight(i,j-1);
                    c += 1;
                }
                if(i < N-1) {
                    h += terrain.getHeight(i+1,j);
                    c += 1;
                }
                if(j < N-1) {
                    h += terrain.getHeight(i,j+1);
                    c += 1;
                }
                s[sidx] = (1-m) * terrain.getHeight(i,j) + m * h / c;
            }
        }
        for(int ia = -radius; ia <= radius; ia++) {
            int i = ic + ia;
            if(i < 0 || i >= N) continue;
            for(int ja = -radius; ja <= radius; ja++) {
                int j = jc + ja;
                if(j < 0 || j >= N) continue;
                int sidx = (ia+radius) + (ja+radius)*w;
                terrain.setHeight(i, j, s[sidx]);
            }
        }
    }

    public static void clampHeights(Terrain terrain) {
        int N = terrain.getN();
        for(int i = 0; i < N; i++) {
            for(int j = 0; j < N; j++) {
                terrain.setHeight(i, j, Math.max(0, Math.min(255, terrain.getHeight(i, j))));
            }
        }
    }

    private static float computeEffect(int i, int j, int ic, int jc, int radius, boolean fallOff, int N) {
        if(i < 0 || j < 0 || i >= N || j >= N) return 0;
        if(!fallOff) return 1;
        int d2 = (ic-i)*(ic-i)+(jc-j)*(jc-j);
        if(d2 > radius*radius) return 0;
        return ((float)radius - (float)Math.sqrt(d2)) / (float)radius;
    }

    public static void addHeight(int i, int j, int radius, float add, Terrain terrain) {
        final int N = terrain.getN();
        for(int ja = -radius; ja <= radius; ja++) {
            int r = j + ja;
            if(r < 0 || r >= N) continue;
            for(int ia = -radius; ia <= radius; ia++) {
                int c = i + ia;
                if(c < 0 || c >= N) continue;
                float v = add * computeEffect(c, r, i, j, radius, true, N);
                float h = terrain.getHeight(c, r) + v;
                h = Math.max(0, Math.min(255, h));
                terrain.setHeight(c, r, h);
            }
        }
    }
}

--[ 2019.11.23.23.27.17.313.0 ]--
InitFile: /src/PathfinderVisualizer.java
/**
 * PathfinderVisualizer visualizes the terrain and found path.
 */

import java.awt.Color;
import java.awt.Font;

public class PathfinderVisualizer {

    // delay in milliseconds (controls animation speed)
    private final static int DELAY = 100;

    // color for different elevations.  must be in ascending order!
    private final static int[][] elevationColors = {
            // h    r   g   b   where h=height, r=red, g=green, b=blue
            {  0,   0,  0,  0},
            {  2,   0,  0,160},
            {  4,   0,224,224},
            { 16, 192,192,  0},
            { 64,  16,255, 16},
            {128,  32,224, 32},
            {192, 128,128,  8},
            {224, 164,164,164},
            {255, 255,255,255}
    };

    private final static Color cStart    = new Color(128, 128, 255);
    private final static Color cEnd      = new Color(255, 128, 128);
    private final static Color cSolution = new Color(255, 128, 255);
    private final static Color cSearched = new Color(128,   0, 128);

    // linearly interpolating between the corresponding rgb values
    private static Color colorLERP(float v1, int r0, int g0, int b0, int r1, int g1, int b1) {
        v1 = Math.max(0.0f, Math.min(1.0f, v1));
        float v0 = 1.0f - v1;
        int r = (int)(v0 * r0 + v1 * r1);
        int g = (int)(v0 * g0 + v1 * g1);
        int b = (int)(v0 * b0 + v1 * b1);
        return new Color(r, g, b);
    }
    private static Color colorLERP(float v1, Color c0, Color c1) {
        v1 = Math.max(0.0f, Math.min(1.0f, v1));
        float v0 = 1.0f - v1;
        int r = (int)(v0 * c0.getRed()   + v1 * c1.getRed());
        int g = (int)(v0 * c0.getGreen() + v1 * c1.getGreen());
        int b = (int)(v0 * c0.getBlue()  + v1 * c1.getBlue());
        int a = (int)(v0 * c0.getAlpha() + v1 * c1.getAlpha());
        return new Color(r, g, b, a);
    }

    // returns color for given height
    private static Color height2Color(int h) {
        h = Math.max(0, Math.min(255, h));

        int[] ec0 = elevationColors[0];  // default lower bound
        int[] ec1 = elevationColors[1];  // default upper bound

        // find upper bound while updating lower bound
        for(int i = 1; i < elevationColors.length; i++) {
            ec1 = elevationColors[i];
            if(h >= ec0[0] && h <= ec1[0]) break;
            ec0 = ec1;
        }

        int h0=ec0[0], r0=ec0[1], g0=ec0[2], b0=ec0[3];
        int h1=ec1[0], r1=ec1[1], g1=ec1[2], b1=ec1[3];
        float v1 = ((float)(h - h0)) / ((float)(h1 - h0));

        return colorLERP(v1, r0, g0, b0, r1, g1, b1);
    }

    private static void drawCircle(int i, int j, int N, double rad) {
        int c = (int)((i+0.5f) * 464.0f / N);
        int r = (int)((j+0.5f) * 464.0f / N);
        StdDraw.circle(c + 24, 464 - r + 36, rad);
    }
    public static void drawCircle(Coord loc, int N, double rad) {
        drawCircle(loc.getI(), loc.getJ(), N, rad);
    }

    private static void drawPath(Iterable<Coord> path, int N) {
        boolean first = true;
        int c0 = 0, r0 = 0;
        for (Coord loc : path) {
            int c1 = (int)((loc.getI()+0.5f) * 464.0f / N);
            int r1 = (int)((loc.getJ()+0.5f) * 464.0f / N);
            if(!first) {
                StdDraw.line(c0 + 24, 464 - r0 + 36, c1 + 24, 464 - r1 + 36);
            }
            first = false;
            c0 = c1; r0 = r1;
        }
    }

    // draw N-by-N pathfinding map
    public static void draw(Terrain terrain, Pathfinder pf, Walker walker, int N) {
        StdDraw.clear();
        StdDraw.setXscale(0, 512);
        StdDraw.setYscale(0, 512);
        StdDraw.setPenColor(StdDraw.BLACK);
        StdDraw.filledSquare(256, 256 + 12, 464 / 2);

        // draw terrain
        for(int row = 0; row < 464; row++) {
            int j = (int)((float)row/464.0f * N);
            for(int col = 0; col < 464; col++) {
                int i = (int)((float)col/464.0f * N);
                Coord loc = new Coord(i,j);
                Color c = height2Color(terrain.getHeight(loc));
                if(pf.wasSearched(loc)) {
                    c = colorLERP(0.50f, c, cSearched);
                }
                StdDraw.setPenColor(c);
                StdDraw.filledSquare(col + 24, 464 - row + 36, 1);
            }
        }

        // draw path start
        if(pf.getPathStart() != null) {
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            drawCircle(pf.getPathStart(), N, 4.0);

            StdDraw.setPenColor(cStart);
            StdDraw.setPenRadius(0.002);
            drawCircle(pf.getPathStart(), N, 4.0);
        }

        // draw path end
        if(pf.getPathEnd() != null) {
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            drawCircle(pf.getPathEnd(), N, 4.0);

            StdDraw.setPenColor(cEnd);
            StdDraw.setPenRadius(0.002);
            drawCircle(pf.getPathEnd(), N, 4.0);
        }

        // draw found path
        if(pf.foundPath()) {
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            drawPath(pf.getPathSolution(), N);

            StdDraw.setPenColor(cSolution);
            StdDraw.setPenRadius(0.002);
            drawPath(pf.getPathSolution(), N);
        }

        // draw walker
        if(walker != null) {
            Coord loc = walker.getLocation();
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            PathfinderVisualizer.drawCircle(loc, N, 2.0);

            StdDraw.setPenColor(StdDraw.WHITE);
            StdDraw.setPenRadius(0.002);
            PathfinderVisualizer.drawCircle(loc, N, 2.0);
        }

        // write status text
        StdDraw.setFont(new Font("SansSerif", Font.PLAIN, 12));
        StdDraw.setPenColor(StdDraw.BLACK);
        StdDraw.text(96, 12, "heuristic: " + pf.getHeuristic());
        if(pf.foundPath()) StdDraw.text(256, 12, "path: " + pf.getPathCost());
        else               StdDraw.text(256, 12, "no path found");
        StdDraw.text(512-96, 12, "searched: " + pf.getSearchSize() + " (" + (int)(100.0f * pf.getSearchSize() / (N*N)) + "%)");
    }
}

--[ 2019.11.23.23.27.17.316.0 ]--
InitFile: /src/InteractivePathfinderVisualizer.java
import java.awt.event.KeyEvent;

/**
 * InteractivePathfinderVisualizer visualizes the terrain and the computed
 * path and allows the user to change parameters of the Pathfinder.  Below
 * is a list of commands and what they do.  Note: some of the commands
 * modify the properties of the path finder and some modify the terrain.
 *
 * Command        Action                                      Terrain
 * C              clear path
 * space          recompute path
 * S/E            set start/end location to mouse
 * left/right     halve/double path search heuristic value
 * 0/1            set path search heuristic to 0 or 1
 * W              start a walker to show the path
 * R              randomly generate a new terrain                *
 * M              smooths terrain under mouse                    *
 * shift+M        smooths all terrain                            *
 * up/down        increase/decrease terrain under mouse          *
 */

public class InteractivePathfinderVisualizer {
    private final static int DELAY = 10;

    // sets how many redraws it should take for the walker to reach its destination
    private final static float STEPS_TO_WALK = 100.0f;

    // for convenience, here are the emap files that are located under heightmaps/ folder
    // the python script in that folder converts png files to emap. \
    // you can use it to create your own maps to test your code
    private final static String[] emaps = {
            "maze32_0.png.emap",    // 0   (32x32 maze)
            "maze32_1.png.emap",    // 1   (another 32x32 maze)
            "maze232_0.png.emap",   // 2   (232x232 maze)
            "maze320_0.png.emap",   // 3   (same as maze32_0, only scaled up by 10x)
            "mazeAB.png.emap",      // 4   (a maze from a site no longer online :( )
            "mazeBrain.png.emap",   // 5   (...)
            "ramp.png.emap",        // 6   (some tests)
            "ramp2.png.emap",       // 7   (...)
            "ramp3.png.emap",       // 8   (...)
            "usa128.png.emap",      // 9   (elevation map of USA from https://bananas.openttd.org/en/heightmap/)
            "usa256.png.emap",      // 10  (same as usa128, only higher resolution)
            "usa1024.png.emap",     // 11  (same as usa128, only higher resolution
    };

    private final static String emapFilename = emaps[11];        // change index to load a different elevation map



    public static void main(String[] args) {
        Terrain terrain = new Terrain(emapFilename);
        Pathfinder pf = new Pathfinder(terrain);
        int N = terrain.getN();

        StdDraw.show(0);

        // set default starting and ending locations
        pf.setPathStart(new Coord(1, 1));
        pf.setPathEnd(new Coord(N-3, N-3));

        // find a path
        pf.computePath();

        PathfinderVisualizer.draw(terrain, pf, null, N);
        StdDraw.show(DELAY);

        // prevent repeated applications
        boolean keyboardR = false;
        boolean keyboardM = false;

        Walker walker = null;

        while(true) {
            boolean recompute = false;
            boolean redraw = false;

            // mouse location on map
            int mouseI = (int) ((StdDraw.mouseX()-24) / 464 * N);
            int mouseJ = (int) ((464 - (StdDraw.mouseY()-36)) / 464 * N);
            boolean isMouseOnMap = (mouseI >=0 && mouseI < N && mouseJ >= 0 && mouseJ < N);

            if(StdDraw.isKeyPressed(KeyEvent.VK_LEFT) || StdDraw.isKeyPressed(KeyEvent.VK_RIGHT)) {
                boolean keyboardLeft = StdDraw.isKeyPressed(KeyEvent.VK_LEFT);
                float m = keyboardLeft ? 0.5f : 2.0f;
                float h = pf.getHeuristic() * m;
                h = Math.max(1.0f/1024.0f, Math.min(1048576.0f, h));
                pf.setHeuristic(h);
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_0) || StdDraw.isKeyPressed(KeyEvent.VK_1)) {
                boolean keyboard0 = StdDraw.isKeyPressed(KeyEvent.VK_0);
                float h = keyboard0 ? 0 : 1;
                pf.setHeuristic(h);
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_C)) {
                pf.resetPath();
                walker = null;
                redraw = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_R) && !keyboardR) {
                TerrainEditor.setFractalHeights(terrain);
                TerrainEditor.clampHeights(terrain);
                recompute = true;
            }
            keyboardR = StdDraw.isKeyPressed(KeyEvent.VK_R);

            if(StdDraw.isKeyPressed(KeyEvent.VK_M)) {
                if(StdDraw.isKeyPressed(KeyEvent.VK_SHIFT)) {
                    if(!keyboardM) {
                        TerrainEditor.smoothHeights(terrain);
                        recompute = true;
                    }
                } else {
                    TerrainEditor.smoothHeights(mouseI, mouseJ, N / 20, true, terrain);
                    recompute = true;
                }
            }
            keyboardM = StdDraw.isKeyPressed(KeyEvent.VK_M);

            if(StdDraw.isKeyPressed(KeyEvent.VK_SPACE)) {
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_UP) || StdDraw.isKeyPressed(KeyEvent.VK_DOWN)) {
                boolean keyboardUp = StdDraw.isKeyPressed(KeyEvent.VK_UP);
                float add = keyboardUp ? 8.0f : -8.0f;
                TerrainEditor.addHeight(mouseI, mouseJ, N / 20, add, terrain);
                recompute = true;
            }

            if(isMouseOnMap && StdDraw.isKeyPressed(KeyEvent.VK_S)) {
                pf.setPathStart(new Coord(mouseI, mouseJ));
                recompute = true;
            }

            if(isMouseOnMap && StdDraw.isKeyPressed(KeyEvent.VK_E)) {
                pf.setPathEnd(new Coord(mouseI, mouseJ));
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_W)) {
                Iterable<Coord> path = pf.getPathSolution();
                if(path != null) {
                    walker = new Walker(terrain, pf.getPathSolution());
                }
            }

            if(walker != null) {
                if(walker.doneWalking()) {
                    walker = null;
                } else {
                    walker.advance(pf.getPathCost() / STEPS_TO_WALK);
                }
                redraw = true;
            }

            if(recompute) {
                walker = null;
                pf.resetPath();
                if(pf.getPathStart() != null && pf.getPathEnd() != null) {
                    pf.computePath();
                }
                redraw = true;
            }

            if(redraw) {
                PathfinderVisualizer.draw(terrain, pf, walker, N);
                StdDraw.show(DELAY);
            } else {
                try {
                    Thread.sleep(10);
                } catch (InterruptedException e) {
                    /* do nothing */
                }
            }
        }
    }
}

--[ 2019.11.23.23.27.17.319.0 ]--
InitFile: /.cos265


--[ 2019.11.23.23.27.17.321.0 ]--
InitFile: /P04_Pathfinding.iml
<?xml version="1.0" encoding="UTF-8"?>
<module type="JAVA_MODULE" version="4">
  <component name="NewModuleRootManager" inherit-compiler-output="true">
    <exclude-output />
    <content url="file://$MODULE_DIR$">
      <sourceFolder url="file://$MODULE_DIR$/src" isTestSource="false" />
      <sourceFolder url="file://$MODULE_DIR$/heightmaps" type="java-resource" />
      <excludeFolder url="file://$MODULE_DIR$/.log" />
    </content>
    <orderEntry type="inheritedJdk" />
    <orderEntry type="sourceFolder" forTests="false" />
    <orderEntry type="library" name="algs4" level="project" />
    <orderEntry type="library" name="stdlib" level="project" />
  </component>
</module>

--[ 2019.11.23.23.27.17.323.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.23.23.27.50.404.0 ]--
:/src/InteractivePathfinderVisualizer.java
r 46     private final static String emapFilename = emaps[1];        // change index to load a different elevation map
--[ 2019.11.23.23.27.50.509.0 ]--
r 46     private final static String emapFilename = emaps[];        // change index to load a different elevation map
--[ 2019.11.23.23.27.51.125.0 ]--
r 46     private final static String emapFilename = emaps[0];        // change index to load a different elevation map
--[ 2019.11.23.23.28.00.864.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.23.23.28.34.070.0 ]--
r 46     private final static String emapFilename = emaps[];        // change index to load a different elevation map
--[ 2019.11.23.23.28.34.364.0 ]--
r 46     private final static String emapFilename = emaps[1];        // change index to load a different elevation map
--[ 2019.11.23.23.28.38.629.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.23.23.29.12.062.0 ]--
r 46     private final static String emapFilename = emaps[];        // change index to load a different elevation map
--[ 2019.11.23.23.29.12.337.0 ]--
r 46     private final static String emapFilename = emaps[5];        // change index to load a different elevation map
--[ 2019.11.23.23.29.16.675.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.24.18.29.00.735.0 ]--
DisposeComponent
--[ 2020.07.17.00.48.10.979.0 ]--
NewLogger: P04_Pathfinding
Version: 1.3
--[ 2020.07.17.00.48.11.168.0 ]--
InitTree:
/out/production/P04_Pathfinding/.donotlog
/out/production/P04_Pathfinding/algs4.jar
/out/production/P04_Pathfinding/stdlib.jar
/out/production/P04_Pathfinding/Coord.class
/out/production/P04_Pathfinding/png2emap.py
/out/production/P04_Pathfinding/Walker.class
/out/production/P04_Pathfinding/ramp.png.emap
/out/production/P04_Pathfinding/Terrain.class
/out/production/P04_Pathfinding/ramp2.png.emap
/out/production/P04_Pathfinding/ramp3.png.emap
/out/production/P04_Pathfinding/mazeAB.png.emap
/out/production/P04_Pathfinding/usa128.png.emap
/out/production/P04_Pathfinding/usa256.png.emap
/out/production/P04_Pathfinding/Pathfinder.class
/out/production/P04_Pathfinding/usa1024.png.emap
/out/production/P04_Pathfinding/maze32_0.png.emap
/out/production/P04_Pathfinding/maze32_1.png.emap
/out/production/P04_Pathfinding/maze232_0.png.emap
/out/production/P04_Pathfinding/maze320_0.png.emap
/out/production/P04_Pathfinding/mazeBrain.png.emap
/out/production/P04_Pathfinding/TerrainEditor.class
/out/production/P04_Pathfinding/Pathfinder$PFNode.class
/out/production/P04_Pathfinding/PathfinderVisualizer.class
/out/production/P04_Pathfinding/InteractivePathfinderVisualizer.class
/src/algs4.jar
/src/Coord.java
/src/stdlib.jar
/src/Walker.java
/src/Terrain.java
/src/Pathfinder.java
/src/TerrainEditor.java
/src/PathfinderVisualizer.java
/src/InteractivePathfinderVisualizer.java
/.log/history.log
/.idea/copyright/profiles_settings.xml
/.idea/libraries/algs4.xml
/.idea/libraries/stdlib.xml
/.idea/.name
/.idea/misc.xml
/.idea/modules.xml
/.idea/compiler.xml
/.idea/workspace.xml
/.idea/uiDesigner.xml
/heightmaps/.donotlog
/heightmaps/png2emap.py
/heightmaps/ramp.png.emap
/heightmaps/ramp2.png.emap
/heightmaps/ramp3.png.emap
/heightmaps/mazeAB.png.emap
/heightmaps/usa128.png.emap
/heightmaps/usa256.png.emap
/heightmaps/usa1024.png.emap
/heightmaps/maze32_0.png.emap
/heightmaps/maze32_1.png.emap
/heightmaps/maze232_0.png.emap
/heightmaps/maze320_0.png.emap
/heightmaps/mazeBrain.png.emap
/.cos265
/readme.html
/P04_Pathfinding.iml
/P04_Pathfinding.zip

--[ 2020.07.17.00.48.11.168.1 ]--
InitFile: /src/PathfinderVisualizer.java
/**
 * PathfinderVisualizer visualizes the terrain and found path.
 */

import java.awt.Color;
import java.awt.Font;

public class PathfinderVisualizer {

    // delay in milliseconds (controls animation speed)
    private final static int DELAY = 100;

    // color for different elevations.  must be in ascending order!
    private final static int[][] elevationColors = {
            // h    r   g   b   where h=height, r=red, g=green, b=blue
            {  0,   0,  0,  0},
            {  2,   0,  0,160},
            {  4,   0,224,224},
            { 16, 192,192,  0},
            { 64,  16,255, 16},
            {128,  32,224, 32},
            {192, 128,128,  8},
            {224, 164,164,164},
            {255, 255,255,255}
    };

    private final static Color cStart    = new Color(128, 128, 255);
    private final static Color cEnd      = new Color(255, 128, 128);
    private final static Color cSolution = new Color(255, 128, 255);
    private final static Color cSearched = new Color(128,   0, 128);

    // linearly interpolating between the corresponding rgb values
    private static Color colorLERP(float v1, int r0, int g0, int b0, int r1, int g1, int b1) {
        v1 = Math.max(0.0f, Math.min(1.0f, v1));
        float v0 = 1.0f - v1;
        int r = (int)(v0 * r0 + v1 * r1);
        int g = (int)(v0 * g0 + v1 * g1);
        int b = (int)(v0 * b0 + v1 * b1);
        return new Color(r, g, b);
    }
    private static Color colorLERP(float v1, Color c0, Color c1) {
        v1 = Math.max(0.0f, Math.min(1.0f, v1));
        float v0 = 1.0f - v1;
        int r = (int)(v0 * c0.getRed()   + v1 * c1.getRed());
        int g = (int)(v0 * c0.getGreen() + v1 * c1.getGreen());
        int b = (int)(v0 * c0.getBlue()  + v1 * c1.getBlue());
        int a = (int)(v0 * c0.getAlpha() + v1 * c1.getAlpha());
        return new Color(r, g, b, a);
    }

    // returns color for given height
    private static Color height2Color(int h) {
        h = Math.max(0, Math.min(255, h));

        int[] ec0 = elevationColors[0];  // default lower bound
        int[] ec1 = elevationColors[1];  // default upper bound

        // find upper bound while updating lower bound
        for(int i = 1; i < elevationColors.length; i++) {
            ec1 = elevationColors[i];
            if(h >= ec0[0] && h <= ec1[0]) break;
            ec0 = ec1;
        }

        int h0=ec0[0], r0=ec0[1], g0=ec0[2], b0=ec0[3];
        int h1=ec1[0], r1=ec1[1], g1=ec1[2], b1=ec1[3];
        float v1 = ((float)(h - h0)) / ((float)(h1 - h0));

        return colorLERP(v1, r0, g0, b0, r1, g1, b1);
    }

    private static void drawCircle(int i, int j, int N, double rad) {
        int c = (int)((i+0.5f) * 464.0f / N);
        int r = (int)((j+0.5f) * 464.0f / N);
        StdDraw.circle(c + 24, 464 - r + 36, rad);
    }
    public static void drawCircle(Coord loc, int N, double rad) {
        drawCircle(loc.getI(), loc.getJ(), N, rad);
    }

    private static void drawPath(Iterable<Coord> path, int N) {
        boolean first = true;
        int c0 = 0, r0 = 0;
        for (Coord loc : path) {
            int c1 = (int)((loc.getI()+0.5f) * 464.0f / N);
            int r1 = (int)((loc.getJ()+0.5f) * 464.0f / N);
            if(!first) {
                StdDraw.line(c0 + 24, 464 - r0 + 36, c1 + 24, 464 - r1 + 36);
            }
            first = false;
            c0 = c1; r0 = r1;
        }
    }

    // draw N-by-N pathfinding map
    public static void draw(Terrain terrain, Pathfinder pf, Walker walker, int N) {
        StdDraw.clear();
        StdDraw.setXscale(0, 512);
        StdDraw.setYscale(0, 512);
        StdDraw.setPenColor(StdDraw.BLACK);
        StdDraw.filledSquare(256, 256 + 12, 464 / 2);

        // draw terrain
        for(int row = 0; row < 464; row++) {
            int j = (int)((float)row/464.0f * N);
            for(int col = 0; col < 464; col++) {
                int i = (int)((float)col/464.0f * N);
                Coord loc = new Coord(i,j);
                Color c = height2Color(terrain.getHeight(loc));
                if(pf.wasSearched(loc)) {
                    c = colorLERP(0.50f, c, cSearched);
                }
                StdDraw.setPenColor(c);
                StdDraw.filledSquare(col + 24, 464 - row + 36, 1);
            }
        }

        // draw path start
        if(pf.getPathStart() != null) {
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            drawCircle(pf.getPathStart(), N, 4.0);

            StdDraw.setPenColor(cStart);
            StdDraw.setPenRadius(0.002);
            drawCircle(pf.getPathStart(), N, 4.0);
        }

        // draw path end
        if(pf.getPathEnd() != null) {
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            drawCircle(pf.getPathEnd(), N, 4.0);

            StdDraw.setPenColor(cEnd);
            StdDraw.setPenRadius(0.002);
            drawCircle(pf.getPathEnd(), N, 4.0);
        }

        // draw found path
        if(pf.foundPath()) {
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            drawPath(pf.getPathSolution(), N);

            StdDraw.setPenColor(cSolution);
            StdDraw.setPenRadius(0.002);
            drawPath(pf.getPathSolution(), N);
        }

        // draw walker
        if(walker != null) {
            Coord loc = walker.getLocation();
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.setPenRadius(0.006);
            PathfinderVisualizer.drawCircle(loc, N, 2.0);

            StdDraw.setPenColor(StdDraw.WHITE);
            StdDraw.setPenRadius(0.002);
            PathfinderVisualizer.drawCircle(loc, N, 2.0);
        }

        // write status text
        StdDraw.setFont(new Font("SansSerif", Font.PLAIN, 12));
        StdDraw.setPenColor(StdDraw.BLACK);
        StdDraw.text(96, 12, "heuristic: " + pf.getHeuristic());
        if(pf.foundPath()) StdDraw.text(256, 12, "path: " + pf.getPathCost());
        else               StdDraw.text(256, 12, "no path found");
        StdDraw.text(512-96, 12, "searched: " + pf.getSearchSize() + " (" + (int)(100.0f * pf.getSearchSize() / (N*N)) + "%)");
    }
}

--[ 2020.07.17.00.48.11.169.0 ]--
InitFile: /P04_Pathfinding.iml
<?xml version="1.0" encoding="UTF-8"?>
<module type="JAVA_MODULE" version="4">
  <component name="NewModuleRootManager" inherit-compiler-output="true">
    <exclude-output />
    <content url="file://$MODULE_DIR$">
      <sourceFolder url="file://$MODULE_DIR$/src" isTestSource="false" />
      <sourceFolder url="file://$MODULE_DIR$/heightmaps" type="java-resource" />
      <excludeFolder url="file://$MODULE_DIR$/.log" />
    </content>
    <orderEntry type="inheritedJdk" />
    <orderEntry type="sourceFolder" forTests="false" />
    <orderEntry type="library" name="algs4" level="project" />
    <orderEntry type="library" name="stdlib" level="project" />
  </component>
</module>

--[ 2020.07.17.00.48.11.170.0 ]--
InitFile: /src/Coord.java
/**
 * Coordinates is an immutable type that store the tuple (i, j)
 */
public final class Coord {
    private final int i;
    private final int j;

    public Coord(int i, int j) {
        this.i = i;
        this.j = j;
    }

    public int getI() { return i; }
    public int getJ() { return j; }

    public boolean isInBounds(int minI, int minJ, int maxI, int maxJ) {
        return i >= minI && j >= minJ && i <= maxI && j <= maxJ;
    }
    public boolean isInBounds(Coord min, Coord max) {
        return i >= min.i && i <= max.i && j >= min.j && j <= max.j;
    }

    public Coord add(int addI, int addJ) {
        return new Coord(i + addI, j + addJ);
    }
    public Coord add(Coord that) { return new Coord(i + that.i, j + that.j); }

    public String toString() { return "(" + i + "," + j + ")"; }

    public boolean equals(Object o) {
        if(this == o) return true;
        if(o == null) return false;
        if(o.getClass() != this.getClass()) return false;
        Coord that = (Coord) o;
        if(this.i != that.i) return false;
        if(this.j != that.j) return false;
        return true;
    }
}

--[ 2020.07.17.00.48.11.170.1 ]--
InitFile: /src/Walker.java
import java.util.Iterator;

/**
 * Walker takes an Iterable of Coords and simulates an individual
 * walking along the path over the given Terrain
 */
public class Walker {
    private Terrain terrain;
    private Iterable<Coord> path;
    private Iterator<Coord> iterator;
    private Coord position;
    private float currentCost;
    private Coord previous = null;
    float runningCost = 0;

    // terrain: the Terrain the Walker traverses
    // path: the sequence of Coords the Walker follows
    public Walker(Terrain terrain, Iterable<Coord> path) {
        this.terrain = terrain;
        this.path = path;
        iterator = path.iterator();
    }

    // returns the Walker's current location
    public Coord getLocation() {
        /*if(previous == null){
            currentCost = 0;
        } else {
            currentCost = terrain.computeTravelCost(previous, position);
        }

        previous = this.position;
        */
        return this.position;
    }

    // returns true if Walker has reached the end Coord (last in path)
    public boolean doneWalking() {
        if(iterator.hasNext()){
            return false;
        }
        return true;
    }

    // advances the Walker along path
    // byTime: how long the Walker should traverse (may be any non-negative value)
    public void advance(float byTime) {
        /*
        if(runningCost >= currentCost){
            this.position = iterator.next();
            runningCost = 0;
        } else {
            runningCost+= byTime;
        }
        */
        this.position = iterator.next();
    }
}
//compute travel cost to know how long it takes to go to each spot
//start walker at first coord
//getlocation always calls beginning until advance is called
//when advance is called, move walker to next thing in iterable


//byTime take into account travel cost
//keep track of how many times advance is called and then compare that to the travel cost.

--[ 2020.07.17.00.48.11.171.0 ]--
InitFile: /src/TerrainEditor.java
/**
 * The following class provides some simple terrain editing functions.
 */
public class TerrainEditor {
    private static float rndRadius(float d) {
        return (float)StdRandom.uniform(-d,d);
    }

    private static float getFractalHeight(int i, int j, float dh, Terrain terrain, boolean[] isset) {
        int N = terrain.getN();
        dh = Math.max(-64, Math.min(255+64, dh));   // allow the height to go just a bit out of range
        if(!isset[i + j * N]) {
            isset[i + j * N] = true;
            terrain.setHeight(i, j, dh);
        }
        return terrain.getHeight(i,j);
    }

    private static void setFractalHeights(int i0, int j0, int i1, int j1, Terrain terrain, boolean[] isset) {
        int id = i1-i0;
        int jd = j1-j0;
        int i01 = (i0+i1)/2;
        int j01 = (j0+j1)/2;

        if(id <= 1 && jd <= 1) return;

        float h00 = getFractalHeight(i0,j0,32,terrain,isset);
        float h01 = getFractalHeight(i0,j1,32,terrain,isset);
        float h10 = getFractalHeight(i1,j0,32,terrain,isset);
        float h11 = getFractalHeight(i1,j1,32,terrain,isset);

        float d = (float)(Math.sqrt((i1-i0)*(i1-i0) + (j1-j0)*(j1-j0)) * 0.5);

        float d0001 = (h00 + h01) / 2 + rndRadius(d);
        float d0010 = (h00 + h10) / 2 + rndRadius(d);
        float d1101 = (h11 + h01) / 2 + rndRadius(d);
        float d1110 = (h11 + h10) / 2 + rndRadius(d);

        float h0001 = getFractalHeight(i0, j01, d0001, terrain,isset);
        float h0010 = getFractalHeight(i01, j0, d0010, terrain,isset);
        float h1101 = getFractalHeight(i01, j1, d1101, terrain,isset);
        float h1110 = getFractalHeight(i1, j01, d1110, terrain,isset);

        float dm = (float)((h0001 + h0010 + h1101 + h1110) / 4.0);
        float hm = getFractalHeight(i01, j01, dm, terrain,isset);

        if(id > 1 && jd > 1) {
            setFractalHeights(i0, j0, i01, j01, terrain, isset);
            setFractalHeights(i01, j0, i1, j01, terrain, isset);
            setFractalHeights(i0, j01, i01, j1, terrain, isset);
            setFractalHeights(i01, j01, i1, j1, terrain, isset);
        } else if(jd > 1) {
            setFractalHeights(i0, j0, i1, j01, terrain, isset);
            setFractalHeights(i0, j01, i1, j1, terrain, isset);
        } else {
            setFractalHeights(i0, j0, i01, j1, terrain, isset);
            setFractalHeights(i01, j0, i1, j1, terrain, isset);
        }
    }

    public static void setFractalHeights(Terrain terrain) {
        int N = terrain.getN();
        boolean[] isset = new boolean[N*N];
        setFractalHeights(0, 0, N - 1, N - 1, terrain, isset);
    }

    public static void smoothHeights(Terrain terrain) {
        int N = terrain.getN();
        int radius = (int)Math.ceil(Math.sqrt(N*N/2.0f));
        smoothHeights(N/2, N/2, radius, false, terrain);
    }

    public static void smoothHeights(int ic, int jc, int radius, boolean fallOff, Terrain terrain) {
        final int N = terrain.getN();
        final int w = 2*radius+1;
        float[] s = new float[w*w];
        for(int ia = -radius; ia <= radius; ia++) {
            int i = ic + ia;
            if(i < 0 || i >= N) continue;
            for(int ja = -radius; ja <= radius; ja++) {
                int j = jc + ja;
                if(j < 0 || j >= N) continue;
                int sidx = (ia+radius) + (ja+radius)*w;

                float m = computeEffect(i, j, ic, jc, radius, fallOff, N);
                if(m <= 0.0000001) {
                    s[sidx] = terrain.getHeight(i,j);
                    continue;
                }
                float h = 0;
                int c = 0;
                if(i > 0 && j > 0) {
                    h += terrain.getHeight(i-1,j-1);
                    c += 1;
                }
                if(i < N-1 && j > 0) {
                    h += terrain.getHeight(i+1,j-1);
                    c += 1;
                }
                if(i > 0 && j < N-1) {
                    h += terrain.getHeight(i-1,j+1);
                    c += 1;
                }
                if(i < N-1 && j < N-1) {
                    h += terrain.getHeight(i+1,j+1);
                    c += 1;
                }
                if(i > 0) {
                    h += terrain.getHeight(i-1,j);
                    c += 1;
                }
                if(j > 0) {
                    h += terrain.getHeight(i,j-1);
                    c += 1;
                }
                if(i < N-1) {
                    h += terrain.getHeight(i+1,j);
                    c += 1;
                }
                if(j < N-1) {
                    h += terrain.getHeight(i,j+1);
                    c += 1;
                }
                s[sidx] = (1-m) * terrain.getHeight(i,j) + m * h / c;
            }
        }
        for(int ia = -radius; ia <= radius; ia++) {
            int i = ic + ia;
            if(i < 0 || i >= N) continue;
            for(int ja = -radius; ja <= radius; ja++) {
                int j = jc + ja;
                if(j < 0 || j >= N) continue;
                int sidx = (ia+radius) + (ja+radius)*w;
                terrain.setHeight(i, j, s[sidx]);
            }
        }
    }

    public static void clampHeights(Terrain terrain) {
        int N = terrain.getN();
        for(int i = 0; i < N; i++) {
            for(int j = 0; j < N; j++) {
                terrain.setHeight(i, j, Math.max(0, Math.min(255, terrain.getHeight(i, j))));
            }
        }
    }

    private static float computeEffect(int i, int j, int ic, int jc, int radius, boolean fallOff, int N) {
        if(i < 0 || j < 0 || i >= N || j >= N) return 0;
        if(!fallOff) return 1;
        int d2 = (ic-i)*(ic-i)+(jc-j)*(jc-j);
        if(d2 > radius*radius) return 0;
        return ((float)radius - (float)Math.sqrt(d2)) / (float)radius;
    }

    public static void addHeight(int i, int j, int radius, float add, Terrain terrain) {
        final int N = terrain.getN();
        for(int ja = -radius; ja <= radius; ja++) {
            int r = j + ja;
            if(r < 0 || r >= N) continue;
            for(int ia = -radius; ia <= radius; ia++) {
                int c = i + ia;
                if(c < 0 || c >= N) continue;
                float v = add * computeEffect(c, r, i, j, radius, true, N);
                float h = terrain.getHeight(c, r) + v;
                h = Math.max(0, Math.min(255, h));
                terrain.setHeight(c, r, h);
            }
        }
    }
}

--[ 2020.07.17.00.48.11.172.0 ]--
InitFile: /src/Terrain.java
import java.lang.IndexOutOfBoundsException;

/**
 * Terrain stores elevations for map and computes distance and
 * cost in traversing the terrain.
 */

public class Terrain {
    private int N;
    private int[][] heights;

    public Terrain(int N) {
        this.N = N;
        this.heights = new int[N][N];
    }

    public Terrain(int[][] heights) {
        this.N = heights.length;
        this.heights = heights;
    }

    public Terrain(String emapfile) {
        In in = new In(emapfile);
        this.N = in.readInt();
        this.heights = new int[N][N];
        for (int j = 0; j < N; j++) {
            for (int i = 0; i < N; i++) {
                this.heights[i][j] = in.readInt();
            }
        }
    }

    public int getN() {
        return N;
    }

    public void setHeight(int i, int j, int h) {
        if(i < 0 || j < 0 || i >= N || j >= N)
            throw new IndexOutOfBoundsException("i and j must be in [0,N)");
        heights[i][j] = h;
    }
    public void setHeight(int i, int j, float h) {
        setHeight(i, j, (int) h);
    }
    public void setHeight(Coord loc, int h) {
        setHeight(loc.getI(), loc.getJ(), h);
    }
    public void setHeight(Coord loc, float h) {
        setHeight(loc.getI(), loc.getJ(), h);
    }

    public int getHeight(int i, int j) {
        if(i < 0 || j < 0 || i >= N || j >= N)
            throw new IndexOutOfBoundsException("i and j must be in [0,N)");
        return heights[i][j];
    }
    public int getHeight(Coord loc) {
        return getHeight(loc.getI(), loc.getJ());
    }

    // computes distance between (i0,j0) and (i1,j1) as the crow flies
    public float computeDistance(int i0, int j0, int i1, int j1) {
        return (float)Math.sqrt((i0 - i1) * (i0 - i1) + (j0 - j1) * (j0 - j1));
    }
    public float computeDistance(Coord c0, Coord c1) {
        return computeDistance(c0.getI(), c0.getJ(), c1.getI(), c1.getJ());
    }

    public float computeTravelCost(int i0, int j0, int i1, int j1) {
        float h0 = getHeight(i0, j0), h1 = getHeight(i1, j1);
        float climb = (float)Math.pow(Math.abs(h0 - h1) * 1000.0, 1.5);
        float dist = computeDistance(i0,j0, i1,j1);
        return (1.0f + climb) * dist;
    }
    public float computeTravelCost(Coord c0, Coord c1) {
        return computeTravelCost(c0.getI(), c0.getJ(), c1.getI(), c1.getJ());
    }
    public float computeTravelCost(Iterable<Coord> cs) {
        Coord c0 = null;
        float cost = 0.0f;
        for(Coord c1 : cs) {
            if(c0 != null) cost += computeTravelCost(c0, c1);
            c0 = c1;
        }
        return cost;
    }
}

--[ 2020.07.17.00.48.11.173.0 ]--
InitFile: /src/InteractivePathfinderVisualizer.java
import java.awt.event.KeyEvent;

/**
 * InteractivePathfinderVisualizer visualizes the terrain and the computed
 * path and allows the user to change parameters of the Pathfinder.  Below
 * is a list of commands and what they do.  Note: some of the commands
 * modify the properties of the path finder and some modify the terrain.
 *
 * Command        Action                                      Terrain
 * C              clear path
 * space          recompute path
 * S/E            set start/end location to mouse
 * left/right     halve/double path search heuristic value
 * 0/1            set path search heuristic to 0 or 1
 * W              start a walker to show the path
 * R              randomly generate a new terrain                *
 * M              smooths terrain under mouse                    *
 * shift+M        smooths all terrain                            *
 * up/down        increase/decrease terrain under mouse          *
 */

public class InteractivePathfinderVisualizer {
    private final static int DELAY = 10;

    // sets how many redraws it should take for the walker to reach its destination
    private final static float STEPS_TO_WALK = 100.0f;

    // for convenience, here are the emap files that are located under heightmaps/ folder
    // the python script in that folder converts png files to emap. \
    // you can use it to create your own maps to test your code
    private final static String[] emaps = {
            "maze32_0.png.emap",    // 0   (32x32 maze)
            "maze32_1.png.emap",    // 1   (another 32x32 maze)
            "maze232_0.png.emap",   // 2   (232x232 maze)
            "maze320_0.png.emap",   // 3   (same as maze32_0, only scaled up by 10x)
            "mazeAB.png.emap",      // 4   (a maze from a site no longer online :( )
            "mazeBrain.png.emap",   // 5   (...)
            "ramp.png.emap",        // 6   (some tests)
            "ramp2.png.emap",       // 7   (...)
            "ramp3.png.emap",       // 8   (...)
            "usa128.png.emap",      // 9   (elevation map of USA from https://bananas.openttd.org/en/heightmap/)
            "usa256.png.emap",      // 10  (same as usa128, only higher resolution)
            "usa1024.png.emap",     // 11  (same as usa128, only higher resolution
    };

    private final static String emapFilename = emaps[5];        // change index to load a different elevation map



    public static void main(String[] args) {
        Terrain terrain = new Terrain(emapFilename);
        Pathfinder pf = new Pathfinder(terrain);
        int N = terrain.getN();

        StdDraw.show(0);

        // set default starting and ending locations
        pf.setPathStart(new Coord(1, 1));
        pf.setPathEnd(new Coord(N-3, N-3));

        // find a path
        pf.computePath();

        PathfinderVisualizer.draw(terrain, pf, null, N);
        StdDraw.show(DELAY);

        // prevent repeated applications
        boolean keyboardR = false;
        boolean keyboardM = false;

        Walker walker = null;

        while(true) {
            boolean recompute = false;
            boolean redraw = false;

            // mouse location on map
            int mouseI = (int) ((StdDraw.mouseX()-24) / 464 * N);
            int mouseJ = (int) ((464 - (StdDraw.mouseY()-36)) / 464 * N);
            boolean isMouseOnMap = (mouseI >=0 && mouseI < N && mouseJ >= 0 && mouseJ < N);

            if(StdDraw.isKeyPressed(KeyEvent.VK_LEFT) || StdDraw.isKeyPressed(KeyEvent.VK_RIGHT)) {
                boolean keyboardLeft = StdDraw.isKeyPressed(KeyEvent.VK_LEFT);
                float m = keyboardLeft ? 0.5f : 2.0f;
                float h = pf.getHeuristic() * m;
                h = Math.max(1.0f/1024.0f, Math.min(1048576.0f, h));
                pf.setHeuristic(h);
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_0) || StdDraw.isKeyPressed(KeyEvent.VK_1)) {
                boolean keyboard0 = StdDraw.isKeyPressed(KeyEvent.VK_0);
                float h = keyboard0 ? 0 : 1;
                pf.setHeuristic(h);
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_C)) {
                pf.resetPath();
                walker = null;
                redraw = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_R) && !keyboardR) {
                TerrainEditor.setFractalHeights(terrain);
                TerrainEditor.clampHeights(terrain);
                recompute = true;
            }
            keyboardR = StdDraw.isKeyPressed(KeyEvent.VK_R);

            if(StdDraw.isKeyPressed(KeyEvent.VK_M)) {
                if(StdDraw.isKeyPressed(KeyEvent.VK_SHIFT)) {
                    if(!keyboardM) {
                        TerrainEditor.smoothHeights(terrain);
                        recompute = true;
                    }
                } else {
                    TerrainEditor.smoothHeights(mouseI, mouseJ, N / 20, true, terrain);
                    recompute = true;
                }
            }
            keyboardM = StdDraw.isKeyPressed(KeyEvent.VK_M);

            if(StdDraw.isKeyPressed(KeyEvent.VK_SPACE)) {
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_UP) || StdDraw.isKeyPressed(KeyEvent.VK_DOWN)) {
                boolean keyboardUp = StdDraw.isKeyPressed(KeyEvent.VK_UP);
                float add = keyboardUp ? 8.0f : -8.0f;
                TerrainEditor.addHeight(mouseI, mouseJ, N / 20, add, terrain);
                recompute = true;
            }

            if(isMouseOnMap && StdDraw.isKeyPressed(KeyEvent.VK_S)) {
                pf.setPathStart(new Coord(mouseI, mouseJ));
                recompute = true;
            }

            if(isMouseOnMap && StdDraw.isKeyPressed(KeyEvent.VK_E)) {
                pf.setPathEnd(new Coord(mouseI, mouseJ));
                recompute = true;
            }

            if(StdDraw.isKeyPressed(KeyEvent.VK_W)) {
                Iterable<Coord> path = pf.getPathSolution();
                if(path != null) {
                    walker = new Walker(terrain, pf.getPathSolution());
                }
            }

            if(walker != null) {
                if(walker.doneWalking()) {
                    walker = null;
                } else {
                    walker.advance(pf.getPathCost() / STEPS_TO_WALK);
                }
                redraw = true;
            }

            if(recompute) {
                walker = null;
                pf.resetPath();
                if(pf.getPathStart() != null && pf.getPathEnd() != null) {
                    pf.computePath();
                }
                redraw = true;
            }

            if(redraw) {
                PathfinderVisualizer.draw(terrain, pf, walker, N);
                StdDraw.show(DELAY);
            } else {
                try {
                    Thread.sleep(10);
                } catch (InterruptedException e) {
                    /* do nothing */
                }
            }
        }
    }
}

--[ 2020.07.17.00.48.11.174.0 ]--
InitFile: /src/Pathfinder.java
import java.lang.IndexOutOfBoundsException;
import java.lang.IllegalArgumentException;

/**
 * Pathfinder uses A* search to find a near optimal path
 * between to locations with given terrain.
 */

public class Pathfinder {
    private Coord end;
    private Coord start;
    private Terrain terrain;
    private float heur;
    private boolean pathFound = false;  //implement in compute path, set to true when found
    private int searchSize;
    private PFNode[][] board;
    private PFNode endNode;
    private Stack<Coord> stack = new Stack<>();
    //set up Minimum Priority Queue
    private MinPQ<PFNode> pq = new MinPQ<>();
    private float pathCost;

    /**
     * PFNode will be the key for MinPQ (used in computePath())
     */
    private class PFNode implements Comparable<PFNode> {
        private boolean isUsed;
        private boolean invalid;
        private Coord loc;
        private PFNode fromNode;
        private float cost;
        // loc: the location of the PFNode
        // fromNode: how did we get here? (linked list back to start)

        public PFNode(Coord loc, PFNode fromNode) {
            this.loc = loc;
            this.fromNode = fromNode;
            if(fromNode != null)
                cost = fromNode.cost + terrain.computeTravelCost(loc, fromNode.loc);
        }

        // compares this with that, used to find minimum cost PFNode
        public int compareTo(PFNode that) {
            if(this.getCost(heur) < that.getCost(heur)) return -1;  //this < that
            if(that.getCost(heur) < this.getCost(heur)) return 1;   //that < this
            return 0;  //this == that
        }

        // returns the cost to travel from starting point to this
        // via the fromNode chain
        public float getCost(float heuristic) {  //call getCost with heuristic of 0, get travel cost, do A* search
            //return fromNode.getCost(0) + terrain.computeTravelCost(fromNode.loc, loc) + heuristic*terrain.computeDistance(loc.getI(), loc.getJ(), endNode.loc.getI(), endNode.loc.getJ());
            //StdOut.println(heuristic);
            //StdOut.println(terrain.computeDistance(loc.getI(), loc.getJ(), end.getI(), end.getJ()));
            //StdOut.println("Cost:" + cost);
            return cost + heuristic*terrain.computeDistance(loc.getI(), loc.getJ(), end.getI(), end.getJ());
        }

        // returns if this PFNode is not marked invalid
        public boolean isValid() {
            return invalid;
        }

        // marks the PFNode as invalid
        public void invalidate() {
            invalid = true;
        }

        // returns if the PFNode is marked as used
        public boolean isUsed() {  //help
            return isUsed;
        }

        // marks the PFNode as used
        public void use(PFNode node) {
            node.isUsed = true;
        }

        // returns an Iterable of PFNodes that surround this
        public Iterable<PFNode> neighbors() {
            Stack<PFNode> s = new Stack<>();
            s.push(new PFNode(null, null));
            return s;
        }
    }

    public Pathfinder(Terrain terrain) {
        this.terrain = terrain;
    }

    public void setPathStart(Coord loc) { // I need a check to see how it can stay on the white area.
        if(loc == null) throw new IllegalArgumentException("The location is null.");
        if(!loc.isInBounds(0,0,terrain.getN()-1, terrain.getN()-1)) throw new IndexOutOfBoundsException("The location is out of bounds.");
        start = loc;
    }

    public Coord getPathStart() {
        return start;
    }

    public void setPathEnd(Coord loc) {
        if(loc == null) throw new IllegalArgumentException("The location is null.");
        if(!loc.isInBounds(0,0,terrain.getN()-1, terrain.getN()-1)) throw new IndexOutOfBoundsException("The location is out of bounds.");
        end = loc;
    }

    public Coord getPathEnd() {
        return end;
    }

    public void setHeuristic(float v) { // is this correct?
        heur = v;
    }

    public float getHeuristic() { return heur; }

    public void resetPath() {
        start = getPathStart(); //how do I tell it to find where the mouse is at? setPathStart?
        end = getPathEnd();
        endNode = null;
        pathFound = false;
        searchSize = 0;

        pq = new MinPQ<>();

        stack = new Stack<>();

        //computePath();
    }

    public void computePath() {
        if(getPathEnd() == null || getPathStart() == null) throw new IllegalArgumentException("Either or both of start path or end path have NOT been set.");

        //set up logic board with 2D array
        int N = terrain.getN();
        board = new PFNode[N][N];

        //I added this... is it needed?
        //setHeuristic(3);

        PFNode beginNode = new PFNode(getPathStart(), null);
        board[getPathStart().getI()][getPathStart().getJ()] = beginNode;
        pq.insert(beginNode);
        beginNode.use(beginNode);
        beginNode.cost = 0;
        searchSize = 0;
        while(!pathFound){
            //StdOut.println("path not found");
            //remove from pq
            PFNode removed = pq.delMin();
            //StdOut.println("The minimum has been removed.");  //bug check
            //check if node is at end
            if(removed.loc.equals(getPathEnd())){  //correct?
                pq.insert(removed);
                endNode = removed;
                pathFound = true;
                endNode.use(endNode);
                endNode.cost = removed.cost + terrain.computeTravelCost(removed.loc, endNode.loc);
                pathCost = endNode.cost;
                searchSize ++;
                break;
            }
            //"process" node just removed
            //see if the locations around the removed position are in bounds
            //now have them point to removed, "from = removed";  ?
            if(removed.loc.getJ() -1 >= 0 ){
               if(board[removed.loc.getI()][removed.loc.getJ()-1] == null){
                    PFNode node = new PFNode(removed.loc.add(0, -1), removed); //good
                    board[removed.loc.getI()][removed.loc.getJ() - 1] = node;
                    pq.insert(node);
                    node.use(node);
                    searchSize ++;
                    //node.cost = removed.cost + terrain.computeTravelCost(removed.loc, node.loc);
                }
            }
            if(removed.loc.getI() - 1 >= 0){
                if(board[removed.loc.getI()-1][removed.loc.getJ()] == null) {
                    PFNode node = new PFNode(removed.loc.add(-1, 0), removed); //good
                    board[removed.loc.getI() - 1][removed.loc.getJ()] = node;
                    pq.insert(node);
                    node.use(node);
                    searchSize ++;
                    //node.cost = removed.cost + terrain.computeTravelCost(removed.loc, node.loc);
                }
            }
            if(removed.loc.getJ() + 1 < N-1){
                if(board[removed.loc.getI()][removed.loc.getJ()+1] == null) {
                    PFNode node = new PFNode(removed.loc.add(0, 1), removed); //good
                    board[removed.loc.getI()][removed.loc.getJ() + 1] = node;
                    pq.insert(node);
                    node.use(node);
                    searchSize ++;
                    //node.cost = removed.cost + terrain.computeTravelCost(removed.loc, node.loc);
                }
            }
            if(removed.loc.getI() + 1 < N-1){
                if(board[removed.loc.getI()+1][removed.loc.getJ()] == null) {
                    PFNode node = new PFNode(removed.loc.add(1, 0), removed); //good
                    board[removed.loc.getI() + 1][removed.loc.getJ()] = node;
                    pq.insert(node);
                    node.use(node);
                    searchSize ++;
                    //node.cost = removed.cost + terrain.computeTravelCost(removed.loc, node.loc);
                }
            }
        }
        StdOut.println("A connection has been found!");

        stack.push(endNode.loc);
        PFNode nextNode = endNode.fromNode;
        while(nextNode.fromNode != beginNode){
            stack.push(nextNode.loc);
            nextNode = nextNode.fromNode;
        }
        //this should be the start node
        stack.push(nextNode.fromNode.loc);
    }

    public boolean foundPath() { //good
        return pathFound;
    }

    public float getPathCost() { //good
        return pathCost;
    }

    public int getSearchSize() { //good
        return searchSize;
    }

    public Iterable<Coord> getPathSolution() {
        return stack;
    } //good

    public boolean wasSearched(Coord loc) { //good
        return board[loc.getI()][loc.getJ()] != null;
    }

}

--[ 2020.07.17.00.48.11.175.0 ]--
InitFile: /.cos265


--[ 2020.07.17.00.48.37.004.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2020.07.17.00.49.40.774.0 ]--
:/src/InteractivePathfinderVisualizer.java
r 46     private final static String emapFilename = emaps[11];        // change index to load a different elevation map
--[ 2020.07.17.00.49.47.412.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2020.07.17.00.51.11.713.0 ]--
r 46     private final static String emapFilename = emaps[2];        // change index to load a different elevation map
--[ 2020.07.17.00.51.19.337.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2020.07.17.00.52.52.361.0 ]--
r 46     private final static String emapFilename = emaps[1];        // change index to load a different elevation map
--[ 2020.07.17.00.52.58.635.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2020.07.17.00.54.39.513.0 ]--
r 46     private final static String emapFilename = emaps[];        // change index to load a different elevation map
--[ 2020.07.17.00.54.47.059.0 ]--
r 46     private final static String emapFilename = emaps[5];        // change index to load a different elevation map
--[ 2020.07.17.00.54.52.301.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2020.07.17.00.57.34.953.0 ]--
DisposeComponent
